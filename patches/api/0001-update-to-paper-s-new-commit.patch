From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Outfit7TSB <sunnybunnies09@naver.com>
Date: Tue, 21 Jan 2025 08:40:15 +0900
Subject: [PATCH] update to paper's new commit

- NogyangSpigot -
code ripped from Paper Repo
and made into a patch
(CODE CONFLICT WARNING WHEN UPDATING UPSTREAM)

diff --git a/src/main/java/com/destroystokyo/paper/event/block/BlockDestroyEvent.java b/src/main/java/com/destroystokyo/paper/event/block/BlockDestroyEvent.java
index 122ccdef02c292c5705a6ac0a96e6095d28bd7bf..78084f4c909f5ec5d129987eb313dd4b9d48db52 100644
--- a/src/main/java/com/destroystokyo/paper/event/block/BlockDestroyEvent.java
+++ b/src/main/java/com/destroystokyo/paper/event/block/BlockDestroyEvent.java
@@ -55,7 +55,7 @@ public class BlockDestroyEvent extends BlockExpEvent implements Cancellable {
      * @param effectBlock block effect
      */
     public void setEffectBlock(final BlockData effectBlock) {
-        this.effectBlock = effectBlock;
+        this.effectBlock = effectBlock.clone();
     }
 
     /**
diff --git a/src/main/java/com/destroystokyo/paper/event/player/PlayerJumpEvent.java b/src/main/java/com/destroystokyo/paper/event/player/PlayerJumpEvent.java
index 1d07c3d6bf3b9283371ca45698178979113085fa..e3d4c3f9127be5d3697dd8730be2fbbd7ff9c269 100644
--- a/src/main/java/com/destroystokyo/paper/event/player/PlayerJumpEvent.java
+++ b/src/main/java/com/destroystokyo/paper/event/player/PlayerJumpEvent.java
@@ -79,7 +79,7 @@ public class PlayerJumpEvent extends PlayerEvent implements Cancellable {
     public void setFrom(final Location from) {
         Preconditions.checkArgument(from != null, "Cannot use null from location!");
         Preconditions.checkArgument(from.getWorld() != null, "Cannot use from location with null world!");
-        this.from = from;
+        this.from = from.clone();
     }
 
     /**
diff --git a/src/main/java/com/destroystokyo/paper/event/player/PlayerSetSpawnEvent.java b/src/main/java/com/destroystokyo/paper/event/player/PlayerSetSpawnEvent.java
index 41d42d73cf65e9b8acac9d0b2dfd6537b532be74..1688c2c4ee3bfea6cf58ef90fab78c4a8a7e126f 100644
--- a/src/main/java/com/destroystokyo/paper/event/player/PlayerSetSpawnEvent.java
+++ b/src/main/java/com/destroystokyo/paper/event/player/PlayerSetSpawnEvent.java
@@ -66,7 +66,7 @@ public class PlayerSetSpawnEvent extends PlayerEvent implements Cancellable {
      * @param location the spawn location, or {@code null} to remove the spawn location
      */
     public void setLocation(final @Nullable Location location) {
-        this.location = location;
+        this.location = location != null ? location.clone() : null;
     }
 
     /**
diff --git a/src/main/java/com/destroystokyo/paper/event/player/PlayerUseUnknownEntityEvent.java b/src/main/java/com/destroystokyo/paper/event/player/PlayerUseUnknownEntityEvent.java
index 9ff2bbf7f99df45cc626cad60bec4d14a8a04e3e..99610d0fecfe1553cee33ef2182f5dcfe17e4b82 100644
--- a/src/main/java/com/destroystokyo/paper/event/player/PlayerUseUnknownEntityEvent.java
+++ b/src/main/java/com/destroystokyo/paper/event/player/PlayerUseUnknownEntityEvent.java
@@ -11,7 +11,7 @@ import org.jspecify.annotations.NullMarked;
 import org.jspecify.annotations.Nullable;
 
 /**
- * Represents an event that is called when a player right-clicks an unknown entity.
+ * Represents an event that is called when a player clicks an unknown entity.
  * Useful for plugins dealing with virtual entities (entities that aren't actually spawned on the server).
  * <br>
  * This event may be called multiple times per interaction with different interaction hands
diff --git a/src/main/java/com/destroystokyo/paper/event/server/PaperServerListPingEvent.java b/src/main/java/com/destroystokyo/paper/event/server/PaperServerListPingEvent.java
index acff2ff570f8419ffa4dfefe890795c63d75325d..f87e304f831817868fdde35ffad4b7e35d133208 100644
--- a/src/main/java/com/destroystokyo/paper/event/server/PaperServerListPingEvent.java
+++ b/src/main/java/com/destroystokyo/paper/event/server/PaperServerListPingEvent.java
@@ -304,8 +304,7 @@ public class PaperServerListPingEvent extends ServerListPingEvent implements Can
         return new PlayerIterator();
     }
 
-    @NotNull
-    protected Object[] getOnlinePlayers() {
+    protected @NotNull Object @NotNull [] getOnlinePlayers() {
         return Bukkit.getOnlinePlayers().toArray();
     }
 
diff --git a/src/main/java/io/papermc/paper/InternalAPIBridge.java b/src/main/java/io/papermc/paper/InternalAPIBridge.java
new file mode 100644
index 0000000000000000000000000000000000000000..511da534a02b78efa0d46a6b3405c183984a4b14
--- /dev/null
+++ b/src/main/java/io/papermc/paper/InternalAPIBridge.java
@@ -0,0 +1,39 @@
+package io.papermc.paper;
+
+import net.kyori.adventure.util.Services;
+import org.bukkit.damage.DamageEffect;
+import org.jetbrains.annotations.ApiStatus;
+import org.jspecify.annotations.NullMarked;
+
+/**
+ * Static bridge to the server internals.
+ * <p>
+ * Any and all methods in here are *not* to be called by plugin developers, may change at any time and may generally
+ * cause issues when called under unexpected circumstances.
+ */
+@ApiStatus.Internal
+@NullMarked
+public interface InternalAPIBridge {
+
+    /**
+     * Yields the instance of this API bridge by lazily requesting it from the java service loader API.
+     *
+     * @return the instance.
+     */
+    static InternalAPIBridge get() {
+        class Holder {
+            public static final InternalAPIBridge INSTANCE = Services.service(InternalAPIBridge.class).orElseThrow();
+        }
+
+        return Holder.INSTANCE;
+    }
+
+    /**
+     * Creates a damage effect instance for the passed key.
+     *
+     * @param key the string key.
+     * @return the damage effect.
+     */
+    DamageEffect getDamageEffect(String key);
+}
+
diff --git a/src/main/java/io/papermc/paper/command/brigadier/CommandSourceStack.java b/src/main/java/io/papermc/paper/command/brigadier/CommandSourceStack.java
index ac6f5b754a15e85ce09de4ed4cdee2044b45022c..109c0a89e25284df5f0551b9205e75c6f0d700ca 100644
--- a/src/main/java/io/papermc/paper/command/brigadier/CommandSourceStack.java
+++ b/src/main/java/io/papermc/paper/command/brigadier/CommandSourceStack.java
@@ -1,5 +1,7 @@
 package io.papermc.paper.command.brigadier;
 
+import com.mojang.brigadier.RedirectModifier;
+import com.mojang.brigadier.tree.CommandNode;
 import org.bukkit.Location;
 import org.bukkit.command.CommandSender;
 import org.bukkit.entity.Entity;
@@ -48,4 +50,24 @@ public interface CommandSourceStack {
      * @return entity that executes this command
      */
     @Nullable Entity getExecutor();
+
+    /**
+     * Creates a new CommandSourceStack object with a different location for redirecting commands to other nodes.
+     *
+     * @param location The location to create a new CommandSourceStack object with
+     * @return The newly created CommandSourceStack
+     * @see #getLocation()
+     * @see com.mojang.brigadier.builder.ArgumentBuilder#fork(CommandNode, RedirectModifier)
+     */
+    CommandSourceStack withLocation(Location location);
+
+    /**
+     * Creates a new CommandSourceStack object with a different executor for redirecting commands to other nodes.
+     *
+     * @param executor The executing entity to create a new CommandSourceStack object with
+     * @return The newly created CommandSourceStack
+     * @see #getExecutor()
+     * @see com.mojang.brigadier.builder.ArgumentBuilder#fork(CommandNode, RedirectModifier)
+     */
+    CommandSourceStack withExecutor(Entity executor);
 }
diff --git a/src/main/java/io/papermc/paper/command/brigadier/argument/CustomArgumentType.java b/src/main/java/io/papermc/paper/command/brigadier/argument/CustomArgumentType.java
index 91d40ef0bdbdee3609e33577782c5cce29deda6a..14be89fab5bf32f2ef75017b62ea4ba408416285 100644
--- a/src/main/java/io/papermc/paper/command/brigadier/argument/CustomArgumentType.java
+++ b/src/main/java/io/papermc/paper/command/brigadier/argument/CustomArgumentType.java
@@ -37,10 +37,31 @@ public interface CustomArgumentType<T, N> extends ArgumentType<T> {
      * @param reader string reader input
      * @return parsed value
      * @throws CommandSyntaxException if an error occurs while parsing
+     * @see #parse(StringReader, Object)
      */
     @Override
     T parse(final StringReader reader) throws CommandSyntaxException;
 
+    /**
+     * Parses the argument into the custom type ({@code T}). Keep in mind
+     * that this parsing will be done on the server. This means that if
+     * you throw a {@link CommandSyntaxException} during parsing, this
+     * will only show up to the user after the user has executed the command
+     * not while they are still entering it.
+     * <p>
+     * This method provides the command source for additional context when parsing. You
+     * may have to do your own {@code instanceof} checks for {@link io.papermc.paper.command.brigadier.CommandSourceStack}.
+     *
+     * @param reader string reader input
+     * @param source source of the command
+     * @return parsed value
+     * @throws CommandSyntaxException if an error occurs while parsing
+     */
+    @Override
+    default <S> T parse(final StringReader reader, final S source) throws CommandSyntaxException {
+        return ArgumentType.super.parse(reader, source);
+    }
+
     /**
      * Gets the native type that this argument uses,
      * the type that is sent to the client.
@@ -95,13 +116,35 @@ public interface CustomArgumentType<T, N> extends ArgumentType<T> {
             return this.convert(this.getNativeType().parse(reader));
         }
 
+        @ApiStatus.NonExtendable
+        @Override
+        default <S> T parse(final StringReader reader, final S source) throws CommandSyntaxException {
+            return this.convert(this.getNativeType().parse(reader, source), source);
+        }
+
         /**
          * Converts the value from the native type to the custom argument type.
          *
          * @param nativeType native argument provided value
          * @return converted value
          * @throws CommandSyntaxException if an exception occurs while parsing
+         * @see #convert(Object, Object)
          */
         T convert(N nativeType) throws CommandSyntaxException;
+
+        /**
+         * Converts the value from the native type to the custom argument type.
+         * <p>
+         * This method provides the command source for additional context when converting. You
+         * may have to do your own {@code instanceof} checks for {@link io.papermc.paper.command.brigadier.CommandSourceStack}.
+         *
+         * @param nativeType native argument provided value
+         * @param source     source of the command
+         * @return converted value
+         * @throws CommandSyntaxException if an exception occurs while parsing
+         */
+        default <S> T convert(final N nativeType, final S source) throws CommandSyntaxException {
+            return this.convert(nativeType);
+        }
     }
 }
diff --git a/src/main/java/io/papermc/paper/datacomponent/item/DamageResistant.java b/src/main/java/io/papermc/paper/datacomponent/item/DamageResistant.java
index 6cbd73cb2a11f4858b44a2f57d2fe0acb1eb9fb5..384098ea55d7c3cc571bd5560be23a0c785b1dc4 100644
--- a/src/main/java/io/papermc/paper/datacomponent/item/DamageResistant.java
+++ b/src/main/java/io/papermc/paper/datacomponent/item/DamageResistant.java
@@ -21,9 +21,9 @@ public interface DamageResistant {
     }
 
     /**
-     * The types that this damage type is invincible tp.
+     * The types that this damage type is invincible to.
      *
-     * @return item
+     * @return the key of the tag holding the respective damage types.
      */
     @Contract(value = "-> new", pure = true)
     TagKey<DamageType> types();
diff --git a/src/main/java/io/papermc/paper/datapack/Datapack.java b/src/main/java/io/papermc/paper/datapack/Datapack.java
index 95039ec90f81993cb2e36f82b7d13e9e7a30220e..fff0cdb98f1baa04054ce85c2fb1fb460023f050 100644
--- a/src/main/java/io/papermc/paper/datapack/Datapack.java
+++ b/src/main/java/io/papermc/paper/datapack/Datapack.java
@@ -1,10 +1,8 @@
 package io.papermc.paper.datapack;
 
-import java.util.Set;
 import net.kyori.adventure.text.Component;
-import org.bukkit.FeatureFlag;
+import org.jetbrains.annotations.ApiStatus;
 import org.jetbrains.annotations.Contract;
-import org.jetbrains.annotations.Unmodifiable;
 import org.jspecify.annotations.NullMarked;
 
 /**
@@ -12,50 +10,8 @@ import org.jspecify.annotations.NullMarked;
  * won't be updated as datapacks are updated.
  */
 @NullMarked
-public interface Datapack {
-
-    /**
-     * Gets the name/id of this datapack.
-     *
-     * @return the name of the pack
-     */
-    @Contract(pure = true)
-    String getName();
-
-    /**
-     * Gets the title component of this datapack.
-     *
-     * @return the title
-     */
-    Component getTitle();
-
-    /**
-     * Gets the description component of this datapack.
-     *
-     * @return the description
-     */
-    Component getDescription();
-
-    /**
-     * Gets if this datapack is required to be enabled.
-     *
-     * @return true if the pack is required
-     */
-    boolean isRequired();
-
-    /**
-     * Gets the compatibility status of this pack.
-     *
-     * @return the compatibility of the pack
-     */
-    Compatibility getCompatibility();
-
-    /**
-     * Gets the set of required features for this datapack.
-     *
-     * @return the set of required features
-     */
-    @Unmodifiable Set<FeatureFlag> getRequiredFeatures();
+@ApiStatus.NonExtendable
+public interface Datapack extends DiscoveredDatapack {
 
     /**
      * Gets the enabled state of this pack.
@@ -74,13 +30,6 @@ public interface Datapack {
      */
     void setEnabled(boolean enabled);
 
-    /**
-     * Gets the source for this datapack.
-     *
-     * @return the pack source
-     */
-    DatapackSource getSource();
-
     /**
      * Computes the component vanilla Minecraft uses
      * to display this datapack. Includes the {@link #getSource()},
@@ -96,4 +45,11 @@ public interface Datapack {
         TOO_NEW,
         COMPATIBLE,
     }
+
+    /**
+     * Position of the pack in the load order.
+     */
+    enum Position {
+        TOP, BOTTOM
+    }
 }
diff --git a/src/main/java/io/papermc/paper/datapack/DatapackRegistrar.java b/src/main/java/io/papermc/paper/datapack/DatapackRegistrar.java
new file mode 100644
index 0000000000000000000000000000000000000000..b009df66dbb990be71bdbe995cbc3fa403c2c1c8
--- /dev/null
+++ b/src/main/java/io/papermc/paper/datapack/DatapackRegistrar.java
@@ -0,0 +1,202 @@
+package io.papermc.paper.datapack;
+
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.lifecycle.event.registrar.Registrar;
+import java.io.IOException;
+import java.net.URI;
+import java.nio.file.Path;
+import java.util.Map;
+import java.util.function.Consumer;
+import net.kyori.adventure.text.Component;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.Unmodifiable;
+import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.Nullable;
+
+/**
+ * The registrar for datapacks. The event for this registrar
+ * is called anytime the game tries to discover datapacks at any of the
+ * configured locations. This means that if a datapack should stay available to the server,
+ * it must always be discovered whenever this event fires.
+ * <p>An example of a plugin loading a datapack from within it's own jar is below</p>
+ * <pre>{@code
+ * public class YourPluginBootstrap implements PluginBootstrap {
+ *     @Override
+ *     public void bootstrap(BoostrapContext context) {
+ *         final LifecycleEventManager<BootstrapContext> manager = context.getLifecycleManager();
+ *         manager.registerEventHandler(LifecycleEvents.DATAPACK_DISCOVERY, event -> {
+ *             DatapackRegistrar registrar = event.registrar();
+ *             try {
+ *                 final URI uri = Objects.requireNonNull(
+ *                     YourPluginBootstrap.class.getResource("/pack")
+ *                 ).toURI();
+ *                 registrar.discoverPack(uri, "packId");
+ *             } catch (final URISyntaxException | IOException e) {
+ *                 throw new RuntimeException(e);
+ *             }
+ *         });
+ *     }
+ * }
+ * }</pre>
+ * @see io.papermc.paper.plugin.lifecycle.event.types.LifecycleEvents#DATAPACK_DISCOVERY
+ */
+@ApiStatus.NonExtendable
+@ApiStatus.Experimental
+@NullMarked
+public interface DatapackRegistrar extends Registrar {
+
+    /**
+     * Checks if a datapack with the specified name has been discovered.
+     *
+     * @param name the name of the pack
+     * @return true if the pack has been discovered
+     * @see Datapack#getName()
+     */
+    @Contract(pure = true)
+    boolean hasPackDiscovered(String name);
+
+    /**
+     * Gets a discovered datapack by its name.
+     *
+     * @param name the name of the pack
+     * @return the datapack
+     * @throws java.util.NoSuchElementException if the pack is not discovered
+     * @see Datapack#getName()
+     */
+    @Contract(pure = true)
+    DiscoveredDatapack getDiscoveredPack(String name);
+
+    /**
+     * Removes a discovered datapack by its name.
+     *
+     * @param name the name of the pack
+     * @return true if the pack was removed
+     * @see Datapack#getName()
+     */
+    @Contract(mutates = "this")
+    boolean removeDiscoveredPack(String name);
+
+    /**
+     * Gets all discovered datapacks.
+     *
+     * @return an unmodifiable map of discovered packs
+     */
+    @Contract(pure = true)
+    @Unmodifiable Map<String, DiscoveredDatapack> getDiscoveredPacks();
+
+    /**
+     * Discovers a datapack at the specified {@link URI} with the id.
+     * <p>Symlinks obey the {@code allowed_symlinks.txt} in the server root directory.</p>
+     *
+     * @param uri the location of the pack
+     * @param id a unique id (will be combined with plugin for the datapacks name)
+     * @return the discovered datapack (or null if it failed)
+     * @throws IOException if any IO error occurs
+     */
+    default @Nullable DiscoveredDatapack discoverPack(final URI uri, final String id) throws IOException {
+        return this.discoverPack(uri, id, c -> {});
+    }
+
+    /**
+     * Discovers a datapack at the specified {@link URI} with the id.
+     * <p>Symlinks obey the {@code allowed_symlinks.txt} in the server root directory.</p>
+     *
+     * @param uri the location of the pack
+     * @param id a unique id (will be combined with plugin for the datapacks name)
+     * @param configurer a configurer for extra options
+     * @return the discovered datapack (or null if it failed)
+     * @throws IOException if any IO error occurs
+     */
+    @Nullable DiscoveredDatapack discoverPack(URI uri, String id, Consumer<Configurer> configurer) throws IOException;
+
+    /**
+     * Discovers a datapack at the specified {@link Path} with the id.
+     * <p>Symlinks obey the {@code allowed_symlinks.txt} in the server root directory.</p>
+     *
+     * @param path the location of the pack
+     * @param id a unique id (will be combined with plugin for the datapacks name)
+     * @return the discovered datapack (or null if it failed)
+     * @throws IOException if any IO error occurs
+     */
+    default @Nullable DiscoveredDatapack discoverPack(final Path path, final String id) throws IOException {
+        return this.discoverPack(path, id, c -> {});
+    }
+
+    /**
+     * Discovers a datapack at the specified {@link Path} with the id.
+     * <p>Symlinks obey the {@code allowed_symlinks.txt} in the server root directory.</p>
+     *
+     * @param path the location of the pack
+     * @param id a unique id (will be combined with plugin for the datapacks name)
+     * @param configurer a configurer for extra options
+     * @return the discovered datapack (or null if it failed)
+     * @throws IOException if any IO error occurs
+     */
+    @Nullable DiscoveredDatapack discoverPack(Path path, String id, Consumer<Configurer> configurer) throws IOException;
+
+    /**
+     * Discovers a datapack at the specified {@link URI} with the id.
+     * <p>Symlinks obey the {@code allowed_symlinks.txt} in the server root directory.</p>
+     *
+     * @param pluginMeta the plugin which will be the "owner" of this datapack
+     * @param uri the location of the pack
+     * @param id a unique id (will be combined with plugin for the datapacks name)
+     * @param configurer a configurer for extra options
+     * @return the discovered datapack (or null if it failed)
+     * @throws IOException if any IO error occurs
+     */
+    @Nullable DiscoveredDatapack discoverPack(PluginMeta pluginMeta, URI uri, String id, Consumer<Configurer> configurer) throws IOException;
+
+    /**
+     * Discovers a datapack at the specified {@link Path} with the id.
+     * <p>Symlinks obey the {@code allowed_symlinks.txt} in the server root directory.</p>
+     *
+     * @param pluginMeta the plugin which will be the "owner" of this datapack
+     * @param path the location of the pack
+     * @param id a unique id (will be combined with plugin for the datapacks name)
+     * @param configurer a configurer for extra options
+     * @return the discovered datapack (or null if it failed)
+     * @throws IOException if any IO error occurs
+     */
+    @Nullable DiscoveredDatapack discoverPack(PluginMeta pluginMeta, Path path, String id, Consumer<Configurer> configurer) throws IOException;
+
+    /**
+     * Configures additional, optional, details about a datapack.
+     */
+    @ApiStatus.NonExtendable
+    @ApiStatus.Experimental
+    interface Configurer {
+
+        /**
+         * Changes the title of the datapack from the default which
+         * is just the "id" in the {@code registerPack} methods.
+         *
+         * @param title the new title
+         * @return the configurer for chaining
+         */
+        @Contract(value = "_ -> this", mutates = "this")
+        Configurer title(Component title);
+
+        /**
+         * Sets whether this pack is going to be automatically enabled on server starts even if previously disabled.
+         * Defaults to false.
+         *
+         * @param autoEnableOnServerStart true to ensure the pack is enabled on server starts.
+         * @return the configurer for chaining
+         */
+        @Contract(value = "_ -> this", mutates = "this")
+        Configurer autoEnableOnServerStart(boolean autoEnableOnServerStart);
+
+        /**
+         * Configures the position in the
+         * load order of this datapack.
+         *
+         * @param fixed won't move around in the load order as packs are added/removed
+         * @param position try to insert at the top of the order or bottom
+         * @return the configurer for chaining
+         */
+        @Contract(value = "_, _ -> this", mutates = "this")
+        Configurer position(boolean fixed, Datapack.Position position);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/datapack/DatapackSource.java b/src/main/java/io/papermc/paper/datapack/DatapackSource.java
index b9b81cd974c2df501fef55bd8d9b78406c073038..1739d598f96536c504cccf166f182a417f4522af 100644
--- a/src/main/java/io/papermc/paper/datapack/DatapackSource.java
+++ b/src/main/java/io/papermc/paper/datapack/DatapackSource.java
@@ -13,6 +13,7 @@ public sealed interface DatapackSource permits DatapackSourceImpl {
     DatapackSource FEATURE = create("feature");
     DatapackSource WORLD = create("world");
     DatapackSource SERVER = create("server");
+    DatapackSource PLUGIN = create("plugin");
 
     private static DatapackSource create(final String name) {
         return new DatapackSourceImpl(name);
diff --git a/src/main/java/io/papermc/paper/datapack/DiscoveredDatapack.java b/src/main/java/io/papermc/paper/datapack/DiscoveredDatapack.java
new file mode 100644
index 0000000000000000000000000000000000000000..984507ba0f2f25d4210a1fa7b24f04bdd57e8305
--- /dev/null
+++ b/src/main/java/io/papermc/paper/datapack/DiscoveredDatapack.java
@@ -0,0 +1,74 @@
+package io.papermc.paper.datapack;
+
+import java.util.Set;
+import net.kyori.adventure.text.Component;
+import org.bukkit.FeatureFlag;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.Unmodifiable;
+import org.jspecify.annotations.NullMarked;
+
+/**
+ * Represents a snapshot of a datapack that the server has found by
+ * searching available sources. It may or may not be enabled and isn't
+ * guaranteed to be available. This object won't be
+ * updated as datapacks are updated.
+ * @see DatapackRegistrar
+ */
+@NullMarked
+@ApiStatus.NonExtendable
+public interface DiscoveredDatapack {
+
+    /**
+     * Gets the name/id of this datapack.
+     *
+     * @return the name of the pack
+     */
+    @Contract(pure = true)
+    String getName();
+
+    /**
+     * Gets the title component of this datapack.
+     *
+     * @return the title
+     */
+    Component getTitle();
+
+    /**
+     * Gets the description component of this datapack.
+     *
+     * @return the description
+     */
+    Component getDescription();
+
+    /**
+     * Gets if this datapack is required.
+     * <p>
+     * A "required" datapack will always be enabled on server startup, even if previously disabled.
+     *
+     * @return true if the pack is required
+     */
+    boolean isRequired();
+
+    /**
+     * Gets the compatibility status of this pack.
+     *
+     * @return the compatibility of the pack
+     */
+    Datapack.Compatibility getCompatibility();
+
+    /**
+     * Gets the set of required features for this datapack.
+     *
+     * @return the set of required features
+     */
+    @Unmodifiable
+    Set<FeatureFlag> getRequiredFeatures();
+
+    /**
+     * Gets the source for this datapack.
+     *
+     * @return the pack source
+     */
+    DatapackSource getSource();
+}
diff --git a/src/main/java/io/papermc/paper/entity/EntitySerializationFlag.java b/src/main/java/io/papermc/paper/entity/EntitySerializationFlag.java
new file mode 100644
index 0000000000000000000000000000000000000000..4a76c3491baf153ff8e1156b3c288ab91da163aa
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/EntitySerializationFlag.java
@@ -0,0 +1,38 @@
+package io.papermc.paper.entity;
+
+import org.bukkit.UnsafeValues;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+
+/**
+ * Represents flags for entity serialization.
+ *
+ * @see UnsafeValues#serializeEntity(Entity, EntitySerializationFlag... serializationFlags)
+ * @since 1.21.4
+ */
+public enum EntitySerializationFlag {
+
+    /**
+     * Serialize entities that wouldn't be serialized normally
+     * (e.g. dead, despawned, non-persistent, etc.).
+     *
+     * @see Entity#isValid()
+     * @see Entity#isPersistent()
+     */
+    FORCE,
+    /**
+     * Serialize misc non-saveable entities like lighting bolts, fishing bobbers, etc.
+     * <br>Note: players require a separate flag: {@link #PLAYER}.
+     */
+    MISC,
+    /**
+     * Include passengers in the serialized data.
+     */
+    PASSENGERS,
+    /**
+     * Allow serializing {@link Player}s.
+     * <p>Note: deserializing player data will always fail.
+     */
+    PLAYER
+
+}
diff --git a/src/main/java/io/papermc/paper/event/entity/EntityEffectTickEvent.java b/src/main/java/io/papermc/paper/event/entity/EntityEffectTickEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..fef69314f616a92f55b4ad387a5b064d5cf9f54d
--- /dev/null
+++ b/src/main/java/io/papermc/paper/event/entity/EntityEffectTickEvent.java
@@ -0,0 +1,75 @@
+package io.papermc.paper.event.entity;
+
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.entity.EntityEvent;
+import org.bukkit.potion.PotionEffectType;
+import org.jetbrains.annotations.ApiStatus;
+import org.jspecify.annotations.NullMarked;
+
+/**
+ * An event that is triggered when an entity receives a potion effect instantly
+ * or when the potion effect is applied on each tick (e.g. every 25 ticks for Poison level 1).
+ * <p>
+ * For example, this event may be called when an entity regenerates health
+ * or takes poison damage as a result of a potion effect.
+ */
+@NullMarked
+public class EntityEffectTickEvent extends EntityEvent implements Cancellable {
+
+    private static final HandlerList HANDLER_LIST = new HandlerList();
+
+    private final PotionEffectType type;
+    private final int amplifier;
+    private boolean cancelled;
+
+    @ApiStatus.Internal
+    public EntityEffectTickEvent(final LivingEntity entity, final PotionEffectType type, final int amplifier) {
+        super(entity);
+        this.type = type;
+        this.amplifier = amplifier;
+    }
+
+    @Override
+    public LivingEntity getEntity() {
+        return (LivingEntity) super.getEntity();
+    }
+
+    /**
+     * Gets the type of the potion effect associated with this event.
+     *
+     * @return the {@link PotionEffectType} of the effect
+     */
+    public PotionEffectType getType() {
+        return type;
+    }
+
+    /**
+     * Gets the amplifier level of the potion effect associated with this event.
+     *
+     * @return the amplifier level of the potion effect
+     */
+    public int getAmplifier() {
+        return amplifier;
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return this.cancelled;
+    }
+
+    @Override
+    public void setCancelled(final boolean cancel) {
+        this.cancelled = cancel;
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return HANDLER_LIST;
+    }
+
+    public static HandlerList getHandlerList() {
+        return HANDLER_LIST;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/event/entity/EntityMoveEvent.java b/src/main/java/io/papermc/paper/event/entity/EntityMoveEvent.java
index 49ace395393839b3652a537207b4cf5b24beeac0..00fef88d560f118dedc09953198948957054009f 100644
--- a/src/main/java/io/papermc/paper/event/entity/EntityMoveEvent.java
+++ b/src/main/java/io/papermc/paper/event/entity/EntityMoveEvent.java
@@ -53,7 +53,7 @@ public class EntityMoveEvent extends EntityEvent implements Cancellable {
      */
     public void setFrom(final Location from) {
         this.validateLocation(from);
-        this.from = from;
+        this.from = from.clone();
     }
 
     /**
@@ -72,7 +72,7 @@ public class EntityMoveEvent extends EntityEvent implements Cancellable {
      */
     public void setTo(final Location to) {
         this.validateLocation(to);
-        this.to = to;
+        this.to = to.clone();
     }
 
     /**
diff --git a/src/main/java/io/papermc/paper/event/executor/EventExecutorFactory.java b/src/main/java/io/papermc/paper/event/executor/EventExecutorFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..2e3e21c3e9ca8c1fab82250fac9400686242061b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/event/executor/EventExecutorFactory.java
@@ -0,0 +1,74 @@
+package io.papermc.paper.event.executor;
+
+import org.bukkit.event.Event;
+import org.bukkit.event.Listener;
+import org.bukkit.plugin.EventExecutor;
+import org.jetbrains.annotations.ApiStatus;
+import org.jspecify.annotations.NullMarked;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.constant.ConstantDescs;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.List;
+import java.util.Objects;
+
+@ApiStatus.Internal
+@NullMarked
+public final class EventExecutorFactory {
+    private static final byte[] TEMPLATE_CLASS_BYTES;
+
+    static {
+        try (final InputStream is = EventExecutorFactory.class.getResourceAsStream("MethodHandleEventExecutorTemplate.class")) {
+            TEMPLATE_CLASS_BYTES = Objects.requireNonNull(is, "template class is missing").readAllBytes();
+        } catch (IOException e) {
+            throw new AssertionError(e);
+        }
+    }
+
+    private EventExecutorFactory() {
+
+    }
+
+    /**
+     * {@return an {@link EventExecutor} implemented by a hidden class calling a method handle}
+     *
+     * @param method     the method to be invoked by the created event executor
+     * @param eventClass the class of the event to handle
+     */
+    public static EventExecutor create(final Method method, final Class<? extends Event> eventClass) {
+        final List<?> classData = List.of(method, eventClass);
+        try {
+            final MethodHandles.Lookup newClass = MethodHandles.lookup().defineHiddenClassWithClassData(TEMPLATE_CLASS_BYTES, classData, true);
+            return newClass.lookupClass().asSubclass(EventExecutor.class).getDeclaredConstructor().newInstance();
+        } catch (ReflectiveOperationException e) {
+            throw new AssertionError(e);
+        }
+    }
+
+    record ClassData(Method method, MethodHandle methodHandle, Class<? extends Event> eventClass) {
+
+    }
+
+    /**
+     * Extracts the class data and creates an adjusted MethodHandle directly usable by the lookup class.
+     * The logic is kept here to minimize memory usage per created class.
+     */
+    static ClassData classData(final MethodHandles.Lookup lookup) {
+        try {
+            final Method method = MethodHandles.classDataAt(lookup, ConstantDescs.DEFAULT_NAME, Method.class, 0);
+            MethodHandle mh = lookup.unreflect(method);
+            if (Modifier.isStatic(method.getModifiers())) {
+                mh = MethodHandles.dropArguments(mh, 0, Listener.class);
+            }
+            mh = mh.asType(MethodType.methodType(void.class, Listener.class, Event.class));
+            final Class<?> eventClass = MethodHandles.classDataAt(lookup, ConstantDescs.DEFAULT_NAME, Class.class, 1);
+            return new ClassData(method, mh, eventClass.asSubclass(Event.class));
+        } catch (ReflectiveOperationException e) {
+            throw new AssertionError(e);
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/event/executor/MethodHandleEventExecutorTemplate.java b/src/main/java/io/papermc/paper/event/executor/MethodHandleEventExecutorTemplate.java
new file mode 100644
index 0000000000000000000000000000000000000000..b28fcfed9625bc464f22911089cbf04bb5294ad5
--- /dev/null
+++ b/src/main/java/io/papermc/paper/event/executor/MethodHandleEventExecutorTemplate.java
@@ -0,0 +1,56 @@
+package io.papermc.paper.event.executor;
+
+import com.destroystokyo.paper.util.SneakyThrow;
+import org.bukkit.event.Event;
+import org.bukkit.event.EventException;
+import org.bukkit.event.Listener;
+import org.bukkit.plugin.EventExecutor;
+import org.jetbrains.annotations.ApiStatus;
+import org.jspecify.annotations.NullMarked;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.reflect.Method;
+
+/**
+ * This class is designed to be used as hidden class template.
+ * Initializing the class directly will fail due to missing {@code classData}.
+ * Instead, {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClassWithClassData(byte[], Object, boolean, MethodHandles.Lookup.ClassOption...)}
+ * must be used, with the {@code classData} object being a list consisting of two elements:
+ * <ol>
+ *     <li>A {@link Method} representing the event handler method</li>
+ *     <li>A {@link Class} representing the event type</li>
+ * </ol>
+ * The method must take {@link Event} or a subtype of it as its single parameter.
+ * If the method is non-static, it also needs to reside in a class implementing {@link Listener}.
+ */
+@SuppressWarnings("unused")
+@ApiStatus.Internal
+@NullMarked
+class MethodHandleEventExecutorTemplate implements EventExecutor {
+    private static final Method METHOD;
+    private static final MethodHandle HANDLE;
+    private static final Class<? extends Event> EVENT_CLASS;
+
+    static {
+        final MethodHandles.Lookup lookup = MethodHandles.lookup();
+        final EventExecutorFactory.ClassData classData = EventExecutorFactory.classData(lookup);
+        METHOD = classData.method();
+        HANDLE = classData.methodHandle();
+        EVENT_CLASS = classData.eventClass();
+    }
+
+    @Override
+    public void execute(final Listener listener, final Event event) throws EventException {
+        if (!EVENT_CLASS.isInstance(event)) return;
+        try {
+            HANDLE.invokeExact(listener, event);
+        } catch (Throwable t) {
+            SneakyThrow.sneaky(t);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "MethodHandleEventExecutorTemplate['" + METHOD + "']";
+    }
+}
diff --git a/src/main/java/io/papermc/paper/event/world/border/WorldBorderCenterChangeEvent.java b/src/main/java/io/papermc/paper/event/world/border/WorldBorderCenterChangeEvent.java
index 74fe5ad50517374631fa3009249833e2b99a55f0..5f43aefe7a25005112ae2c884557e8944f00b9c5 100644
--- a/src/main/java/io/papermc/paper/event/world/border/WorldBorderCenterChangeEvent.java
+++ b/src/main/java/io/papermc/paper/event/world/border/WorldBorderCenterChangeEvent.java
@@ -52,7 +52,7 @@ public class WorldBorderCenterChangeEvent extends WorldBorderEvent implements Ca
      * @param newCenter the new center
      */
     public void setNewCenter(final Location newCenter) {
-        this.newCenter = newCenter;
+        this.newCenter = newCenter.clone();
     }
 
     @Override
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/LifecycleEvents.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/LifecycleEvents.java
index b65c5fd5443cef80989d55bf684191f849afa0e7..8ff52773b0df277925a96cddce94f5aa5a5ebc8f 100644
--- a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/LifecycleEvents.java
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/LifecycleEvents.java
@@ -1,10 +1,12 @@
 package io.papermc.paper.plugin.lifecycle.event.types;
 
 import io.papermc.paper.command.brigadier.Commands;
+import io.papermc.paper.datapack.DatapackRegistrar;
 import io.papermc.paper.plugin.bootstrap.BootstrapContext;
 import io.papermc.paper.plugin.lifecycle.event.LifecycleEvent;
 import io.papermc.paper.plugin.lifecycle.event.LifecycleEventManager;
 import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import io.papermc.paper.plugin.lifecycle.event.registrar.RegistrarEvent;
 import io.papermc.paper.plugin.lifecycle.event.registrar.ReloadableRegistrarEvent;
 import org.bukkit.plugin.Plugin;
 import org.jetbrains.annotations.ApiStatus;
@@ -32,6 +34,14 @@ public final class LifecycleEvents {
      */
     public static final TagEventTypeProvider TAGS = LifecycleEventTypeProvider.provider().tagProvider();
 
+
+    /**
+     * This event is for informing the server about any available datapacks from other sources such as inside a plugin's jar. You
+     * can register a handler for this event only in {@link io.papermc.paper.plugin.bootstrap.PluginBootstrap#bootstrap(BootstrapContext)}.
+     * @see DatapackRegistrar an example of a datapack being discovered
+     */
+    public static final LifecycleEventType.Prioritizable<BootstrapContext, RegistrarEvent<DatapackRegistrar>> DATAPACK_DISCOVERY = bootstrapPrioritized("datapack_discovery");
+
     //<editor-fold desc="helper methods" defaultstate="collapsed">
     @ApiStatus.Internal
     static <E extends LifecycleEvent> LifecycleEventType.Monitorable<Plugin, E> plugin(final String name) {
diff --git a/src/main/java/io/papermc/paper/potion/PotionMix.java b/src/main/java/io/papermc/paper/potion/PotionMix.java
index 01b2a7c7a6bf328b3f7c30db3be0bfb8156ebc89..41152c98c0a8dd8c6d16079f02476b6c60816f85 100644
--- a/src/main/java/io/papermc/paper/potion/PotionMix.java
+++ b/src/main/java/io/papermc/paper/potion/PotionMix.java
@@ -30,9 +30,9 @@ public final class PotionMix implements Keyed {
      */
     public PotionMix(final NamespacedKey key, final ItemStack result, final RecipeChoice input, final RecipeChoice ingredient) {
         this.key = key;
-        this.result = result;
-        this.input = input;
-        this.ingredient = ingredient;
+        this.result = result.clone();
+        this.input = input.clone();
+        this.ingredient = ingredient.clone();
     }
 
     /**
@@ -58,7 +58,7 @@ public final class PotionMix implements Keyed {
      * @return the result itemstack
      */
     public ItemStack getResult() {
-        return this.result;
+        return this.result.clone();
     }
 
     /**
@@ -67,7 +67,7 @@ public final class PotionMix implements Keyed {
      * @return the bottom 3 slot ingredients
      */
     public RecipeChoice getInput() {
-        return this.input;
+        return this.input.clone();
     }
 
     /**
@@ -76,7 +76,7 @@ public final class PotionMix implements Keyed {
      * @return the top slot input
      */
     public RecipeChoice getIngredient() {
-        return this.ingredient;
+        return this.ingredient.clone();
     }
 
     @Override
diff --git a/src/main/java/io/papermc/paper/registry/RegistryBuilderFactory.java b/src/main/java/io/papermc/paper/registry/RegistryBuilderFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..ce2447d3d6468b2a4200f4d3ff44158f302acf36
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/RegistryBuilderFactory.java
@@ -0,0 +1,39 @@
+package io.papermc.paper.registry;
+
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Contract;
+import org.jspecify.annotations.NullMarked;
+
+/**
+ * A factory to create a {@link RegistryBuilder} for a given {@link TypedKey}. For
+ * each instance of this class, once either {@link #empty()} or {@link #copyFrom(TypedKey)}
+ * is called once, any future calls to either method will throw an {@link IllegalStateException}.
+ *
+ * @param <T> The type of the registry
+ * @param <B> The type of the registry builder
+ */
+@NullMarked
+@ApiStatus.Experimental
+@ApiStatus.NonExtendable
+public interface RegistryBuilderFactory<T, B extends RegistryBuilder<T>> {
+
+    /**
+     * Creates a new empty {@link RegistryBuilder}.
+     *
+     * @return A new empty {@link RegistryBuilder}
+     * @throws IllegalStateException if this method or {@link #copyFrom(TypedKey)}) has already been called once
+     */
+    @Contract("-> new")
+    B empty();
+
+    /**
+     * Creates a new {@link RegistryBuilder} with the same properties as the given {@link TypedKey}.
+     *
+     * @param key The key to copy properties from
+     * @return A new {@link RegistryBuilder} with the same properties as the given key
+     * @throws IllegalStateException if this method or {@link #empty()} has already been called once
+     * @throws IllegalArgumentException if key doesn't exist
+     */
+    @Contract("_ -> new")
+    B copyFrom(TypedKey<T> key);
+}
diff --git a/src/main/java/io/papermc/paper/registry/RegistryKey.java b/src/main/java/io/papermc/paper/registry/RegistryKey.java
index e5319bdb9f75358b8bb0ac35373125a7d94edfa6..ea795de9558f1ec35e072759458d7211cd03a671 100644
--- a/src/main/java/io/papermc/paper/registry/RegistryKey.java
+++ b/src/main/java/io/papermc/paper/registry/RegistryKey.java
@@ -1,6 +1,8 @@
 package io.papermc.paper.registry;
 
 import io.papermc.paper.datacomponent.DataComponentType;
+import net.kyori.adventure.key.Key;
+import net.kyori.adventure.key.KeyPattern;
 import net.kyori.adventure.key.Keyed;
 import org.bukkit.Art;
 import org.bukkit.Fluid;
@@ -200,4 +202,26 @@ public sealed interface RegistryKey<T> extends Keyed permits RegistryKeyImpl {
     RegistryKey<Particle> PARTICLE_TYPE = create("particle_type");
     RegistryKey<PotionType> POTION = create("potion");
     RegistryKey<MemoryKey<?>> MEMORY_MODULE_TYPE = create("memory_module_type");
+
+    /**
+     * Constructs a new {@link TypedKey} for this registry given the typed key's key.
+     *
+     * @param key the key of the typed key.
+     * @return the constructed typed key.
+     */
+    @ApiStatus.Experimental
+    default TypedKey<T> typedKey(final Key key) {
+        return TypedKey.create(this, key);
+    }
+
+    /**
+     * Constructs a new {@link TypedKey} for this registry given the typed key's key.
+     *
+     * @param key the string representation of the key that will be passed to {@link Key#key(String)}.
+     * @return the constructed typed key.
+     */
+    @ApiStatus.Experimental
+    default TypedKey<T> typedKey(final @KeyPattern String key) {
+        return TypedKey.create(this, key);
+    }
 }
diff --git a/src/main/java/io/papermc/paper/registry/TypedKey.java b/src/main/java/io/papermc/paper/registry/TypedKey.java
index 81bee5224196008662ddda528b5dcb8dd7cb9f21..c8f363a2403629d5de0a6ce64b5faeb196303fe6 100644
--- a/src/main/java/io/papermc/paper/registry/TypedKey.java
+++ b/src/main/java/io/papermc/paper/registry/TypedKey.java
@@ -1,6 +1,7 @@
 package io.papermc.paper.registry;
 
 import net.kyori.adventure.key.Key;
+import net.kyori.adventure.key.KeyPattern;
 import net.kyori.adventure.key.Keyed;
 import org.jetbrains.annotations.ApiStatus;
 import org.jspecify.annotations.NullMarked;
@@ -42,4 +43,18 @@ public sealed interface TypedKey<T> extends Key permits TypedKeyImpl {
     static <T> TypedKey<T> create(final RegistryKey<T> registryKey, final Key key) {
         return new TypedKeyImpl<>(key, registryKey);
     }
+
+    /**
+     * Create a typed key from a string and a registry key.
+     *
+     * @param registryKey the registry this key is for
+     * @param key         the string version of a {@link Key} that will be passed to {@link Key#key(String)} for parsing.
+     * @param <T>         value type
+     * @return a new key for the value key and registry key
+     * @see Key#key(String)
+     */
+    @ApiStatus.Experimental
+    static <T> TypedKey<T> create(final RegistryKey<T> registryKey, final @KeyPattern String key) {
+        return create(registryKey, Key.key(key));
+    }
 }
diff --git a/src/main/java/io/papermc/paper/registry/data/BannerPatternRegistryEntry.java b/src/main/java/io/papermc/paper/registry/data/BannerPatternRegistryEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..8ca672a5bb5c8e3f5b0046b5f390c597ff3d2adb
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/data/BannerPatternRegistryEntry.java
@@ -0,0 +1,65 @@
+package io.papermc.paper.registry.data;
+
+import io.papermc.paper.registry.RegistryBuilder;
+import net.kyori.adventure.key.Key;
+import org.bukkit.block.banner.PatternType;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Contract;
+
+/**
+ * A data-centric version-specific registry entry for the {@link PatternType} type.
+ */
+@ApiStatus.Experimental
+@ApiStatus.NonExtendable
+public interface BannerPatternRegistryEntry {
+
+    /**
+     * Provides the asset id of the pattern type, which is the location of the sprite to use.
+     *
+     * @return the asset id.
+     */
+    Key assetId();
+
+    /**
+     * Provides the translation key for displaying the pattern inside the banner's tooltip.
+     *
+     * @return the translation key.
+     */
+    String translationKey();
+
+    /**
+     * A mutable builder for the {@link BannerPatternRegistryEntry} plugins may change in applicable registry events.
+     * <p>
+     * The following values are required for each builder:
+     * <ul>
+     *     <li>{@link #assetId(Key)}</li>
+     *     <li>{@link #translationKey(String)}</li>
+     * </ul>
+     */
+    @ApiStatus.Experimental
+    @ApiStatus.NonExtendable
+    interface Builder extends BannerPatternRegistryEntry, RegistryBuilder<PatternType> {
+
+        /**
+         * Sets the asset id of the pattern type, which is the location of the sprite to use.
+         *
+         * @param assetId the asset id.
+         * @return this builder instance.
+         * @see BannerPatternRegistryEntry#assetId()
+         */
+        @Contract(value = "_ -> this", mutates = "this")
+        Builder assetId(Key assetId);
+
+        /**
+         * Sets the translation key for displaying the pattern inside the banner's tooltip.
+         *
+         * @param translationKey the translation key.
+         * @return this builder instance.
+         * @see BannerPatternRegistryEntry#translationKey()
+         */
+        @Contract(value = "_ -> this", mutates = "this")
+        Builder translationKey(String translationKey);
+
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/registry/data/DamageTypeRegistryEntry.java b/src/main/java/io/papermc/paper/registry/data/DamageTypeRegistryEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..fd2d7fffa43f632f4c3188baec2641f5047abd53
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/data/DamageTypeRegistryEntry.java
@@ -0,0 +1,120 @@
+package io.papermc.paper.registry.data;
+
+import io.papermc.paper.registry.RegistryBuilder;
+import org.bukkit.damage.DamageEffect;
+import org.bukkit.damage.DamageScaling;
+import org.bukkit.damage.DamageType;
+import org.bukkit.damage.DeathMessageType;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Contract;
+
+/**
+ * A data-centric version-specific registry entry for the {@link DamageType} type.
+ */
+@ApiStatus.Experimental
+@ApiStatus.NonExtendable
+public interface DamageTypeRegistryEntry {
+
+    /**
+     * Provides part of the death message translation key. (death.attack.&lt;message_id&gt;)
+     * <p>
+     * <strong>Note</strong> The translation key is only used if
+     * {@link #deathMessageType()} is {@link DeathMessageType#DEFAULT}
+     *
+     * @return part of the translation key
+     */
+    String messageId();
+
+    /**
+     * Provides the amount of hunger exhaustion caused by this damage type.
+     *
+     * @return the exhaustion
+     */
+    float exhaustion();
+
+    /**
+     * Provides the {@link DamageScaling} for this damage type.
+     *
+     * @return the damage scaling
+     */
+    DamageScaling damageScaling();
+
+    /**
+     * Provides the {@link DamageEffect} for this damage type.
+     *
+     * @return the damage effect
+     */
+    DamageEffect damageEffect();
+
+    /**
+     * Provides the {@link DeathMessageType} for this damage type.
+     *
+     * @return the death message type
+     */
+    DeathMessageType deathMessageType();
+
+    /**
+     * A mutable builder for the {@link DamageTypeRegistryEntry} plugins may change in applicable registry events.
+     * <p>
+     * The following values are required for each builder:
+     * <ul>
+     *     <li>{@link #messageId(String)}</li>
+     *     <li>{@link #exhaustion(float)}</li>
+     *     <li>{@link #damageScaling(DamageScaling)}</li>
+     * </ul>
+     */
+    @ApiStatus.Experimental
+    @ApiStatus.NonExtendable
+    interface Builder extends DamageTypeRegistryEntry, RegistryBuilder<DamageType> {
+
+        /**
+         * Sets part of the death message translation key.
+         *
+         * @return this builder instance.
+         * @see DamageTypeRegistryEntry#messageId()
+         * @see DamageType#getTranslationKey()
+         */
+        @Contract(value = "_ -> this", mutates = "this")
+        Builder messageId(String messageId);
+
+        /**
+         * Sets the amount of hunger exhaustion caused by this damage type.
+         *
+         * @return this builder instance.
+         * @see DamageTypeRegistryEntry#exhaustion()
+         * @see DamageType#getExhaustion()
+         */
+        @Contract(value = "_ -> this", mutates = "this")
+        Builder exhaustion(float exhaustion);
+
+        /**
+         * Sets the {@link DamageScaling} for this damage type.
+         *
+         * @return this builder instance.
+         * @see DamageTypeRegistryEntry#damageScaling()
+         * @see DamageType#getDamageScaling()
+         */
+        @Contract(value = "_ -> this", mutates = "this")
+        Builder damageScaling(DamageScaling scaling);
+
+        /**
+         * Sets the {@link DamageEffect} for this damage type.
+         *
+         * @return this builder instance.
+         * @see DamageTypeRegistryEntry#damageEffect()
+         * @see DamageType#getDamageEffect()
+         */
+        @Contract(value = "_ -> this", mutates = "this")
+        Builder damageEffect(DamageEffect effect);
+
+        /**
+         * Sets the {@link DeathMessageType} for this damage type.
+         *
+         * @return this builder instance.
+         * @see DamageTypeRegistryEntry#deathMessageType()
+         * @see DamageType#getDeathMessageType()
+         */
+        @Contract(value = "_ -> this", mutates = "this")
+        Builder deathMessageType(DeathMessageType deathMessageType);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/data/InlinedRegistryBuilderProvider.java b/src/main/java/io/papermc/paper/registry/data/InlinedRegistryBuilderProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..554bda034102106f96b0a61d5d1cb84edbb1a3cc
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/data/InlinedRegistryBuilderProvider.java
@@ -0,0 +1,22 @@
+package io.papermc.paper.registry.data;
+
+import io.papermc.paper.registry.RegistryBuilderFactory;
+import java.util.Optional;
+import java.util.ServiceLoader;
+import java.util.function.Consumer;
+import org.bukkit.Art;
+import org.jetbrains.annotations.ApiStatus;
+
+@ApiStatus.Internal
+@ApiStatus.NonExtendable
+public interface InlinedRegistryBuilderProvider {
+
+    static InlinedRegistryBuilderProvider instance() {
+        class Holder {
+            static final Optional<InlinedRegistryBuilderProvider> INSTANCE = ServiceLoader.load(InlinedRegistryBuilderProvider.class).findFirst();
+        }
+        return Holder.INSTANCE.orElseThrow();
+    }
+
+    Art createPaintingVariant(Consumer<RegistryBuilderFactory<Art, ? extends PaintingVariantRegistryEntry.Builder>> value);
+}
diff --git a/src/main/java/io/papermc/paper/registry/event/RegistryEvents.java b/src/main/java/io/papermc/paper/registry/event/RegistryEvents.java
index 40deffbd0930508bb04e9aedfd62ad2144855198..d155815794451581f0a79ea36a586c8eb8aa55d2 100644
--- a/src/main/java/io/papermc/paper/registry/event/RegistryEvents.java
+++ b/src/main/java/io/papermc/paper/registry/event/RegistryEvents.java
@@ -1,11 +1,15 @@
 package io.papermc.paper.registry.event;
 
 import io.papermc.paper.registry.RegistryKey;
+import io.papermc.paper.registry.data.BannerPatternRegistryEntry;
+import io.papermc.paper.registry.data.DamageTypeRegistryEntry;
 import io.papermc.paper.registry.data.EnchantmentRegistryEntry;
 import io.papermc.paper.registry.data.GameEventRegistryEntry;
 import io.papermc.paper.registry.data.PaintingVariantRegistryEntry;
 import org.bukkit.Art;
 import org.bukkit.GameEvent;
+import org.bukkit.block.banner.PatternType;
+import org.bukkit.damage.DamageType;
 import org.bukkit.enchantments.Enchantment;
 import org.jetbrains.annotations.ApiStatus;
 import org.jspecify.annotations.NullMarked;
@@ -23,6 +27,8 @@ public final class RegistryEvents {
     public static final RegistryEventProvider<GameEvent, GameEventRegistryEntry.Builder> GAME_EVENT = create(RegistryKey.GAME_EVENT);
     public static final RegistryEventProvider<Enchantment, EnchantmentRegistryEntry.Builder> ENCHANTMENT = create(RegistryKey.ENCHANTMENT);
     public static final RegistryEventProvider<Art, PaintingVariantRegistryEntry.Builder> PAINTING_VARIANT = create(RegistryKey.PAINTING_VARIANT);
+    public static final RegistryEventProvider<PatternType, BannerPatternRegistryEntry.Builder> BANNER_PATTERN = create(RegistryKey.BANNER_PATTERN);
+    public static final RegistryEventProvider<DamageType, DamageTypeRegistryEntry.Builder> DAMAGE_TYPE = create(RegistryKey.DAMAGE_TYPE);
 
     private RegistryEvents() {
     }
diff --git a/src/main/java/io/papermc/paper/registry/event/WritableRegistry.java b/src/main/java/io/papermc/paper/registry/event/WritableRegistry.java
index 744f455b14cdc9131497024088da4ca0e8fc39dc..fed7ad660f96294f326d859843ff1bb5fe30b231 100644
--- a/src/main/java/io/papermc/paper/registry/event/WritableRegistry.java
+++ b/src/main/java/io/papermc/paper/registry/event/WritableRegistry.java
@@ -1,6 +1,7 @@
 package io.papermc.paper.registry.event;
 
 import io.papermc.paper.registry.RegistryBuilder;
+import io.papermc.paper.registry.RegistryBuilderFactory;
 import io.papermc.paper.registry.TypedKey;
 import java.util.function.Consumer;
 import org.jetbrains.annotations.ApiStatus;
@@ -24,5 +25,18 @@ public interface WritableRegistry<T, B extends RegistryBuilder<T>> {
      * @param key the entry's key (must be unique from others)
      * @param value a consumer for the entry's builder
      */
-    void register(TypedKey<T> key, Consumer<? super B> value);
+    default void register(final TypedKey<T> key, final Consumer<? super B> value) {
+        this.registerWith(key, factory -> value.accept(factory.empty()));
+    }
+
+    /**
+     * Register a new value with the specified key. This will
+     * fire a {@link RegistryEntryAddEvent} for the new entry. The
+     * {@link RegistryBuilderFactory} lets you pre-fill a builder with
+     * an already-existing entry's properties.
+     *
+     * @param key the entry's key (must be unique from others)
+     * @param value a consumer of a builder factory
+     */
+    void registerWith(TypedKey<T> key, Consumer<RegistryBuilderFactory<T, B>> value);
 }
diff --git a/src/main/java/org/bukkit/Art.java b/src/main/java/org/bukkit/Art.java
index 5d3fb60a212ee5609d5edc1d8030310521d8343e..82daa6941c2268a24f6e5eb34efb87fb00b2745b 100644
--- a/src/main/java/org/bukkit/Art.java
+++ b/src/main/java/org/bukkit/Art.java
@@ -2,9 +2,15 @@ package org.bukkit;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Lists;
+import io.papermc.paper.registry.RegistryAccess;
+import io.papermc.paper.registry.RegistryBuilderFactory;
+import io.papermc.paper.registry.RegistryKey;
+import io.papermc.paper.registry.data.InlinedRegistryBuilderProvider;
+import io.papermc.paper.registry.data.PaintingVariantRegistryEntry;
 import java.util.Locale;
-import org.bukkit.packs.DataPack;
+import java.util.function.Consumer;
 import org.bukkit.util.OldEnum;
+import org.jetbrains.annotations.ApiStatus;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
@@ -13,11 +19,22 @@ import org.jetbrains.annotations.Nullable;
  * <p>
  * The arts listed in this interface are present in the default server
  * or can be enabled via a {@link FeatureFlag}.
- * There may be additional arts present in the server, for example from a {@link DataPack}
- * which can be accessed via {@link Registry#ART}.
+ * There may be additional arts present in the server, for example from a {@link io.papermc.paper.datapack.Datapack}
+ * which can be accessed via {@link RegistryAccess#registryAccess()} and {@link RegistryKey#PAINTING_VARIANT}.
  */
 public interface Art extends OldEnum<Art>, Keyed {
 
+    /**
+     * Create an inlined painting variant.
+     *
+     * @param value a consumer for the builder factory
+     * @return the created painting variant
+     */
+    @ApiStatus.Experimental
+    static @NotNull Art create(final @NotNull Consumer<RegistryBuilderFactory<Art, ? extends PaintingVariantRegistryEntry.Builder>> value) {
+        return InlinedRegistryBuilderProvider.instance().createPaintingVariant(value);
+    }
+
     Art KEBAB = getArt("kebab");
     Art AZTEC = getArt("aztec");
     Art ALBAN = getArt("alban");
@@ -71,7 +88,7 @@ public interface Art extends OldEnum<Art>, Keyed {
 
     @NotNull
     private static Art getArt(@NotNull String key) {
-        return Registry.ART.getOrThrow(NamespacedKey.minecraft(key));
+        return RegistryAccess.registryAccess().getRegistry(RegistryKey.PAINTING_VARIANT).getOrThrow(NamespacedKey.minecraft(key));
     }
 
     /**
@@ -173,7 +190,7 @@ public interface Art extends OldEnum<Art>, Keyed {
     static Art getByName(@NotNull String name) {
         Preconditions.checkArgument(name != null, "Name cannot be null");
 
-        return Bukkit.getUnsafe().get(Registry.ART, NamespacedKey.fromString(name.toLowerCase(Locale.ROOT)));
+        return Bukkit.getUnsafe().get(RegistryKey.PAINTING_VARIANT, NamespacedKey.fromString(name.toLowerCase(Locale.ROOT)));
     }
 
     /**
@@ -184,7 +201,7 @@ public interface Art extends OldEnum<Art>, Keyed {
     @NotNull
     @Deprecated(since = "1.21.3", forRemoval = true) @org.jetbrains.annotations.ApiStatus.ScheduledForRemoval(inVersion = "1.22") // Paper - will be removed via asm-utils
     static Art valueOf(@NotNull String name) {
-        Art art = Bukkit.getUnsafe().get(Registry.ART, NamespacedKey.fromString(name.toLowerCase(Locale.ROOT)));
+        Art art = Bukkit.getUnsafe().get(RegistryKey.PAINTING_VARIANT, NamespacedKey.fromString(name.toLowerCase(Locale.ROOT)));
         Preconditions.checkArgument(art != null, "No art found with the name %s", name);
         return art;
     }
diff --git a/src/main/java/org/bukkit/Bukkit.java b/src/main/java/org/bukkit/Bukkit.java
index 8ab94f8189ebd9d4158231871abdebec399deb2c..9196b1e62b328b1e9790b966600aba9681dd0ddc 100644
--- a/src/main/java/org/bukkit/Bukkit.java
+++ b/src/main/java/org/bukkit/Bukkit.java
@@ -40,6 +40,7 @@ import org.bukkit.inventory.InventoryHolder;
 import org.bukkit.inventory.ItemCraftResult;
 import org.bukkit.inventory.ItemFactory;
 import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.MenuType;
 import org.bukkit.inventory.Merchant;
 import org.bukkit.inventory.Recipe;
 import org.bukkit.inventory.meta.ItemMeta;
@@ -1184,7 +1185,7 @@ public final class Bukkit {
      * @return the {@link Recipe} resulting from the given crafting matrix.
      */
     @Nullable
-    public static Recipe getCraftingRecipe(@NotNull ItemStack[] craftingMatrix, @NotNull World world) {
+    public static Recipe getCraftingRecipe(@NotNull ItemStack @NotNull [] craftingMatrix, @NotNull World world) {
         return server.getCraftingRecipe(craftingMatrix, world);
     }
 
@@ -1213,7 +1214,7 @@ public final class Bukkit {
      * @return resulting {@link ItemCraftResult} containing the resulting item, matrix and any overflow items.
      */
     @NotNull
-    public static ItemCraftResult craftItemResult(@NotNull ItemStack[] craftingMatrix, @NotNull World world, @NotNull Player player) {
+    public static ItemCraftResult craftItemResult(@NotNull ItemStack @NotNull [] craftingMatrix, @NotNull World world, @NotNull Player player) {
         return server.craftItemResult(craftingMatrix, world, player);
     }
 
@@ -1235,7 +1236,7 @@ public final class Bukkit {
      * @return resulting {@link ItemCraftResult} containing the resulting item, matrix and any overflow items.
      */
     @NotNull
-    public static ItemCraftResult craftItemResult(@NotNull ItemStack[] craftingMatrix, @NotNull World world) {
+    public static ItemCraftResult craftItemResult(@NotNull ItemStack @NotNull [] craftingMatrix, @NotNull World world) {
         return server.craftItemResult(craftingMatrix, world);
     }
 
@@ -1266,7 +1267,7 @@ public final class Bukkit {
      * an ItemStack of {@link Material#AIR} is returned.
      */
     @NotNull
-    public static ItemStack craftItem(@NotNull ItemStack[] craftingMatrix, @NotNull World world, @NotNull Player player) {
+    public static ItemStack craftItem(@NotNull ItemStack @NotNull [] craftingMatrix, @NotNull World world, @NotNull Player player) {
         return server.craftItem(craftingMatrix, world, player);
     }
 
@@ -1289,7 +1290,7 @@ public final class Bukkit {
      * an ItemStack of {@link Material#AIR} is returned.
      */
     @NotNull
-    public static ItemStack craftItem(@NotNull ItemStack[] craftingMatrix, @NotNull World world) {
+    public static ItemStack craftItem(@NotNull ItemStack @NotNull [] craftingMatrix, @NotNull World world) {
         return server.craftItem(craftingMatrix, world);
     }
 
@@ -1756,8 +1757,7 @@ public final class Bukkit {
      *
      * @return an array containing all previous players
      */
-    @NotNull
-    public static OfflinePlayer[] getOfflinePlayers() {
+    public static @NotNull OfflinePlayer @NotNull [] getOfflinePlayers() {
         return server.getOfflinePlayers();
     }
 
@@ -1926,7 +1926,10 @@ public final class Bukkit {
      * @param title the title of the corresponding merchant inventory, displayed
      * when the merchant inventory is viewed
      * @return a new merchant
+     * @deprecated The title parameter is no-longer needed when used with
+     * {@link MenuType#MERCHANT} and {@link MenuType.Typed#builder()}.
      */
+    @Deprecated(since = "1.21.4")
     public static @NotNull Merchant createMerchant(net.kyori.adventure.text.@Nullable Component title) {
         return server.createMerchant(title);
     }
@@ -1937,7 +1940,8 @@ public final class Bukkit {
      * @param title the title of the corresponding merchant inventory, displayed
      * when the merchant inventory is viewed
      * @return a new merchant
-     * @deprecated in favour of {@link #createMerchant(net.kyori.adventure.text.Component)}
+     * @deprecated in favour of {@link #createMerchant(net.kyori.adventure.text.Component)}. The title parameter is
+     * no-longer needed when used with {@link MenuType#MERCHANT} and {@link MenuType.Typed#builder()}
      */
     @NotNull
     @Deprecated // Paper
@@ -1945,6 +1949,16 @@ public final class Bukkit {
         return server.createMerchant(title);
     }
 
+    /**
+     * Creates an empty merchant.
+     *
+     * @return a new merchant
+     */
+    @NotNull
+    public static Merchant createMerchant() {
+        return server.createMerchant();
+    }
+
     /**
      * Gets the amount of consecutive neighbor updates before skipping
      * additional ones.
@@ -2404,8 +2418,7 @@ public final class Bukkit {
      * Gets the current server TPS
      * @return current server TPS (1m, 5m, 15m in Paper-Server)
      */
-    @NotNull
-    public static double[] getTPS() {
+    public static double @NotNull [] getTPS() {
         return server.getTPS();
     }
 
@@ -2414,8 +2427,7 @@ public final class Bukkit {
      *
      * @return A sample of the servers last tick times (in nanos)
      */
-    @NotNull
-    public static long[] getTickTimes() {
+    public static long @NotNull [] getTickTimes() {
         return server.getTickTimes();
     }
 
diff --git a/src/main/java/org/bukkit/Chunk.java b/src/main/java/org/bukkit/Chunk.java
index bc8b5bc17706250b8535b1b309134843d2ce2bb1..d434277342b2db19f98e032d3a316b27d728b840 100644
--- a/src/main/java/org/bukkit/Chunk.java
+++ b/src/main/java/org/bukkit/Chunk.java
@@ -133,8 +133,7 @@ public interface Chunk extends PersistentDataHolder {
      *
      * @return The entities.
      */
-    @NotNull
-    Entity[] getEntities();
+    @NotNull Entity @NotNull [] getEntities();
 
     /**
      * Get a list of all tile entities in the chunk.
@@ -143,7 +142,7 @@ public interface Chunk extends PersistentDataHolder {
      */
     @NotNull
     // Paper start
-    default BlockState[] getTileEntities() {
+    default BlockState @NotNull [] getTileEntities() {
         return getTileEntities(true);
     }
 
@@ -154,7 +153,7 @@ public interface Chunk extends PersistentDataHolder {
      * @return The tile entities.
      */
     @NotNull
-    BlockState[] getTileEntities(boolean useSnapshot);
+    BlockState @NotNull [] getTileEntities(boolean useSnapshot);
 
     /**
      * Get a list of all tile entities that match a given predicate in the chunk.
diff --git a/src/main/java/org/bukkit/Fluid.java b/src/main/java/org/bukkit/Fluid.java
index a3ff4fefaf50f3e99a69ba68cbe8e30c95dac5df..45a095f16c9aa9d0daf110dbe35028315ae36fb2 100644
--- a/src/main/java/org/bukkit/Fluid.java
+++ b/src/main/java/org/bukkit/Fluid.java
@@ -2,6 +2,7 @@ package org.bukkit;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Lists;
+import io.papermc.paper.registry.RegistryKey;
 import java.util.Locale;
 import org.bukkit.util.OldEnum;
 import org.jetbrains.annotations.NotNull;
@@ -45,7 +46,7 @@ public interface Fluid extends OldEnum<Fluid>, Keyed {
     @NotNull
     @Deprecated(since = "1.21.3", forRemoval = true) @org.jetbrains.annotations.ApiStatus.ScheduledForRemoval(inVersion = "1.22") // Paper - will be removed via asm-utils
     static Fluid valueOf(@NotNull String name) {
-        Fluid fluid = Bukkit.getUnsafe().get(Registry.FLUID, NamespacedKey.fromString(name.toLowerCase(Locale.ROOT)));
+        Fluid fluid = Bukkit.getUnsafe().get(RegistryKey.FLUID, NamespacedKey.fromString(name.toLowerCase(Locale.ROOT)));
         Preconditions.checkArgument(fluid != null, "No fluid found with the name %s", name);
         return fluid;
     }
diff --git a/src/main/java/org/bukkit/JukeboxSong.java b/src/main/java/org/bukkit/JukeboxSong.java
index c6feb13c735fabbd08676fa8828ce0b9fd54da32..7e3dca5023d1ca7f1187a30aa0a6ef19b77819db 100644
--- a/src/main/java/org/bukkit/JukeboxSong.java
+++ b/src/main/java/org/bukkit/JukeboxSong.java
@@ -1,5 +1,7 @@
 package org.bukkit;
 
+import io.papermc.paper.registry.RegistryAccess;
+import io.papermc.paper.registry.RegistryKey;
 import org.jetbrains.annotations.ApiStatus;
 import org.jetbrains.annotations.NotNull;
 
@@ -31,7 +33,7 @@ public interface JukeboxSong extends Keyed, Translatable {
 
     @NotNull
     private static JukeboxSong get(@NotNull String key) {
-        return Registry.JUKEBOX_SONG.getOrThrow(NamespacedKey.minecraft(key));
+        return RegistryAccess.registryAccess().getRegistry(RegistryKey.JUKEBOX_SONG).getOrThrow(NamespacedKey.minecraft(key));
     }
 
     // Paper start - adventure
diff --git a/src/main/java/org/bukkit/Location.java b/src/main/java/org/bukkit/Location.java
index bdc065a486306236c7f0960718bea53bc0b0a9b6..8bc340c9d4d8d1b113d877e25af769ef9251dc94 100644
--- a/src/main/java/org/bukkit/Location.java
+++ b/src/main/java/org/bukkit/Location.java
@@ -3,25 +3,22 @@ package org.bukkit;
 import com.google.common.base.Preconditions;
 import java.lang.ref.Reference;
 import java.lang.ref.WeakReference;
-import com.google.common.base.Preconditions; // Paper
+import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.function.Predicate;
+import io.papermc.paper.math.FinePosition;
 import org.bukkit.block.Block;
 import org.bukkit.configuration.serialization.ConfigurationSerializable;
-import org.bukkit.entity.Entity; // Paper
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.Player;
 import org.bukkit.util.NumberConversions;
 import org.bukkit.util.Vector;
+import org.jetbrains.annotations.Contract;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
-// Paper start
-import java.util.Collection;
-import java.util.function.Predicate;
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.LivingEntity;
-import org.bukkit.entity.Player;
-// Paper end
-
 /**
  * Represents a 3-dimensional position in a world.
  * <br>
@@ -30,7 +27,7 @@ import org.bukkit.entity.Player;
  * magnitude than 360 are valid, but may be normalized to any other equivalent
  * representation by the implementation.
  */
-public class Location implements Cloneable, ConfigurationSerializable, io.papermc.paper.math.FinePosition { // Paper
+public class Location implements Cloneable, ConfigurationSerializable, io.papermc.paper.math.FinePosition {
     private Reference<World> world;
     private double x;
     private double y;
@@ -46,7 +43,7 @@ public class Location implements Cloneable, ConfigurationSerializable, io.paperm
      * @param y The y-coordinate of this new location
      * @param z The z-coordinate of this new location
      */
-    public Location(@UndefinedNullability final World world, final double x, final double y, final double z) { // Paper
+    public Location(@UndefinedNullability final World world, final double x, final double y, final double z) {
         this(world, x, y, z, 0, 0);
     }
 
@@ -60,7 +57,7 @@ public class Location implements Cloneable, ConfigurationSerializable, io.paperm
      * @param yaw The absolute rotation on the x-plane, in degrees
      * @param pitch The absolute rotation on the y-plane, in degrees
      */
-    public Location(@UndefinedNullability final World world, final double x, final double y, final double z, final float yaw, final float pitch) { // Paper
+    public Location(@UndefinedNullability final World world, final double x, final double y, final double z, final float yaw, final float pitch) {
         if (world != null) {
             this.world = new WeakReference<>(world);
         }
@@ -102,7 +99,7 @@ public class Location implements Cloneable, ConfigurationSerializable, io.paperm
      * @throws IllegalArgumentException when world is unloaded
      * @see #isWorldLoaded()
      */
-    @UndefinedNullability // Paper
+    @UndefinedNullability
     public World getWorld() {
         if (this.world == null) {
             return null;
@@ -398,6 +395,22 @@ public class Location implements Cloneable, ConfigurationSerializable, io.paperm
         return this;
     }
 
+    /**
+     * Adds rotation in the form of yaw and patch to this location. Not world-aware.
+     *
+     * @param yaw   yaw, measured in degrees.
+     * @param pitch pitch, measured in degrees.
+     * @return the same location
+     * @see Vector
+     */
+    @NotNull
+    @Contract(value = "_,_ -> this", mutates = "this")
+    public Location addRotation(final float yaw, final float pitch) {
+        this.yaw += yaw;
+        this.pitch += pitch;
+        return this;
+    }
+
     /**
      * Subtracts the location by another.
      *
@@ -451,6 +464,22 @@ public class Location implements Cloneable, ConfigurationSerializable, io.paperm
         return this;
     }
 
+    /**
+     * Subtracts rotation in the form of yaw and patch from this location.
+     *
+     * @param yaw   yaw, measured in degrees.
+     * @param pitch pitch, measured in degrees.
+     * @return the same location
+     * @see Vector
+     */
+    @NotNull
+    @Contract(value = "_,_ -> this", mutates = "this")
+    public Location subtractRotation(final float yaw, final float pitch) {
+        this.yaw -= yaw;
+        this.pitch -= pitch;
+        return this;
+    }
+
     /**
      * Gets the magnitude of the location, defined as sqrt(x^2+y^2+z^2). The
      * value of this method is not cached and uses a costly square-root
@@ -543,9 +572,10 @@ public class Location implements Cloneable, ConfigurationSerializable, io.paperm
         return this;
     }
 
-    public boolean isChunkLoaded() { return this.getWorld().isChunkLoaded(locToBlock(x) >> 4, locToBlock(z) >> 4); } // Paper
+    public boolean isChunkLoaded() {
+        return this.getWorld().isChunkLoaded(locToBlock(x) >> 4, locToBlock(z) >> 4);
+    }
 
-    // Paper start - isGenerated API
     /**
      * Checks if a {@link Chunk} has been generated at this location.
      *
@@ -556,9 +586,6 @@ public class Location implements Cloneable, ConfigurationSerializable, io.paperm
         Preconditions.checkNotNull(world, "Location has no world!");
         return world.isChunkGenerated(locToBlock(x) >> 4, locToBlock(z) >> 4);
     }
-    // Paper end - isGenerated API
-
-    // Paper start - expand location manipulation API
 
     /**
      * Sets the position of this Location and returns itself
@@ -578,6 +605,23 @@ public class Location implements Cloneable, ConfigurationSerializable, io.paperm
         return this;
     }
 
+    /**
+     * Sets the rotation of this location and returns itself.
+     * <p>
+     * This mutates this object, clone first.
+     *
+     * @param yaw   yaw, measured in degrees.
+     * @param pitch pitch, measured in degrees.
+     * @return self (not cloned)
+     */
+    @NotNull
+    @Contract(value = "_,_ -> this", mutates = "this")
+    public Location setRotation(final float yaw, final float pitch) {
+        this.yaw = yaw;
+        this.pitch = pitch;
+        return this;
+    }
+
     /**
      * Takes the x/y/z from base and adds the specified x/y/z to it and returns self
      * <p>
@@ -609,9 +653,7 @@ public class Location implements Cloneable, ConfigurationSerializable, io.paperm
     public Location subtract(@NotNull Location base, double x, double y, double z) {
         return this.set(base.x - x, base.y - y, base.z - z);
     }
-    // Paper end - expand location manipulation API
 
-    // Paper start - expand Location API
     /**
      * @return A new location where X/Y/Z are on the Block location (integer value of X/Y/Z)
      */
@@ -624,7 +666,6 @@ public class Location implements Cloneable, ConfigurationSerializable, io.paperm
         return blockLoc;
     }
 
-    // Paper start
     /**
      * @return The block key for this location's block location.
      * @see Block#getBlockKey(int, int, int)
@@ -634,7 +675,6 @@ public class Location implements Cloneable, ConfigurationSerializable, io.paperm
     public long toBlockKey() {
         return Block.getBlockKey(getBlockX(), getBlockY(), getBlockZ());
     }
-    // Paper end
 
     /**
      * @return A new location where X/Y/Z are the center of the block
@@ -647,9 +687,7 @@ public class Location implements Cloneable, ConfigurationSerializable, io.paperm
         centerLoc.setZ(getBlockZ() + 0.5);
         return centerLoc;
     }
-    // Paper end - expand Location API
 
-    // Paper start - Add heightmap api
     /**
      * Returns a copy of this location except with y = getWorld().getHighestBlockYAt(this.getBlockX(), this.getBlockZ())
      * @return A copy of this location except with y = getWorld().getHighestBlockYAt(this.getBlockX(), this.getBlockZ())
@@ -671,9 +709,7 @@ public class Location implements Cloneable, ConfigurationSerializable, io.paperm
         ret.setY(this.getWorld().getHighestBlockYAt(this, heightMap));
         return ret;
     }
-    // Paper end - Add heightmap api
 
-    // Paper start - Expand Explosions API
     /**
      * Creates explosion at this location with given power
      * <p>
@@ -754,9 +790,7 @@ public class Location implements Cloneable, ConfigurationSerializable, io.paperm
     public boolean createExplosion(@Nullable Entity source, float power, boolean setFire, boolean breakBlocks) {
         return this.getWorld().createExplosion(source, this, power, setFire, breakBlocks);
     }
-    // Paper end - Expand Explosions API
 
-    // Paper start - additional getNearbyEntities API
     /**
      * Returns a list of entities within a bounding box centered around a Location.
      * <p>
@@ -979,7 +1013,6 @@ public class Location implements Cloneable, ConfigurationSerializable, io.paperm
         }
         return world.getNearbyEntitiesByType(clazz, this, xRadius, yRadius, zRadius, predicate);
     }
-    // Paper end - additional getNearbyEntities API
 
     @Override
     public boolean equals(Object obj) {
@@ -1155,7 +1188,6 @@ public class Location implements Cloneable, ConfigurationSerializable, io.paperm
         return pitch;
     }
 
-    // Paper - add Position
     @Override
     public double x() {
         return this.getX();
@@ -1173,12 +1205,11 @@ public class Location implements Cloneable, ConfigurationSerializable, io.paperm
 
     @Override
     public boolean isFinite() {
-        return io.papermc.paper.math.FinePosition.super.isFinite() && Float.isFinite(this.getYaw()) && Float.isFinite(this.getPitch());
+        return FinePosition.super.isFinite() && Float.isFinite(this.getYaw()) && Float.isFinite(this.getPitch());
     }
 
     @Override
     public @NotNull Location toLocation(@NotNull World world) {
         return new Location(world, this.x(), this.y(), this.z(), this.getYaw(), this.getPitch());
     }
-    // Paper end
 }
diff --git a/src/main/java/org/bukkit/Material.java b/src/main/java/org/bukkit/Material.java
index e89edabd36a6755912694d8a8700da4ebe5c5829..9afafc00e457c721a1b20b05c6a5d330caa40dfb 100644
--- a/src/main/java/org/bukkit/Material.java
+++ b/src/main/java/org/bukkit/Material.java
@@ -5706,8 +5706,9 @@ public enum Material implements Keyed, Translatable, net.kyori.adventure.transla
      *
      * @param world the world to check
      * @return true if this material can be used in this World.
+     * @deprecated use {@link io.papermc.paper.world.flag.FeatureFlagSetHolder#isEnabled(io.papermc.paper.world.flag.FeatureDependant)}
      */
-    @Deprecated(forRemoval = true, since = "1.20") // Paper
+    @Deprecated(forRemoval = true, since = "1.20")
     public boolean isEnabledByFeature(@NotNull World world) {
         if (isItem()) {
             return Bukkit.getDataPackManager().isEnabledByFeature(asItemType(), world);
diff --git a/src/main/java/org/bukkit/MusicInstrument.java b/src/main/java/org/bukkit/MusicInstrument.java
index d41892af5253623112fb3f8c53958c7914609e30..bfe64b367dd41ffcc9c5154534d7856a9d5369e6 100644
--- a/src/main/java/org/bukkit/MusicInstrument.java
+++ b/src/main/java/org/bukkit/MusicInstrument.java
@@ -1,6 +1,8 @@
 package org.bukkit;
 
 import com.google.common.collect.Lists;
+import io.papermc.paper.registry.RegistryAccess;
+import io.papermc.paper.registry.RegistryKey;
 import java.util.Collection;
 import java.util.Collections;
 import org.jetbrains.annotations.NotNull;
@@ -44,7 +46,7 @@ public abstract class MusicInstrument implements Keyed, net.kyori.adventure.tran
 
     @NotNull
     private static MusicInstrument getInstrument(@NotNull String key) {
-        return Registry.INSTRUMENT.getOrThrow(NamespacedKey.minecraft(key));
+        return RegistryAccess.registryAccess().getRegistry(RegistryKey.INSTRUMENT).getOrThrow(NamespacedKey.minecraft(key));
     }
 
     // Paper start - deprecate getKey
diff --git a/src/main/java/org/bukkit/Registry.java b/src/main/java/org/bukkit/Registry.java
index d55c33ca14257be5005520e18e465da87a58dbaf..50eea296715bea58e21c11e66084f77689b3d403 100644
--- a/src/main/java/org/bukkit/Registry.java
+++ b/src/main/java/org/bukkit/Registry.java
@@ -3,13 +3,22 @@ package org.bukkit;
 import com.google.common.base.Preconditions;
 import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableMap;
+import io.papermc.paper.datacomponent.DataComponentType;
+import io.papermc.paper.registry.RegistryAccess;
+import io.papermc.paper.registry.RegistryKey;
+import io.papermc.paper.registry.TypedKey;
+import io.papermc.paper.registry.tag.Tag;
+import io.papermc.paper.registry.tag.TagKey;
+import java.util.Collection;
 import java.util.Iterator;
 import java.util.Locale;
 import java.util.Map;
+import java.util.NoSuchElementException;
 import java.util.Objects;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
+import net.kyori.adventure.key.Key;
 import org.bukkit.advancement.Advancement;
 import org.bukkit.attribute.Attribute;
 import org.bukkit.block.Biome;
@@ -35,8 +44,8 @@ import org.bukkit.map.MapCursor;
 import org.bukkit.potion.PotionEffectType;
 import org.bukkit.potion.PotionType;
 import org.jetbrains.annotations.ApiStatus;
-import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
+import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.Nullable;
 
 /**
  * Represents a registry of Bukkit objects that may be retrieved by
@@ -44,39 +53,34 @@ import org.jetbrains.annotations.Nullable;
  *
  * @param <T> type of item in the registry
  */
+@NullMarked
 public interface Registry<T extends Keyed> extends Iterable<T> {
 
+    private static <A extends Keyed> Registry<A> registryFor(final RegistryKey<A> registryKey) {
+        return RegistryAccess.registryAccess().getRegistry(registryKey);
+    }
+
+    @SuppressWarnings("removal")
+    @Deprecated(forRemoval = true, since = "1.21.4")
+    private static <A extends Keyed> Registry<A> legacyRegistryFor(final Class<A> clazz) {
+        return Objects.requireNonNull(RegistryAccess.registryAccess().getRegistry(clazz), "No registry present for " + clazz.getSimpleName() + ". This is a bug.");
+    }
+
     /**
      * Server advancements.
      *
-     * @see Bukkit#getAdvancement(org.bukkit.NamespacedKey)
+     * @see Bukkit#getAdvancement(NamespacedKey)
      * @see Bukkit#advancementIterator()
+     * @deprecated use {@link Bukkit#getAdvancement(NamespacedKey)} and {@link Bukkit#advancementIterator()}
      */
-    Registry<Advancement> ADVANCEMENT = new Registry<Advancement>() {
+    @Deprecated(since = "1.21.4", forRemoval = true)
+    Registry<Advancement> ADVANCEMENT = new NotARegistry<>() {
 
-        @Nullable
         @Override
-        public Advancement get(@NotNull NamespacedKey key) {
+        public @Nullable Advancement get(final NamespacedKey key) {
             return Bukkit.getAdvancement(key);
         }
 
-        @NotNull
-        @Override
-        public Advancement getOrThrow(@NotNull NamespacedKey key) {
-            Advancement advancement = get(key);
-
-            Preconditions.checkArgument(advancement != null, "No Advancement registry entry found for key %s.", key);
-
-            return advancement;
-        }
-
-        @NotNull
-        @Override
-        public Stream<Advancement> stream() {
-            return StreamSupport.stream(spliterator(), false);
-        }
-
-        @NotNull
         @Override
         public Iterator<Advancement> iterator() {
             return Bukkit.advancementIterator();
@@ -86,71 +90,54 @@ public interface Registry<T extends Keyed> extends Iterable<T> {
      * Server art.
      *
      * @see Art
-     * @deprecated use {@link io.papermc.paper.registry.RegistryAccess#getRegistry(io.papermc.paper.registry.RegistryKey)} with {@link io.papermc.paper.registry.RegistryKey#PAINTING_VARIANT}
+     * @deprecated use {@link RegistryAccess#getRegistry(RegistryKey)} with {@link RegistryKey#PAINTING_VARIANT}
      */
     @Deprecated(since = "1.21.3") // Paper
-    Registry<Art> ART = Objects.requireNonNull(io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(Art.class), "No registry present for Art. This is a bug.");
+    Registry<Art> ART = legacyRegistryFor(Art.class);
     /**
      * Attribute.
      *
      * @see Attribute
      */
-    Registry<Attribute> ATTRIBUTE = io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(io.papermc.paper.registry.RegistryKey.ATTRIBUTE); // Paper
+    Registry<Attribute> ATTRIBUTE = registryFor(RegistryKey.ATTRIBUTE);
     /**
      * Server banner patterns.
      *
      * @see PatternType
-     * @deprecated use {@link io.papermc.paper.registry.RegistryAccess#getRegistry(io.papermc.paper.registry.RegistryKey)} with {@link io.papermc.paper.registry.RegistryKey#BANNER_PATTERN}
+     * @deprecated use {@link RegistryAccess#getRegistry(RegistryKey)} with {@link RegistryKey#BANNER_PATTERN}
      */
     @Deprecated(since = "1.21") // Paper
-    Registry<PatternType> BANNER_PATTERN = Objects.requireNonNull(io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(PatternType.class), "No registry present for PatternType. This is a bug."); // Paper
+    Registry<PatternType> BANNER_PATTERN = legacyRegistryFor(PatternType.class);
     /**
      * Server biomes.
      *
      * @see Biome
-     * @deprecated use {@link io.papermc.paper.registry.RegistryAccess#getRegistry(io.papermc.paper.registry.RegistryKey)} with {@link io.papermc.paper.registry.RegistryKey#BIOME}
+     * @deprecated use {@link RegistryAccess#getRegistry(RegistryKey)} with {@link RegistryKey#BIOME}
      */
     @Deprecated(since = "1.21.3") // Paper
-    Registry<Biome> BIOME = Objects.requireNonNull(io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(Biome.class), "No registry present for Biome. This is a bug.");
+    Registry<Biome> BIOME = legacyRegistryFor(Biome.class);
     /**
      * Server block types.
      *
      * @see BlockType
-     * @apiNote BlockType is not ready for public usage yet
      */
-    @ApiStatus.Internal
-    Registry<BlockType> BLOCK = io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(io.papermc.paper.registry.RegistryKey.BLOCK); // Paper
+    @ApiStatus.Experimental
+    Registry<BlockType> BLOCK = registryFor(RegistryKey.BLOCK);
     /**
      * Custom boss bars.
      *
      * @see Bukkit#getBossBar(org.bukkit.NamespacedKey)
      * @see Bukkit#getBossBars()
+     * @deprecated use {@link Bukkit#getBossBar(NamespacedKey)} and {@link Bukkit#getBossBars()}
      */
-    Registry<KeyedBossBar> BOSS_BARS = new Registry<KeyedBossBar>() {
+    @Deprecated(since = "1.21.4", forRemoval = true)
+    Registry<KeyedBossBar> BOSS_BARS = new NotARegistry<>() {
 
-        @Nullable
         @Override
-        public KeyedBossBar get(@NotNull NamespacedKey key) {
+        public @Nullable KeyedBossBar get(final NamespacedKey key) {
             return Bukkit.getBossBar(key);
         }
 
-        @NotNull
-        @Override
-        public KeyedBossBar getOrThrow(@NotNull NamespacedKey key) {
-            KeyedBossBar keyedBossBar = get(key);
-
-            Preconditions.checkArgument(keyedBossBar != null, "No KeyedBossBar registry entry found for key %s.", key);
-
-            return keyedBossBar;
-        }
-
-        @NotNull
-        @Override
-        public Stream<KeyedBossBar> stream() {
-            return StreamSupport.stream(spliterator(), false);
-        }
-
-        @NotNull
         @Override
         public Iterator<KeyedBossBar> iterator() {
             return Bukkit.getBossBars();
@@ -161,37 +148,36 @@ public interface Registry<T extends Keyed> extends Iterable<T> {
      *
      * @see Cat.Type
      */
-    Registry<Cat.Type> CAT_VARIANT = io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(io.papermc.paper.registry.RegistryKey.CAT_VARIANT); // Paper
+    Registry<Cat.Type> CAT_VARIANT = registryFor(RegistryKey.CAT_VARIANT);
     /**
      * Server enchantments.
      *
      * @see Enchantment
-     * @deprecated use {@link io.papermc.paper.registry.RegistryAccess#getRegistry(io.papermc.paper.registry.RegistryKey)} with {@link io.papermc.paper.registry.RegistryKey#ENCHANTMENT}
+     * @deprecated use {@link RegistryAccess#getRegistry(RegistryKey)} with {@link RegistryKey#ENCHANTMENT}
      */
     @Deprecated(since = "1.21")
-    Registry<Enchantment> ENCHANTMENT = Objects.requireNonNull(io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(Enchantment.class), "No registry present for Enchantment. This is a bug."); // Paper
+    Registry<Enchantment> ENCHANTMENT = legacyRegistryFor(Enchantment.class);
     /**
      * Server entity types.
      *
      * @see EntityType
      */
-    Registry<EntityType> ENTITY_TYPE = io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(io.papermc.paper.registry.RegistryKey.ENTITY_TYPE); // Paper
+    Registry<EntityType> ENTITY_TYPE = registryFor(RegistryKey.ENTITY_TYPE);
     /**
      * Server instruments.
      *
      * @see MusicInstrument
-     * @deprecated use {@link io.papermc.paper.registry.RegistryAccess#getRegistry(io.papermc.paper.registry.RegistryKey)} with {@link io.papermc.paper.registry.RegistryKey#INSTRUMENT}
+     * @deprecated use {@link RegistryAccess#getRegistry(RegistryKey)} with {@link RegistryKey#INSTRUMENT}
      */
     @Deprecated(since = "1.21.2")
-    Registry<MusicInstrument> INSTRUMENT = Objects.requireNonNull(io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(MusicInstrument.class), "No registry present for Instruments. This is a bug."); // Paper
+    Registry<MusicInstrument> INSTRUMENT = legacyRegistryFor(MusicInstrument.class);
     /**
      * Server item types.
      *
      * @see ItemType
-     * @apiNote ItemType is not ready for public usage yet
      */
-    @ApiStatus.Internal
-    Registry<ItemType> ITEM = io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(io.papermc.paper.registry.RegistryKey.ITEM); // Paper
+    @ApiStatus.Experimental
+    Registry<ItemType> ITEM = registryFor(RegistryKey.ITEM);
     /**
      * Default server loot tables.
      *
@@ -210,25 +196,25 @@ public interface Registry<T extends Keyed> extends Iterable<T> {
      * @see MenuType
      */
     @ApiStatus.Experimental
-    Registry<MenuType> MENU = io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(io.papermc.paper.registry.RegistryKey.MENU); // Paper
+    Registry<MenuType> MENU = registryFor(RegistryKey.MENU);
     /**
      * Server mob effects.
      *
      * @see PotionEffectType
      */
-    Registry<PotionEffectType> EFFECT = io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(io.papermc.paper.registry.RegistryKey.MOB_EFFECT); // Paper
+    Registry<PotionEffectType> MOB_EFFECT = registryFor(RegistryKey.MOB_EFFECT);
     /**
      * Server particles.
      *
      * @see Particle
      */
-    Registry<Particle> PARTICLE_TYPE = io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(io.papermc.paper.registry.RegistryKey.PARTICLE_TYPE); // Paper
+    Registry<Particle> PARTICLE_TYPE = registryFor(RegistryKey.PARTICLE_TYPE); // Paper
     /**
      * Server potions.
      *
      * @see PotionType
      */
-    Registry<PotionType> POTION = io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(io.papermc.paper.registry.RegistryKey.POTION); // Paper
+    Registry<PotionType> POTION = registryFor(RegistryKey.POTION); // Paper
     /**
      * Server statistics.
      *
@@ -239,160 +225,161 @@ public interface Registry<T extends Keyed> extends Iterable<T> {
      * Server structures.
      *
      * @see Structure
-     * @deprecated use {@link io.papermc.paper.registry.RegistryAccess#getRegistry(io.papermc.paper.registry.RegistryKey)} with {@link io.papermc.paper.registry.RegistryKey#STRUCTURE}
+     * @deprecated use {@link RegistryAccess#getRegistry(RegistryKey)} with {@link RegistryKey#STRUCTURE}
      */
     @Deprecated(since = "1.20.6") // Paper
-    Registry<Structure> STRUCTURE = Objects.requireNonNull(io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(Structure.class), "No registry present for Structure. This is a bug."); // Paper
+    Registry<Structure> STRUCTURE = legacyRegistryFor(Structure.class);
     /**
      * Server structure types.
      *
      * @see StructureType
      */
-    Registry<StructureType> STRUCTURE_TYPE = Objects.requireNonNull(io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(io.papermc.paper.registry.RegistryKey.STRUCTURE_TYPE), "No registry present for StructureType. This is a bug."); // Paper
+    Registry<StructureType> STRUCTURE_TYPE = registryFor(RegistryKey.STRUCTURE_TYPE);
     /**
-     * Sound keys.
+     * Sound events.
      *
      * @see Sound
      */
-    Registry<Sound> SOUNDS = io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(io.papermc.paper.registry.RegistryKey.SOUND_EVENT); // Paper
+    Registry<Sound> SOUND_EVENT = registryFor(RegistryKey.SOUND_EVENT);
     /**
      * Trim materials.
      *
      * @see TrimMaterial
-     * @deprecated use {@link io.papermc.paper.registry.RegistryAccess#getRegistry(io.papermc.paper.registry.RegistryKey)} with {@link io.papermc.paper.registry.RegistryKey#TRIM_MATERIAL}
+     * @deprecated use {@link RegistryAccess#getRegistry(RegistryKey)} with {@link RegistryKey#TRIM_MATERIAL}
      */
     @Deprecated(since = "1.20.6") // Paper
-    Registry<TrimMaterial> TRIM_MATERIAL = Objects.requireNonNull(io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(TrimMaterial.class), "No registry present for TrimMaterial. This is a bug."); // Paper
+    Registry<TrimMaterial> TRIM_MATERIAL = legacyRegistryFor(TrimMaterial.class);
     /**
      * Trim patterns.
      *
      * @see TrimPattern
-     * @deprecated use {@link io.papermc.paper.registry.RegistryAccess#getRegistry(io.papermc.paper.registry.RegistryKey)} with {@link io.papermc.paper.registry.RegistryKey#TRIM_PATTERN}
+     * @deprecated use {@link RegistryAccess#getRegistry(RegistryKey)} with {@link RegistryKey#TRIM_PATTERN}
      */
     @Deprecated(since = "1.20.6")
-    Registry<TrimPattern> TRIM_PATTERN = Objects.requireNonNull(io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(TrimPattern.class), "No registry present for TrimPattern. This is a bug."); // Paper
+    Registry<TrimPattern> TRIM_PATTERN = legacyRegistryFor(TrimPattern.class);
     /**
      * Damage types.
      *
      * @see DamageType
-     * @deprecated use {@link io.papermc.paper.registry.RegistryAccess#getRegistry(io.papermc.paper.registry.RegistryKey)} with {@link io.papermc.paper.registry.RegistryKey#DAMAGE_TYPE}
+     * @deprecated use {@link RegistryAccess#getRegistry(RegistryKey)} with {@link RegistryKey#DAMAGE_TYPE}
      */
     @Deprecated(since = "1.20.6")
-    Registry<DamageType> DAMAGE_TYPE = Objects.requireNonNull(io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(DamageType.class), "No registry present for DamageType. This is a bug."); // Paper
+    Registry<DamageType> DAMAGE_TYPE = legacyRegistryFor(DamageType.class);
     /**
      * Jukebox songs.
      *
      * @see JukeboxSong
-     * @deprecated use {@link io.papermc.paper.registry.RegistryAccess#getRegistry(io.papermc.paper.registry.RegistryKey)} with {@link io.papermc.paper.registry.RegistryKey#JUKEBOX_SONG}
+     * @deprecated use {@link RegistryAccess#getRegistry(RegistryKey)} with {@link RegistryKey#JUKEBOX_SONG}
      */
     @ApiStatus.Experimental
     @Deprecated(since = "1.21")
-    Registry<JukeboxSong> JUKEBOX_SONG = Objects.requireNonNull(io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(JukeboxSong.class), "No registry present for JukeboxSong. This is a bug."); // Paper
+    Registry<JukeboxSong> JUKEBOX_SONG = legacyRegistryFor(JukeboxSong.class);
     /**
      * Villager profession.
      *
      * @see Villager.Profession
      */
-    Registry<Villager.Profession> VILLAGER_PROFESSION = io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(io.papermc.paper.registry.RegistryKey.VILLAGER_PROFESSION); // Paper
+    Registry<Villager.Profession> VILLAGER_PROFESSION = registryFor(RegistryKey.VILLAGER_PROFESSION);
     /**
      * Villager type.
      *
      * @see Villager.Type
      */
-    Registry<Villager.Type> VILLAGER_TYPE = io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(io.papermc.paper.registry.RegistryKey.VILLAGER_TYPE); // Paper
+    Registry<Villager.Type> VILLAGER_TYPE = registryFor(RegistryKey.VILLAGER_TYPE);
     /**
      * Memory Keys.
      *
      * @see MemoryKey
      */
-    Registry<MemoryKey> MEMORY_MODULE_TYPE = new Registry<MemoryKey>() {
+    Registry<MemoryKey> MEMORY_MODULE_TYPE = new NotARegistry<>() {
 
-        @NotNull
         @Override
         public Iterator iterator() {
             return MemoryKey.values().iterator();
         }
 
-        @Nullable
         @Override
-        public MemoryKey get(@NotNull NamespacedKey key) {
+        public @Nullable MemoryKey get(final NamespacedKey key) {
             return MemoryKey.getByKey(key);
         }
-
-        @NotNull
-        @Override
-        public MemoryKey getOrThrow(@NotNull NamespacedKey key) {
-            MemoryKey memoryKey = get(key);
-
-            Preconditions.checkArgument(memoryKey != null, "No MemoryKey registry entry found for key %s.", key);
-
-            return memoryKey;
-        }
-
-        @NotNull
-        @Override
-        public Stream<MemoryKey> stream() {
-            return StreamSupport.stream(spliterator(), false);
-        }
     };
     /**
      * Server fluids.
      *
      * @see Fluid
      */
-    Registry<Fluid> FLUID = io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(io.papermc.paper.registry.RegistryKey.FLUID); // Paper
+    Registry<Fluid> FLUID = registryFor(RegistryKey.FLUID);
     /**
      * Frog variants.
      *
      * @see Frog.Variant
      */
-    Registry<Frog.Variant> FROG_VARIANT = io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(io.papermc.paper.registry.RegistryKey.FROG_VARIANT); // Paper
+    Registry<Frog.Variant> FROG_VARIANT = registryFor(RegistryKey.FROG_VARIANT);
     /**
      * Wolf variants.
      *
      * @see Wolf.Variant
-     * @deprecated use {@link io.papermc.paper.registry.RegistryAccess#getRegistry(io.papermc.paper.registry.RegistryKey)} with {@link io.papermc.paper.registry.RegistryKey#WOLF_VARIANT}
+     * @deprecated use {@link RegistryAccess#getRegistry(RegistryKey)} with {@link RegistryKey#WOLF_VARIANT}
      */
     @Deprecated(since = "1.20.6")
-    Registry<Wolf.Variant> WOLF_VARIANT = Objects.requireNonNull(io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(Wolf.Variant.class), "No registry present for Wolf$Variant. This is a bug."); // Paper
+    Registry<Wolf.Variant> WOLF_VARIANT = legacyRegistryFor(Wolf.Variant.class);
     /**
      * Map cursor types.
      *
      * @see MapCursor.Type
      */
-    Registry<MapCursor.Type> MAP_DECORATION_TYPE = io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(io.papermc.paper.registry.RegistryKey.MAP_DECORATION_TYPE); // Paper
+    Registry<MapCursor.Type> MAP_DECORATION_TYPE = registryFor(RegistryKey.MAP_DECORATION_TYPE);
     /**
      * Game events.
      *
      * @see GameEvent
+     * @see io.papermc.paper.registry.event.RegistryEvents#GAME_EVENT
      */
-    Registry<GameEvent> GAME_EVENT = io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(io.papermc.paper.registry.RegistryKey.GAME_EVENT); // Paper
-
-    // Paper start - potion effect type registry
+    Registry<GameEvent> GAME_EVENT = registryFor(RegistryKey.GAME_EVENT);
     /**
-     * Potion effect types.
+     * Data component types.
      *
-     * @see org.bukkit.potion.PotionEffectType
+     * @see DataComponentType
      */
+    Registry<DataComponentType> DATA_COMPONENT_TYPE = registryFor(RegistryKey.DATA_COMPONENT_TYPE); // Paper
+
+    //<editor-fold desc="renames" defaultstate="collapsed">
+    /**
+     * @apiNote use {@link #MOB_EFFECT} instead
+     * @hidden
+     */
+    @ApiStatus.Obsolete(since = "1.21.4")
+    Registry<PotionEffectType> EFFECT = MOB_EFFECT;
+    /**
+     * @apiNote use {@link #MOB_EFFECT} instead
+     * @hidden
+     */
+    @ApiStatus.Obsolete(since = "1.21.4")
     Registry<org.bukkit.potion.PotionEffectType> POTION_EFFECT_TYPE = EFFECT;
-    // Paper end - potion effect type registry
-    Registry<io.papermc.paper.datacomponent.DataComponentType> DATA_COMPONENT_TYPE = io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(io.papermc.paper.registry.RegistryKey.DATA_COMPONENT_TYPE); // Paper
+    /**
+     * @apiNote use {@link #SOUND_EVENT}
+     * @hidden
+     */
+    @ApiStatus.Obsolete(since = "1.21.4")
+    Registry<Sound> SOUNDS = registryFor(RegistryKey.SOUND_EVENT);
+    //</editor-fold>
+
     /**
      * Get the object by its key.
      *
      * @param key non-null key
-     * @return item or null if does not exist
+     * @return item or null if it does not exist
      */
-    @Nullable
-    T get(@NotNull NamespacedKey key);
+    @Nullable T get(NamespacedKey key);
     // Paper start
+
     /**
      * Get the object by its key.
      *
      * @param key non-null key
      * @return item or null if it does not exist
      */
-    default @Nullable T get(final net.kyori.adventure.key.@NotNull Key key) {
+    default @Nullable T get(final Key key) {
         return key instanceof final NamespacedKey nsKey ? this.get(nsKey) : this.get(new NamespacedKey(key.namespace(), key.value()));
     }
 
@@ -402,23 +389,26 @@ public interface Registry<T extends Keyed> extends Iterable<T> {
      * @param typedKey non-null typed key
      * @return item or null if it does not exist
      */
-    default @Nullable T get(final io.papermc.paper.registry.@NotNull TypedKey<T> typedKey) {
+    default @Nullable T get(final TypedKey<T> typedKey) {
+        Preconditions.checkArgument(typedKey != null, "typedKey cannot be null");
         return this.get(typedKey.key());
     }
     // Paper end
 
     // Paper start - improve Registry
+
     /**
      * Gets the object by its key or throws if it doesn't exist.
      *
      * @param key the key to get the object of in this registry
      * @return the object for the key
-     * @throws java.util.NoSuchElementException if the key doesn't point to an object in the registry
+     * @throws NoSuchElementException if the key doesn't point to an object in the registry
      */
-    default @NotNull T getOrThrow(final net.kyori.adventure.key.@NotNull Key key) {
+    default T getOrThrow(final net.kyori.adventure.key.Key key) {
+        Preconditions.checkArgument(key != null, "key cannot be null");
         final T value = this.get(key);
         if (value == null) {
-            throw new java.util.NoSuchElementException("No value for " + key + " in " + this);
+            throw new NoSuchElementException("No value for " + key + " in " + this);
         }
         return value;
     }
@@ -428,12 +418,12 @@ public interface Registry<T extends Keyed> extends Iterable<T> {
      *
      * @param key the key to get the object of in this registry
      * @return the object for the key
-     * @throws java.util.NoSuchElementException if the key doesn't point to an object in the registry
+     * @throws NoSuchElementException if the key doesn't point to an object in the registry
      */
-    default @NotNull T getOrThrow(final io.papermc.paper.registry.@NotNull TypedKey<T> key) {
+    default T getOrThrow(final TypedKey<T> key) {
         final T value = this.get(key);
         if (value == null) {
-            throw new java.util.NoSuchElementException("No value for " + key + " in " + this);
+            throw new NoSuchElementException("No value for " + key + " in " + this);
         }
         return value;
     }
@@ -447,14 +437,13 @@ public interface Registry<T extends Keyed> extends Iterable<T> {
      *
      * @param value the value to get the key of in this registry
      * @return the key for the value
-     * @throws java.util.NoSuchElementException if the value doesn't exist in this registry
+     * @throws NoSuchElementException if the value doesn't exist in this registry
      * @see #getKey(Keyed)
      */
-    default @NotNull NamespacedKey getKeyOrThrow(final @NotNull T value) {
-        Preconditions.checkArgument(value != null, "value cannot be null");
+    default NamespacedKey getKeyOrThrow(final T value) {
         final NamespacedKey key = this.getKey(value);
         if (key == null) {
-            throw new java.util.NoSuchElementException(value + " has no key in " + this);
+            throw new NoSuchElementException(value + " has no key in " + this);
         }
         return key;
     }
@@ -470,14 +459,7 @@ public interface Registry<T extends Keyed> extends Iterable<T> {
      * @return the key for the value or null if not in the registry
      * @see #getKeyOrThrow(Keyed)
      */
-    default @Nullable NamespacedKey getKey(final @NotNull T value) {
-        Preconditions.checkArgument(value != null, "value cannot be null");
-        //noinspection ConstantValue (it might not be in the future...)
-        if (value instanceof Keyed) {
-            return value.getKey();
-        }
-        return null;
-    }
+    @Nullable NamespacedKey getKey(T value);
     // Paper end - improve Registry
 
     // Paper start - RegistrySet API
@@ -486,46 +468,52 @@ public interface Registry<T extends Keyed> extends Iterable<T> {
      *
      * @param key the key to check for
      * @return true if this registry has a tag with the given key, false otherwise
-     * @see #getTag(io.papermc.paper.registry.tag.TagKey)
+     * @throws UnsupportedOperationException if this registry doesn't have or support tags
+     * @see #getTag(TagKey)
      */
     @ApiStatus.Experimental
-    default boolean hasTag(final io.papermc.paper.registry.tag.@NotNull TagKey<T> key) {
-        throw new UnsupportedOperationException(this + " doesn't have tags");
-    }
+    boolean hasTag(TagKey<T> key);
 
     /**
      * Gets the named registry set (tag) for the given key.
      *
      * @param key the key to get the tag for
      * @return the tag for the key
-     * @throws java.util.NoSuchElementException if no tag with the given key is found
+     * @throws NoSuchElementException if no tag with the given key is found
+     * @throws UnsupportedOperationException    if this registry doesn't have or support tags
+     * @see #hasTag(TagKey)
+     */
+    @ApiStatus.Experimental
+    Tag<T> getTag(TagKey<T> key);
+
+    /**
+     * Gets all the tags in this registry.
+     *
+     * @return a stream of all tags in this registry
      * @throws UnsupportedOperationException if this registry doesn't have or support tags
-     * @see #hasTag(io.papermc.paper.registry.tag.TagKey)
      */
     @ApiStatus.Experimental
-    default @NotNull io.papermc.paper.registry.tag.Tag<T> getTag(final io.papermc.paper.registry.tag.@NotNull TagKey<T> key) {
-        throw new UnsupportedOperationException(this + " doesn't have tags");
-    }
+    Collection<Tag<T>> getTags();
     // Paper end - RegistrySet API
 
     /**
      * Get the object by its key.
-     *
+     * <p>
      * If there is no object with the given key, an exception will be thrown.
      *
      * @param key to get the object from
      * @return object with the given key
-     * @throws IllegalArgumentException if there is no object with the given key
+     * @throws NoSuchElementException if there is no object with the given key
      */
-    @NotNull
-    T getOrThrow(@NotNull NamespacedKey key);
+    default T getOrThrow(final NamespacedKey key) {
+        return this.getOrThrow((Key) key);
+    }
 
     /**
      * Returns a new stream, which contains all registry items, which are registered to the registry.
      *
      * @return a stream of all registry items
      */
-    @NotNull
     Stream<T> stream();
 
     /**
@@ -539,77 +527,82 @@ public interface Registry<T extends Keyed> extends Iterable<T> {
      * @deprecated this method's behavior is broken and not useful. If you want to get an object
      * based on its vanilla name, or a key, wrap it in a {@link NamespacedKey} object and use {@link #get(NamespacedKey)}
      */
-    @Nullable
-    @Deprecated(forRemoval = true) // Paper
-    default T match(@NotNull String input) {
+    // Paper
+    @Deprecated(forRemoval = true)
+    default @Nullable T match(final String input) {
         Preconditions.checkArgument(input != null, "input must not be null");
 
-        String filtered = input.toLowerCase(Locale.ROOT).replaceAll("\\s+", "_");
-        NamespacedKey namespacedKey = NamespacedKey.fromString(filtered);
-        return (namespacedKey != null) ? get(namespacedKey) : null;
+        final String filtered = input.toLowerCase(Locale.ROOT).replaceAll("\\s+", "_");
+        final NamespacedKey namespacedKey = NamespacedKey.fromString(filtered);
+        return (namespacedKey != null) ? this.get(namespacedKey) : null;
     }
 
-    class SimpleRegistry<T extends Enum<T> & Keyed> implements Registry<T> { // Paper - remove final
+    @ApiStatus.Internal
+    class SimpleRegistry<T extends Enum<T> & Keyed> extends NotARegistry<T> { // Paper - remove final
 
         private final Class<T> type;
         private final Map<NamespacedKey, T> map;
 
-        protected SimpleRegistry(@NotNull Class<T> type) {
-            this(type, Predicates.<T>alwaysTrue());
+        protected SimpleRegistry(final Class<T> type) {
+            this(type, Predicates.alwaysTrue());
         }
 
-        protected SimpleRegistry(@NotNull Class<T> type, @NotNull Predicate<T> predicate) {
-            ImmutableMap.Builder<NamespacedKey, T> builder = ImmutableMap.builder();
+        protected SimpleRegistry(final Class<T> type, final Predicate<T> predicate) {
+            final ImmutableMap.Builder<NamespacedKey, T> builder = ImmutableMap.builder();
 
-            for (T entry : type.getEnumConstants()) {
+            for (final T entry : type.getEnumConstants()) {
                 if (predicate.test(entry)) {
                     builder.put(entry.getKey(), entry);
                 }
             }
 
-            map = builder.build();
+            this.map = builder.build();
             this.type = type;
         }
 
-        @Nullable
         @Override
-        public T get(@NotNull NamespacedKey key) {
-            return map.get(key);
+        public @Nullable T get(final NamespacedKey key) {
+            return this.map.get(key);
         }
 
-        @NotNull
         @Override
-        public T getOrThrow(@NotNull NamespacedKey key) {
-            T object = get(key);
+        public Iterator<T> iterator() {
+            return this.map.values().iterator();
+        }
+
+        @ApiStatus.Internal
+        @Deprecated(since = "1.20.6", forRemoval = true)
+        public Class<T> getType() {
+            return this.type;
+        }
+    }
 
-            Preconditions.checkArgument(object != null, "No %s registry entry found for key %s.", type, key);
+    @ApiStatus.Internal
+    abstract class NotARegistry<A extends Keyed> implements Registry<A> {
 
-            return object;
+        @Override
+        public Stream<A> stream() {
+            return StreamSupport.stream(this.spliterator(), false);
         }
 
-        @NotNull
         @Override
-        public Stream<T> stream() {
-            return StreamSupport.stream(spliterator(), false);
+        public NamespacedKey getKey(final A value) {
+            return value.getKey();
         }
 
-        @NotNull
         @Override
-        public Iterator<T> iterator() {
-            return map.values().iterator();
+        public boolean hasTag(final TagKey<A> key) {
+            throw new UnsupportedOperationException("This is not a real registry and therefore cannot support tags");
         }
 
-        @ApiStatus.Internal
-        @Deprecated(since = "1.20.6", forRemoval = true)
-        public Class<T> getType() {
-            return this.type;
+        @Override
+        public Tag<A> getTag(final TagKey<A> key) {
+            throw new UnsupportedOperationException("This is not a real registry and therefore cannot support tags");
         }
 
-        // Paper start - improve Registry
         @Override
-        public @NotNull NamespacedKey getKey(final @NotNull T value) {
-            return value.getKey();
+        public Collection<Tag<A>> getTags() {
+            throw new UnsupportedOperationException("This is not a real registry and therefore cannot support tags");
         }
-        // Paper end - improve Registry
     }
 }
diff --git a/src/main/java/org/bukkit/Server.java b/src/main/java/org/bukkit/Server.java
index ad816538b30079c62d5e1eb98c6f4b61e12e8d47..11923ef0ea75f702273ba5481ac6d46cc0f17697 100644
--- a/src/main/java/org/bukkit/Server.java
+++ b/src/main/java/org/bukkit/Server.java
@@ -14,6 +14,9 @@ import java.util.Set;
 import java.util.UUID;
 import java.util.function.Consumer;
 import java.util.logging.Logger;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.kyori.adventure.text.minimessage.tag.resolver.TagResolver;
 import org.bukkit.Warning.WarningState;
 import org.bukkit.advancement.Advancement;
 import org.bukkit.block.data.BlockData;
@@ -40,6 +43,7 @@ import org.bukkit.inventory.InventoryHolder;
 import org.bukkit.inventory.ItemCraftResult;
 import org.bukkit.inventory.ItemFactory;
 import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.MenuType;
 import org.bukkit.inventory.Merchant;
 import org.bukkit.inventory.Recipe;
 import org.bukkit.inventory.meta.ItemMeta;
@@ -409,6 +413,40 @@ public interface Server extends PluginMessageRecipient, net.kyori.adventure.audi
     }
     // Paper end
 
+    /**
+     * Sends a message with the MiniMessage format to the server.
+     * <p>
+     * See <a href="https://docs.advntr.dev/minimessage/">MiniMessage docs</a>
+     * for more information on the format.
+     *
+     * @param message MiniMessage content
+     */
+    default void sendRichMessage(final @NotNull String message) {
+        this.sendMessage(MiniMessage.miniMessage().deserialize(message));
+    }
+
+    /**
+     * Sends a message with the MiniMessage format to the server.
+     * <p>
+     * See <a href="https://docs.advntr.dev/minimessage/">MiniMessage docs</a> and <a href="https://docs.advntr.dev/minimessage/dynamic-replacements">MiniMessage Placeholders docs</a>
+     * for more information on the format.
+     *
+     * @param message MiniMessage content
+     * @param resolvers resolvers to use
+     */
+    default void sendRichMessage(final @NotNull String message, final @NotNull TagResolver... resolvers) {
+        this.sendMessage(MiniMessage.miniMessage().deserialize(message, resolvers));
+    }
+
+    /**
+     * Sends a plain message to the server.
+     *
+     * @param message plain message
+     */
+    default void sendPlainMessage(final @NotNull String message) {
+        this.sendMessage(Component.text(message));
+    }
+
     /**
      * Gets the name of the update folder. The update folder is used to safely
      * update plugins at the right moment on a plugin load.
@@ -1018,7 +1056,7 @@ public interface Server extends PluginMessageRecipient, net.kyori.adventure.audi
      * @return the {@link Recipe} resulting from the given crafting matrix.
      */
     @Nullable
-    public Recipe getCraftingRecipe(@NotNull ItemStack[] craftingMatrix, @NotNull World world);
+    public Recipe getCraftingRecipe(@NotNull ItemStack @NotNull [] craftingMatrix, @NotNull World world);
 
     /**
      * Get the crafted item using the list of {@link ItemStack} provided.
@@ -1046,7 +1084,7 @@ public interface Server extends PluginMessageRecipient, net.kyori.adventure.audi
      * an ItemStack of {@link Material#AIR} is returned.
      */
     @NotNull
-    public ItemStack craftItem(@NotNull ItemStack[] craftingMatrix, @NotNull World world, @NotNull Player player);
+    public ItemStack craftItem(@NotNull ItemStack @NotNull [] craftingMatrix, @NotNull World world, @NotNull Player player);
 
     /**
      * Get the crafted item using the list of {@link ItemStack} provided.
@@ -1067,7 +1105,7 @@ public interface Server extends PluginMessageRecipient, net.kyori.adventure.audi
      * an ItemStack of {@link Material#AIR} is returned.
      */
     @NotNull
-    public ItemStack craftItem(@NotNull ItemStack[] craftingMatrix, @NotNull World world);
+    public ItemStack craftItem(@NotNull ItemStack @NotNull [] craftingMatrix, @NotNull World world);
 
     /**
      * Get the crafted item using the list of {@link ItemStack} provided.
@@ -1094,7 +1132,7 @@ public interface Server extends PluginMessageRecipient, net.kyori.adventure.audi
      * @return resulting {@link ItemCraftResult} containing the resulting item, matrix and any overflow items.
      */
     @NotNull
-    public ItemCraftResult craftItemResult(@NotNull ItemStack[] craftingMatrix, @NotNull World world, @NotNull Player player);
+    public ItemCraftResult craftItemResult(@NotNull ItemStack @NotNull [] craftingMatrix, @NotNull World world, @NotNull Player player);
 
     /**
      * Get the crafted item using the list of {@link ItemStack} provided.
@@ -1114,7 +1152,7 @@ public interface Server extends PluginMessageRecipient, net.kyori.adventure.audi
      * @return resulting {@link ItemCraftResult} containing the resulting item, matrix and any overflow items.
      */
     @NotNull
-    public ItemCraftResult craftItemResult(@NotNull ItemStack[] craftingMatrix, @NotNull World world);
+    public ItemCraftResult craftItemResult(@NotNull ItemStack @NotNull [] craftingMatrix, @NotNull World world);
 
     /**
      * Get an iterator through the list of crafting recipes.
@@ -1503,8 +1541,7 @@ public interface Server extends PluginMessageRecipient, net.kyori.adventure.audi
      *
      * @return an array containing all previous players
      */
-    @NotNull
-    public OfflinePlayer[] getOfflinePlayers();
+    public @NotNull OfflinePlayer @NotNull [] getOfflinePlayers();
 
     /**
      * Gets the {@link Messenger} responsible for this server.
@@ -1529,11 +1566,11 @@ public interface Server extends PluginMessageRecipient, net.kyori.adventure.audi
      * <br>
      * {@link InventoryType#WORKBENCH} will not process crafting recipes if
      * created with this method. Use
-     * {@link Player#openWorkbench(Location, boolean)} instead.
+     * {@link MenuType#CRAFTING} instead.
      * <br>
      * {@link InventoryType#ENCHANTING} will not process {@link ItemStack}s
      * for possible enchanting results. Use
-     * {@link Player#openEnchanting(Location, boolean)} instead.
+     * {@link MenuType#ENCHANTMENT} instead.
      *
      * @param owner the holder of the inventory, or null to indicate no holder
      * @param type the type of inventory to create
@@ -1556,11 +1593,11 @@ public interface Server extends PluginMessageRecipient, net.kyori.adventure.audi
      * <br>
      * {@link InventoryType#WORKBENCH} will not process crafting recipes if
      * created with this method. Use
-     * {@link Player#openWorkbench(Location, boolean)} instead.
+     * {@link MenuType#CRAFTING} instead.
      * <br>
      * {@link InventoryType#ENCHANTING} will not process {@link ItemStack}s
      * for possible enchanting results. Use
-     * {@link Player#openEnchanting(Location, boolean)} instead.
+     * {@link MenuType#ENCHANTMENT} instead.
      *
      * @param owner The holder of the inventory; can be null if there's no holder.
      * @param type The type of inventory to create.
@@ -1584,11 +1621,11 @@ public interface Server extends PluginMessageRecipient, net.kyori.adventure.audi
      * <br>
      * {@link InventoryType#WORKBENCH} will not process crafting recipes if
      * created with this method. Use
-     * {@link Player#openWorkbench(Location, boolean)} instead.
+     * {@link MenuType#CRAFTING} instead.
      * <br>
      * {@link InventoryType#ENCHANTING} will not process {@link ItemStack}s
      * for possible enchanting results. Use
-     * {@link Player#openEnchanting(Location, boolean)} instead.
+     * {@link MenuType#ENCHANTMENT} instead.
      *
      * @param owner The holder of the inventory; can be null if there's no holder.
      * @param type The type of inventory to create.
@@ -1655,7 +1692,10 @@ public interface Server extends PluginMessageRecipient, net.kyori.adventure.audi
      * @param title the title of the corresponding merchant inventory, displayed
      * when the merchant inventory is viewed
      * @return a new merchant
+     * @deprecated The title parameter is no-longer needed when used with
+     * {@link MenuType#MERCHANT} and {@link MenuType.Typed#builder()}.
      */
+    @Deprecated(since = "1.21.4")
     @NotNull Merchant createMerchant(net.kyori.adventure.text.@Nullable Component title);
     // Paper start
     /**
@@ -1664,7 +1704,8 @@ public interface Server extends PluginMessageRecipient, net.kyori.adventure.audi
      * @param title the title of the corresponding merchant inventory, displayed
      * when the merchant inventory is viewed
      * @return a new merchant
-     * @deprecated in favour of {@link #createMerchant(net.kyori.adventure.text.Component)}
+     * @deprecated in favour of {@link #createMerchant(net.kyori.adventure.text.Component)}, The title parameter is
+     * no-longer needed when used with {@link MenuType#MERCHANT} and {@link MenuType.Typed#builder()}.
      */
     @NotNull
     @Deprecated // Paper
@@ -1679,6 +1720,14 @@ public interface Server extends PluginMessageRecipient, net.kyori.adventure.audi
      */
     int getMaxChainedNeighborUpdates();
 
+    /**
+     * Creates an empty merchant.
+     *
+     * @return a new merchant
+     */
+    @NotNull
+    Merchant createMerchant();
+
     /**
      * Gets user-specified limit for number of monsters that can spawn in a
      * chunk.
@@ -2057,16 +2106,14 @@ public interface Server extends PluginMessageRecipient, net.kyori.adventure.audi
      *
      * @return current server TPS (1m, 5m, 15m in Paper-Server)
      */
-    @NotNull
-    public double[] getTPS();
+    public double @NotNull [] getTPS();
 
     /**
      * Get a sample of the servers last tick times (in nanos)
      *
      * @return A sample of the servers last tick times (in nanos)
      */
-    @NotNull
-    long[] getTickTimes();
+    long @NotNull [] getTickTimes();
 
     /**
      * Get the average tick time (in millis)
diff --git a/src/main/java/org/bukkit/Sound.java b/src/main/java/org/bukkit/Sound.java
index 70d6dedcad934be38ec5dc3807ec946b0fe3b649..e2fb7cfba4d67b643ce966034606322a089ec17b 100644
--- a/src/main/java/org/bukkit/Sound.java
+++ b/src/main/java/org/bukkit/Sound.java
@@ -2,6 +2,7 @@ package org.bukkit;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Lists;
+import io.papermc.paper.registry.RegistryKey;
 import java.util.Locale;
 import org.bukkit.packs.DataPack;
 import org.bukkit.util.OldEnum;
@@ -1687,7 +1688,7 @@ public interface Sound extends OldEnum<Sound>, Keyed, net.kyori.adventure.sound.
     @NotNull
     @Deprecated(since = "1.21.3")
     static Sound valueOf(@NotNull String name) {
-        Sound sound = Bukkit.getUnsafe().get(Registry.SOUNDS, NamespacedKey.fromString(name.toLowerCase(Locale.ROOT)));
+        Sound sound = Bukkit.getUnsafe().get(RegistryKey.SOUND_EVENT, NamespacedKey.fromString(name.toLowerCase(Locale.ROOT)));
         if (sound != null) {
             return sound;
         }
diff --git a/src/main/java/org/bukkit/Tag.java b/src/main/java/org/bukkit/Tag.java
index 961a36e03df968898590c95573cee04083988e32..193858a2815588dc6736a4b8d4cadd7262860757 100644
--- a/src/main/java/org/bukkit/Tag.java
+++ b/src/main/java/org/bukkit/Tag.java
@@ -1049,10 +1049,17 @@ public interface Tag<T extends Keyed> extends Keyed {
      * Vanilla item tag representing all items which repair wolf armor.
      */
     Tag<Material> ITEMS_REPAIRS_WOLF_ARMOR = Bukkit.getTag(REGISTRY_ITEMS, NamespacedKey.minecraft("repairs_wolf_armor"), Material.class);
+    /**
+     * Vanilla item tag representing all stone based materials for crafting.
+     */
+    Tag<Material> ITEMS_STONE_CRAFTING_MATERIALS = Bukkit.getTag(REGISTRY_ITEMS, NamespacedKey.minecraft("stone_crafting_materials"), Material.class);
     /**
      * Vanilla item tag representing all furnace materials.
+     *
+     * @deprecated partially replaced by {@link #ITEMS_STONE_CRAFTING_MATERIALS}
      */
-    Tag<Material> ITEMS_FURNACE_MATERIALS = Bukkit.getTag(REGISTRY_ITEMS, NamespacedKey.minecraft("furnace_materials"), Material.class);
+    @Deprecated(since = "1.16.2", forRemoval = true)
+    Tag<Material> ITEMS_FURNACE_MATERIALS = ITEMS_STONE_CRAFTING_MATERIALS;
     /**
      * Vanilla item tag representing all compasses.
      */
diff --git a/src/main/java/org/bukkit/UnsafeValues.java b/src/main/java/org/bukkit/UnsafeValues.java
index d0de7ce3c3a73863fada71d9e8d7b3ccee98ad8e..de34d068420d31d805105789ca127c8955d82c84 100644
--- a/src/main/java/org/bukkit/UnsafeValues.java
+++ b/src/main/java/org/bukkit/UnsafeValues.java
@@ -1,6 +1,8 @@
 package org.bukkit;
 
 import com.google.common.collect.Multimap;
+import io.papermc.paper.entity.EntitySerializationFlag;
+import io.papermc.paper.registry.RegistryKey;
 import org.bukkit.advancement.Advancement;
 import org.bukkit.attribute.Attribute;
 import org.bukkit.attribute.AttributeModifier;
@@ -9,7 +11,9 @@ import org.bukkit.block.data.BlockData;
 import org.bukkit.damage.DamageEffect;
 import org.bukkit.damage.DamageSource;
 import org.bukkit.damage.DamageType;
+import org.bukkit.entity.Entity;
 import org.bukkit.entity.EntityType;
+import org.bukkit.event.entity.CreatureSpawnEvent;
 import org.bukkit.inventory.CreativeCategory;
 import org.bukkit.inventory.EquipmentSlot;
 import org.bukkit.inventory.ItemStack;
@@ -123,10 +127,6 @@ public interface UnsafeValues {
     @Deprecated(since = "1.20.2", forRemoval = true)
     PotionType.InternalPotionData getInternalPotionData(NamespacedKey key);
 
-    @ApiStatus.Internal
-    @Nullable
-    DamageEffect getDamageEffect(@NotNull String key);
-
     /**
      * Create a new {@link DamageSource.Builder}.
      *
@@ -141,7 +141,7 @@ public interface UnsafeValues {
     String get(Class<?> aClass, String value);
 
     @ApiStatus.Internal
-    <B extends Keyed> B get(Registry<B> registry, NamespacedKey key);
+    <B extends Keyed> B get(RegistryKey<B> registry, NamespacedKey key);
 
     @ApiStatus.Internal
     Biome getCustomBiome();
@@ -198,13 +198,81 @@ public interface UnsafeValues {
      */
     @NotNull ItemStack deserializeItemFromJson(@NotNull com.google.gson.JsonObject data) throws IllegalArgumentException;
 
-    byte[] serializeEntity(org.bukkit.entity.Entity entity);
+    /**
+     * Serializes the provided entity.
+     *
+     * @param entity entity
+     * @return serialized entity data
+     * @see #serializeEntity(Entity, EntitySerializationFlag...)
+     * @see #deserializeEntity(byte[], World, boolean, boolean)
+     * @throws IllegalArgumentException if couldn't serialize the entity
+     * @since 1.17.1
+     */
+    default byte @NotNull [] serializeEntity(@NotNull Entity entity) {
+        return serializeEntity(entity, new EntitySerializationFlag[0]);
+    }
 
-    default org.bukkit.entity.Entity deserializeEntity(byte[] data, World world) {
+    /**
+     * Serializes the provided entity.
+     *
+     * @param entity entity
+     * @param serializationFlags serialization flags
+     * @return serialized entity data
+     * @throws IllegalArgumentException if couldn't serialize the entity
+     * @see #deserializeEntity(byte[], World, boolean, boolean)
+     * @since 1.21.4
+     */
+    byte @NotNull [] serializeEntity(@NotNull Entity entity, @NotNull EntitySerializationFlag... serializationFlags);
+
+    /**
+     * Deserializes the entity from data.
+     * <br>The entity's {@link java.util.UUID} as well as passengers will not be preserved.
+     *
+     * @param data serialized entity data
+     * @param world world
+     * @return deserialized entity
+     * @throws IllegalArgumentException if invalid serialized entity data provided
+     * @see #deserializeEntity(byte[], World, boolean, boolean)
+     * @see #serializeEntity(Entity, EntitySerializationFlag...)
+     * @see Entity#spawnAt(Location, CreatureSpawnEvent.SpawnReason)
+     * @since 1.17.1
+     */
+    default @NotNull Entity deserializeEntity(byte @NotNull [] data, @NotNull World world) {
         return deserializeEntity(data, world, false);
     }
 
-    org.bukkit.entity.Entity deserializeEntity(byte[] data, World world, boolean preserveUUID);
+    /**
+     * Deserializes the entity from data.
+     * <br>The entity's passengers will not be preserved.
+     *
+     * @param data serialized entity data
+     * @param world world
+     * @param preserveUUID whether to preserve the entity's uuid
+     * @return deserialized entity
+     * @throws IllegalArgumentException if invalid serialized entity data provided
+     * @see #deserializeEntity(byte[], World, boolean, boolean)
+     * @see #serializeEntity(Entity, EntitySerializationFlag...)
+     * @see Entity#spawnAt(Location, CreatureSpawnEvent.SpawnReason)
+     * @since 1.17.1
+     */
+    default @NotNull Entity deserializeEntity(byte @NotNull [] data, @NotNull World world, boolean preserveUUID) {
+        return deserializeEntity(data, world, preserveUUID, false);
+    }
+
+    /**
+     * Deserializes the entity from data.
+     *
+     * @param data serialized entity data
+     * @param world world
+     * @param preserveUUID whether to preserve uuids of the entity and its passengers
+     * @param preservePassengers whether to preserve passengers
+     * @return deserialized entity
+     * @throws IllegalArgumentException if invalid serialized entity data provided
+     * @see #serializeEntity(Entity, EntitySerializationFlag...)
+     * @see Entity#spawnAt(Location, CreatureSpawnEvent.SpawnReason)
+     * @since 1.21.4
+     */
+    @NotNull Entity deserializeEntity(byte @NotNull [] data, @NotNull World world, boolean preserveUUID, boolean preservePassengers);
 
     /**
      * Creates and returns the next EntityId available.
diff --git a/src/main/java/org/bukkit/Vibration.java b/src/main/java/org/bukkit/Vibration.java
index bbc01e7c192ae6689c301670047ff114306c57cb..2c0e18e8ddff4bc05fa584b1cde9cd95dda74fa3 100644
--- a/src/main/java/org/bukkit/Vibration.java
+++ b/src/main/java/org/bukkit/Vibration.java
@@ -79,7 +79,7 @@ public class Vibration {
             private final Location block;
 
             public BlockDestination(@NotNull Location block) {
-                this.block = block;
+                this.block = block.clone();
             }
 
             public BlockDestination(@NotNull Block block) {
@@ -88,7 +88,7 @@ public class Vibration {
 
             @NotNull
             public Location getLocation() {
-                return block;
+                return block.clone();
             }
 
             @NotNull
diff --git a/src/main/java/org/bukkit/World.java b/src/main/java/org/bukkit/World.java
index bef54a6c8290e09cbaac20b03dde8dfb902c96b0..e99fa923d35b6dda0b02968bdcf6b43552517ea4 100644
--- a/src/main/java/org/bukkit/World.java
+++ b/src/main/java/org/bukkit/World.java
@@ -346,8 +346,7 @@ public interface World extends RegionAccessor, WorldInfo, PluginMessageRecipient
      *
      * @return Chunk[] containing all loaded chunks
      */
-    @NotNull
-    public Chunk[] getLoadedChunks();
+    public @NotNull Chunk @NotNull [] getLoadedChunks();
 
     /**
      * Loads the specified {@link Chunk}.
@@ -2594,9 +2593,6 @@ public interface World extends RegionAccessor, WorldInfo, PluginMessageRecipient
      * <p>
      * It is safe to run this method when the block does not exist, it will
      * not create the block.
-     * <p>
-     * This method will return the raw temperature without adjusting for block
-     * height effects.
      *
      * @param x X coordinate of the block
      * @param z Z coordinate of the block
@@ -2611,9 +2607,6 @@ public interface World extends RegionAccessor, WorldInfo, PluginMessageRecipient
      * <p>
      * It is safe to run this method when the block does not exist, it will
      * not create the block.
-     * <p>
-     * This method will return the raw temperature without adjusting for block
-     * height effects.
      *
      * @param x X coordinate of the block
      * @param y Y coordinate of the block
@@ -3563,8 +3556,7 @@ public interface World extends RegionAccessor, WorldInfo, PluginMessageRecipient
      *
      * @return An array of {@link GameRule} names.
      */
-    @NotNull
-    public String[] getGameRules();
+    public @NotNull String @NotNull [] getGameRules();
 
     /**
      * Gets the current state of the specified rule
diff --git a/src/main/java/org/bukkit/attribute/Attribute.java b/src/main/java/org/bukkit/attribute/Attribute.java
index 521f035409ee61a9ad73d39bec938f2938892570..978b0e779ea933037798e24b9aef69c7aa63cdea 100644
--- a/src/main/java/org/bukkit/attribute/Attribute.java
+++ b/src/main/java/org/bukkit/attribute/Attribute.java
@@ -2,6 +2,7 @@ package org.bukkit.attribute;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Lists;
+import io.papermc.paper.registry.RegistryKey;
 import java.util.Locale;
 import org.bukkit.Bukkit;
 import org.bukkit.Keyed;
@@ -89,7 +90,7 @@ public interface Attribute extends OldEnum<Attribute>, Keyed, Translatable, net.
      */
     Attribute JUMP_STRENGTH = getAttribute("jump_strength");
     /**
-     * How long an entity remains burning after ingition.
+     * How long an entity remains burning after ignition.
      */
     Attribute BURNING_TIME = getAttribute("burning_time");
     /**
@@ -158,7 +159,7 @@ public interface Attribute extends OldEnum<Attribute>, Keyed, Translatable, net.
     @NotNull
     @Deprecated(since = "1.21.3", forRemoval = true) @org.jetbrains.annotations.ApiStatus.ScheduledForRemoval(inVersion = "1.22") // Paper - will be removed via asm-utils
     static Attribute valueOf(@NotNull String name) {
-        Attribute attribute = Bukkit.getUnsafe().get(Registry.ATTRIBUTE, NamespacedKey.fromString(name.toLowerCase(Locale.ROOT)));
+        Attribute attribute = Bukkit.getUnsafe().get(RegistryKey.ATTRIBUTE, NamespacedKey.fromString(name.toLowerCase(Locale.ROOT)));
         Preconditions.checkArgument(attribute != null, "No attribute found with the name %s", name);
         return attribute;
     }
diff --git a/src/main/java/org/bukkit/block/Biome.java b/src/main/java/org/bukkit/block/Biome.java
index 20fc2b30fdcdedb012dfe129e746d0b9e162fc36..1387559c3a1323a038791c4e08378b5bd09d1070 100644
--- a/src/main/java/org/bukkit/block/Biome.java
+++ b/src/main/java/org/bukkit/block/Biome.java
@@ -2,13 +2,14 @@ package org.bukkit.block;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Lists;
+import io.papermc.paper.registry.RegistryAccess;
+import io.papermc.paper.registry.RegistryKey;
 import java.util.Locale;
 import org.bukkit.Bukkit;
 import org.bukkit.FeatureFlag;
 import org.bukkit.Keyed;
 import org.bukkit.NamespacedKey;
 import org.bukkit.Registry;
-import org.bukkit.packs.DataPack;
 import org.bukkit.util.OldEnum;
 import org.jetbrains.annotations.NotNull;
 
@@ -17,8 +18,8 @@ import org.jetbrains.annotations.NotNull;
  * <p>
  * The Biomes listed in this interface are present in the default server
  * or can be enabled via a {@link FeatureFlag}.
- * There may be additional biomes present in the server, for example from a {@link DataPack}
- * which can be accessed via {@link Registry#BIOME}.
+ * There may be additional biomes present in the server, for example from a {@link io.papermc.paper.datapack.Datapack}
+ * which can be accessed via {@link io.papermc.paper.registry.RegistryAccess#getRegistry(RegistryKey)} and {@link RegistryKey#BIOME}.
  */
 public interface Biome extends OldEnum<Biome>, Keyed, net.kyori.adventure.translation.Translatable { // Paper - Adventure translations
 
@@ -98,7 +99,7 @@ public interface Biome extends OldEnum<Biome>, Keyed, net.kyori.adventure.transl
 
     @NotNull
     private static Biome getBiome(@NotNull String key) {
-        return Registry.BIOME.getOrThrow(NamespacedKey.minecraft(key));
+        return RegistryAccess.registryAccess().getRegistry(RegistryKey.BIOME).getOrThrow(NamespacedKey.minecraft(key));
     }
 
     /**
@@ -113,7 +114,7 @@ public interface Biome extends OldEnum<Biome>, Keyed, net.kyori.adventure.transl
             return Biome.CUSTOM;
         }
 
-        Biome biome = Bukkit.getUnsafe().get(Registry.BIOME, NamespacedKey.fromString(name.toLowerCase(Locale.ROOT)));
+        Biome biome = Bukkit.getUnsafe().get(RegistryKey.BIOME, NamespacedKey.fromString(name.toLowerCase(Locale.ROOT)));
         Preconditions.checkArgument(biome != null, "No biome found with the name %s", name);
         return biome;
     }
diff --git a/src/main/java/org/bukkit/block/Block.java b/src/main/java/org/bukkit/block/Block.java
index b7530e7f389fdc6d815bdff0949fca4b14298c07..b703ad820ff873097dadff9e55b53fcc6b1b8698 100644
--- a/src/main/java/org/bukkit/block/Block.java
+++ b/src/main/java/org/bukkit/block/Block.java
@@ -509,9 +509,6 @@ public interface Block extends Metadatable, Translatable, net.kyori.adventure.tr
 
     /**
      * Gets the temperature of this block.
-     * <p>
-     * If the raw biome temperature without adjusting for height effects is
-     * required then please use {@link World#getTemperature(int, int, int)}.
      *
      * @return Temperature of this block
      */
diff --git a/src/main/java/org/bukkit/block/BlockType.java b/src/main/java/org/bukkit/block/BlockType.java
index a340e78a4371b033d6afd2a7ccdf8292b24237b4..d8fde88e3b7535bbc7f96dbe61f55768ca602f0d 100644
--- a/src/main/java/org/bukkit/block/BlockType.java
+++ b/src/main/java/org/bukkit/block/BlockType.java
@@ -1,5 +1,6 @@
 package org.bukkit.block;
 
+import java.util.Collection;
 import java.util.function.Consumer;
 import org.bukkit.Keyed;
 import org.bukkit.Material;
@@ -120,6 +121,7 @@ import org.bukkit.inventory.ItemType;
 import org.jetbrains.annotations.ApiStatus;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
 
 /**
  * While this API is in a public interface, it is not intended for use by
@@ -169,6 +171,15 @@ public interface BlockType extends Keyed, Translatable, net.kyori.adventure.tran
         @Override
         B createBlockData();
 
+        /**
+         * Creates a collection of {@link BlockData} instances for this block type, with all
+         * possible combinations of properties values.
+         *
+         * @return new block data collection
+         */
+        @Override
+        @Unmodifiable @NotNull Collection<B> createBlockDataStates();
+
         /**
          * Creates a new {@link BlockData} instance for this block type, with all
          * properties initialized to unspecified defaults, except for those provided
@@ -3480,6 +3491,14 @@ public interface BlockType extends Keyed, Translatable, net.kyori.adventure.tran
     @NotNull
     BlockData createBlockData();
 
+    /**
+     * Creates a collection of {@link BlockData} instances for this block type, with all
+     * possible combinations of properties values.
+     *
+     * @return new block data collection
+     */
+    @Unmodifiable @NotNull Collection<? extends BlockData> createBlockDataStates();
+
     /**
      * Creates a new {@link BlockData} instance for this block type, with all
      * properties initialized to unspecified defaults, except for those provided
@@ -3551,7 +3570,7 @@ public interface BlockType extends Keyed, Translatable, net.kyori.adventure.tran
      * state as well. This method will return true if there is at least one
      * state in which additional interact handling is performed for the
      * block type.
-     * 
+     *
      * @deprecated This method is not comprehensive and does not accurately reflect what block types are
      * interactable. Many "interactions" are defined on the item not block, and many are conditional on some other world state
      * checks being true.
@@ -3604,7 +3623,7 @@ public interface BlockType extends Keyed, Translatable, net.kyori.adventure.tran
      *
      * @param world the world to check
      * @return true if this BlockType can be used in this World.
-     * @deprecated Use {@link io.papermc.paper.world.flag.FeatureFlagSetHolder#isEnabled(io.papermc.paper.world.flag.FeatureDependant)}
+     * @deprecated use {@link io.papermc.paper.world.flag.FeatureFlagSetHolder#isEnabled(io.papermc.paper.world.flag.FeatureDependant)}
      */
     @Deprecated(forRemoval = true, since = "1.21.1") // Paper
     boolean isEnabledByFeature(@NotNull World world);
diff --git a/src/main/java/org/bukkit/block/banner/Pattern.java b/src/main/java/org/bukkit/block/banner/Pattern.java
index de815683bb5a7a0c41c3316b216d2a5e5e91eee5..d760d500f566f2d397037a2a5c53bca7e096f128 100644
--- a/src/main/java/org/bukkit/block/banner/Pattern.java
+++ b/src/main/java/org/bukkit/block/banner/Pattern.java
@@ -2,6 +2,7 @@ package org.bukkit.block.banner;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableMap;
+import io.papermc.paper.registry.RegistryKey;
 import java.util.Map;
 import java.util.NoSuchElementException;
 import org.bukkit.Bukkit;
@@ -45,7 +46,7 @@ public class Pattern implements ConfigurationSerializable {
         PatternType patternType = PatternType.getByIdentifier(value);
 
         if (patternType == null) {
-            patternType = Bukkit.getUnsafe().get(Registry.BANNER_PATTERN, NamespacedKey.fromString(value));
+            patternType = Bukkit.getUnsafe().get(RegistryKey.BANNER_PATTERN, NamespacedKey.fromString(value));
         }
 
         Preconditions.checkNotNull(patternType, "Pattern type for key %s cannot be null", value);
diff --git a/src/main/java/org/bukkit/block/banner/PatternType.java b/src/main/java/org/bukkit/block/banner/PatternType.java
index 24b58ed80f3dd7c6b35bb18071000af845d18ba4..444f128e8a1202e29c5e95eed55bbb8b138de290 100644
--- a/src/main/java/org/bukkit/block/banner/PatternType.java
+++ b/src/main/java/org/bukkit/block/banner/PatternType.java
@@ -2,6 +2,8 @@ package org.bukkit.block.banner;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Lists;
+import io.papermc.paper.registry.RegistryAccess;
+import io.papermc.paper.registry.RegistryKey;
 import java.util.Locale;
 import org.bukkit.Keyed;
 import org.bukkit.NamespacedKey;
@@ -95,8 +97,7 @@ public interface PatternType extends OldEnum<PatternType>, Keyed {
      *
      * @param identifier the identifier
      * @return the matched pattern type or null
-     * @see Registry#BANNER_PATTERN
-     * @deprecated magic value, use {@link Registry#get(NamespacedKey)} instead
+     * @deprecated magic value, use {@link Registry#get(NamespacedKey)} instead with {@link io.papermc.paper.registry.RegistryAccess#getRegistry(io.papermc.paper.registry.RegistryKey)} and {@link io.papermc.paper.registry.RegistryKey#BANNER_PATTERN}
      */
     @Contract("null -> null")
     @Nullable
@@ -117,7 +118,7 @@ public interface PatternType extends OldEnum<PatternType>, Keyed {
 
     @NotNull
     private static PatternType getType(@NotNull String key) {
-        return Registry.BANNER_PATTERN.getOrThrow(NamespacedKey.minecraft(key));
+        return RegistryAccess.registryAccess().getRegistry(RegistryKey.BANNER_PATTERN).getOrThrow(NamespacedKey.minecraft(key));
     }
 
     /**
diff --git a/src/main/java/org/bukkit/command/Command.java b/src/main/java/org/bukkit/command/Command.java
index 74384a56eebbce41d431db2507c55eddbcf50a41..71eb845a4d3b8b6ec3b816a0f20ec807e0f9a86d 100644
--- a/src/main/java/org/bukkit/command/Command.java
+++ b/src/main/java/org/bukkit/command/Command.java
@@ -66,7 +66,7 @@ public abstract class Command {
      * @param args All arguments passed to the command, split via ' '
      * @return true if the command was successful, otherwise false
      */
-    public abstract boolean execute(@NotNull CommandSender sender, @NotNull String commandLabel, @NotNull String[] args);
+    public abstract boolean execute(@NotNull CommandSender sender, @NotNull String commandLabel, @NotNull String @NotNull [] args);
 
     /**
      * Executed on tab completion for this command, returning a list of
@@ -80,7 +80,7 @@ public abstract class Command {
      * @throws IllegalArgumentException if sender, alias, or args is null
      */
     @NotNull
-    public List<String> tabComplete(@NotNull CommandSender sender, @NotNull String alias, @NotNull String[] args) throws IllegalArgumentException {
+    public List<String> tabComplete(@NotNull CommandSender sender, @NotNull String alias, @NotNull String @NotNull [] args) throws IllegalArgumentException {
         return tabComplete0(sender, alias, args, null);
     }
 
@@ -97,7 +97,7 @@ public abstract class Command {
      * @throws IllegalArgumentException if sender, alias, or args is null
      */
     @NotNull
-    public List<String> tabComplete(@NotNull CommandSender sender, @NotNull String alias, @NotNull String[] args, @Nullable Location location) throws IllegalArgumentException {
+    public List<String> tabComplete(@NotNull CommandSender sender, @NotNull String alias, @NotNull String @NotNull [] args, @Nullable Location location) throws IllegalArgumentException {
         return tabComplete(sender, alias, args);
     }
 
diff --git a/src/main/java/org/bukkit/command/CommandExecutor.java b/src/main/java/org/bukkit/command/CommandExecutor.java
index 45cb8da120ac976fc1ccac7c54264d8d3c4f2072..8d7139467f7102722c644bb516c4a8facd73949a 100644
--- a/src/main/java/org/bukkit/command/CommandExecutor.java
+++ b/src/main/java/org/bukkit/command/CommandExecutor.java
@@ -19,5 +19,5 @@ public interface CommandExecutor {
      * @param args Passed command arguments
      * @return true if a valid command, otherwise false
      */
-    public boolean onCommand(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args);
+    public boolean onCommand(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String @NotNull [] args);
 }
diff --git a/src/main/java/org/bukkit/command/MessageCommandSender.java b/src/main/java/org/bukkit/command/MessageCommandSender.java
index 946d2f0ef37c6cf895caf8d3c6963c7889e0567b..d9137e2d318b6616b1827239706f0832aba2b1f0 100644
--- a/src/main/java/org/bukkit/command/MessageCommandSender.java
+++ b/src/main/java/org/bukkit/command/MessageCommandSender.java
@@ -22,7 +22,7 @@ import org.jetbrains.annotations.Nullable;
 public interface MessageCommandSender extends CommandSender {
 
     @Override
-    default void sendMessage(@NotNull String[] messages) {
+    default void sendMessage(@NotNull String @NotNull [] messages) {
         for (String message : messages) {
             sendMessage(message);
         }
@@ -34,7 +34,7 @@ public interface MessageCommandSender extends CommandSender {
     }
 
     @Override
-    default void sendMessage(@Nullable UUID sender, @NotNull String[] messages) {
+    default void sendMessage(@Nullable UUID sender, @NotNull String @NotNull [] messages) {
         for (String message : messages) {
             sendMessage(message);
         }
diff --git a/src/main/java/org/bukkit/command/MultipleCommandAlias.java b/src/main/java/org/bukkit/command/MultipleCommandAlias.java
index 8487bfe3327616fd8eb871c52b35ce3af033934c..9a47b364d09d70d15761c18600c033ff2d61a8b6 100644
--- a/src/main/java/org/bukkit/command/MultipleCommandAlias.java
+++ b/src/main/java/org/bukkit/command/MultipleCommandAlias.java
@@ -18,8 +18,7 @@ public class MultipleCommandAlias extends Command {
      *
      * @return commands associated with alias
      */
-    @NotNull
-    public Command[] getCommands() {
+    public @NotNull Command @NotNull [] getCommands() {
         return commands;
     }
 
diff --git a/src/main/java/org/bukkit/command/TabCompleter.java b/src/main/java/org/bukkit/command/TabCompleter.java
index ed6f6525a627dcb4739c03a47d27c29417b1b35b..2bcdaca5f206f423f7273723994e9614e898d2ee 100644
--- a/src/main/java/org/bukkit/command/TabCompleter.java
+++ b/src/main/java/org/bukkit/command/TabCompleter.java
@@ -23,5 +23,5 @@ public interface TabCompleter {
      *     to default to the command executor
      */
     @Nullable
-    public List<String> onTabComplete(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args);
+    public List<String> onTabComplete(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String @NotNull [] args);
 }
diff --git a/src/main/java/org/bukkit/damage/DamageEffect.java b/src/main/java/org/bukkit/damage/DamageEffect.java
index 8cf8fde6020f7434d53a810949c937ec8fe4a807..2e442f1469077125c86154d2a615f65826854347 100644
--- a/src/main/java/org/bukkit/damage/DamageEffect.java
+++ b/src/main/java/org/bukkit/damage/DamageEffect.java
@@ -1,7 +1,7 @@
 package org.bukkit.damage;
 
 import com.google.common.base.Preconditions;
-import org.bukkit.Bukkit;
+import io.papermc.paper.InternalAPIBridge;
 import org.bukkit.Sound;
 import org.jetbrains.annotations.ApiStatus;
 import org.jetbrains.annotations.NotNull;
@@ -40,7 +40,7 @@ public interface DamageEffect {
 
     @NotNull
     private static DamageEffect getDamageEffect(@NotNull String key) {
-        return Preconditions.checkNotNull(Bukkit.getUnsafe().getDamageEffect(key), "No DamageEffect found for %s. This is a bug.", key);
+        return Preconditions.checkNotNull(InternalAPIBridge.get().getDamageEffect(key), "No DamageEffect found for %s. This is a bug.", key);
     }
 
     /**
diff --git a/src/main/java/org/bukkit/damage/DamageType.java b/src/main/java/org/bukkit/damage/DamageType.java
index 14f90d8d4c1caaf35f5b9385981c12191d8e4fd3..b74846c77d42dec702dc25d8b1ce3225251e0c2f 100644
--- a/src/main/java/org/bukkit/damage/DamageType.java
+++ b/src/main/java/org/bukkit/damage/DamageType.java
@@ -1,5 +1,7 @@
 package org.bukkit.damage;
 
+import io.papermc.paper.registry.RegistryAccess;
+import io.papermc.paper.registry.RegistryKey;
 import org.bukkit.Keyed;
 import org.bukkit.NamespacedKey;
 import org.bukkit.Registry;
@@ -12,7 +14,7 @@ import org.jetbrains.annotations.NotNull;
  * <p>
  * Constants in this class include the base types provided by the vanilla
  * server. Data packs are capable of registering more types of damage which may
- * be obtained through the {@link Registry#DAMAGE_TYPE}.
+ * be obtained through {@link io.papermc.paper.registry.RegistryAccess#getRegistry(RegistryKey)} and {@link RegistryKey#DAMAGE_TYPE}.
  *
  * @see <a href="https://minecraft.wiki/w/Damage_type">Minecraft Wiki</a>
  */
@@ -71,7 +73,7 @@ public interface DamageType extends Keyed, Translatable {
 
     @NotNull
     private static DamageType getDamageType(@NotNull String key) {
-        return Registry.DAMAGE_TYPE.getOrThrow(NamespacedKey.minecraft(key));
+        return RegistryAccess.registryAccess().getRegistry(RegistryKey.DAMAGE_TYPE).getOrThrow(NamespacedKey.minecraft(key));
     }
 
     /**
diff --git a/src/main/java/org/bukkit/enchantments/Enchantment.java b/src/main/java/org/bukkit/enchantments/Enchantment.java
index a824ac90e78d3d7f90b01397270e54422d88e8b9..288123c31a27084e4da6602c167beef2b1643e8b 100644
--- a/src/main/java/org/bukkit/enchantments/Enchantment.java
+++ b/src/main/java/org/bukkit/enchantments/Enchantment.java
@@ -1,6 +1,8 @@
 package org.bukkit.enchantments;
 
 import com.google.common.collect.Lists;
+import io.papermc.paper.registry.RegistryAccess;
+import io.papermc.paper.registry.RegistryKey;
 import java.util.Locale;
 import org.bukkit.Keyed;
 import org.bukkit.NamespacedKey;
@@ -229,7 +231,7 @@ public abstract class Enchantment implements Keyed, Translatable, net.kyori.adve
 
     @NotNull
     private static Enchantment getEnchantment(@NotNull String key) {
-        return Registry.ENCHANTMENT.getOrThrow(NamespacedKey.minecraft(key));
+        return RegistryAccess.registryAccess().getRegistry(RegistryKey.ENCHANTMENT).getOrThrow(NamespacedKey.minecraft(key));
     }
 
     /**
diff --git a/src/main/java/org/bukkit/entity/Entity.java b/src/main/java/org/bukkit/entity/Entity.java
index 19272cff8d6d040e95b2644d70acdac606e06c16..ddf7829eee5e3f0ded9319a5a0a7b2e2486320a4 100644
--- a/src/main/java/org/bukkit/entity/Entity.java
+++ b/src/main/java/org/bukkit/entity/Entity.java
@@ -3,6 +3,7 @@ package org.bukkit.entity;
 import java.util.List;
 import java.util.Set;
 import java.util.UUID;
+import io.papermc.paper.entity.LookAnchor;
 import org.bukkit.Chunk; // Paper
 import org.bukkit.EntityEffect;
 import org.bukkit.Location;
@@ -13,6 +14,7 @@ import org.bukkit.World;
 import org.bukkit.block.BlockFace;
 import org.bukkit.block.PistonMoveReaction;
 import org.bukkit.command.CommandSender;
+import org.bukkit.event.entity.CreatureSpawnEvent;
 import org.bukkit.event.entity.EntityDamageEvent;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
 import org.bukkit.material.Directional;
@@ -150,6 +152,26 @@ public interface Entity extends Metadatable, CommandSender, Nameable, Persistent
      * @return <code>true</code> if the teleport was successful
      */
     boolean teleport(@NotNull Location location, @NotNull TeleportCause cause, @NotNull io.papermc.paper.entity.TeleportFlag @NotNull... teleportFlags);
+
+    /**
+     * Causes the entity to look towards the given position.
+     *
+     * @param x x coordinate
+     * @param y y coordinate
+     * @param z z coordinate
+     * @param entityAnchor What part of the entity should face the given position
+     */
+    void lookAt(double x, double y, double z, @NotNull LookAnchor entityAnchor);
+
+    /**
+     * Causes the entity to look towards the given position.
+     *
+     * @param position Position to look at in the player's current world
+     * @param entityAnchor What part of the entity should face the given position
+     */
+    default void lookAt(@NotNull io.papermc.paper.math.Position position, @NotNull LookAnchor entityAnchor) {
+        this.lookAt(position.x(), position.y(), position.z(), entityAnchor);
+    }
     // Paper end - Teleport API
 
     /**
@@ -1051,11 +1073,12 @@ public interface Entity extends Metadatable, CommandSender, Nameable, Persistent
      * <p>
      * Also, this method will fire the same events as a normal entity spawn.
      *
-     * @param location The location to spawn the entity at.
-     * @return Whether the entity was successfully spawned.
+     * @param location the location to spawn the entity at
+     * @return whether the entity was successfully spawned
+     * @since 1.17.1
      */
-    public default boolean spawnAt(@NotNull Location location) {
-        return spawnAt(location, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DEFAULT);
+    default boolean spawnAt(@NotNull Location location) {
+        return spawnAt(location, CreatureSpawnEvent.SpawnReason.DEFAULT);
     }
 
     /**
@@ -1065,11 +1088,12 @@ public interface Entity extends Metadatable, CommandSender, Nameable, Persistent
      * <p>
      * Also, this method will fire the same events as a normal entity spawn.
      *
-     * @param location The location to spawn the entity at.
-     * @param reason   The reason for the entity being spawned.
-     * @return Whether the entity was successfully spawned.
+     * @param location the location to spawn the entity at
+     * @param reason   the reason for the entity being spawned
+     * @return whether the entity was successfully spawned
+     * @since 1.17.1
      */
-    public boolean spawnAt(@NotNull Location location, @NotNull org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason reason);
+    boolean spawnAt(@NotNull Location location, @NotNull CreatureSpawnEvent.SpawnReason reason);
 
     /**
      * Check if entity is inside powdered snow.
diff --git a/src/main/java/org/bukkit/entity/EntityType.java b/src/main/java/org/bukkit/entity/EntityType.java
index 0251ec12e819565db2ca9e7e87f5c06566f54e1d..29d22511660060c182314e23ad849bca34611717 100644
--- a/src/main/java/org/bukkit/entity/EntityType.java
+++ b/src/main/java/org/bukkit/entity/EntityType.java
@@ -503,8 +503,9 @@ public enum EntityType implements Keyed, Translatable, net.kyori.adventure.trans
      *
      * @param world the world to check
      * @return true if this EntityType can be used to spawn an Entity for this World.
+     * @deprecated use {@link io.papermc.paper.world.flag.FeatureFlagSetHolder#isEnabled(io.papermc.paper.world.flag.FeatureDependant)}
      */
-    @Deprecated(forRemoval = true, since = "1.20") // Paper
+    @Deprecated(forRemoval = true, since = "1.20")
     public boolean isEnabledByFeature(@NotNull World world) {
         return Bukkit.getDataPackManager().isEnabledByFeature(this, world);
     }
diff --git a/src/main/java/org/bukkit/entity/HumanEntity.java b/src/main/java/org/bukkit/entity/HumanEntity.java
index 188c8e27d724a1593dc586b58c7dcb74a1b3d926..34538999ef88b63fa37023edd81ab7b48392de73 100644
--- a/src/main/java/org/bukkit/entity/HumanEntity.java
+++ b/src/main/java/org/bukkit/entity/HumanEntity.java
@@ -2,18 +2,22 @@ package org.bukkit.entity;
 
 import java.util.Collection;
 import java.util.Set;
+import java.util.function.Consumer;
 import org.bukkit.GameMode;
 import org.bukkit.Location;
 import org.bukkit.Material;
 import org.bukkit.NamespacedKey;
+import org.bukkit.inventory.EquipmentSlot;
 import org.bukkit.inventory.Inventory;
 import org.bukkit.inventory.InventoryHolder;
 import org.bukkit.inventory.InventoryView;
 import org.bukkit.inventory.ItemStack;
 import org.bukkit.inventory.MainHand;
+import org.bukkit.inventory.MenuType;
 import org.bukkit.inventory.Merchant;
 import org.bukkit.inventory.PlayerInventory;
 import org.bukkit.inventory.meta.FireworkMeta;
+import org.jetbrains.annotations.ApiStatus;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
@@ -123,7 +127,10 @@ public interface HumanEntity extends LivingEntity, AnimalTamer, InventoryHolder
      *     no inventory will be opened and null will be returned.
      * @return The newly opened inventory view, or null if it could not be
      *     opened.
+     * @deprecated This method should be replaced by {@link MenuType#CRAFTING}
+     * see {@link MenuType.Typed#builder()} and its options for more information.
      */
+    @Deprecated(since = "1.21.4")
     @Nullable
     public InventoryView openWorkbench(@Nullable Location location, boolean force);
 
@@ -137,7 +144,10 @@ public interface HumanEntity extends LivingEntity, AnimalTamer, InventoryHolder
      *     location, no inventory will be opened and null will be returned.
      * @return The newly opened inventory view, or null if it could not be
      *     opened.
+     * @deprecated This method should be replaced by {@link MenuType#ENCHANTMENT}
+     * see {@link MenuType.Typed#builder()} and its options for more information.
      */
+    @Deprecated(since = "1.21.4")
     @Nullable
     public InventoryView openEnchanting(@Nullable Location location, boolean force);
 
@@ -163,8 +173,10 @@ public interface HumanEntity extends LivingEntity, AnimalTamer, InventoryHolder
      * @param trader The merchant to trade with. Cannot be null.
      * @param force whether to force the trade even if another player is trading
      * @return The newly opened inventory view, or null if it could not be
-     * opened.
+     * @deprecated This method can be replaced by using {@link MenuType#MERCHANT}
+     * in conjunction with {@link #openInventory(InventoryView)}.
      */
+    @Deprecated(since = "1.21.4")
     @Nullable
     public InventoryView openMerchant(@NotNull Villager trader, boolean force);
 
@@ -177,8 +189,10 @@ public interface HumanEntity extends LivingEntity, AnimalTamer, InventoryHolder
      * @param merchant The merchant to trade with. Cannot be null.
      * @param force whether to force the trade even if another player is trading
      * @return The newly opened inventory view, or null if it could not be
-     * opened.
+     * @deprecated This method can be replaced by using {@link MenuType#MERCHANT}
+     * in conjunction with {@link #openInventory(InventoryView)}.
      */
+    @Deprecated(since = "1.21.4")
     @Nullable
     public InventoryView openMerchant(@NotNull Merchant merchant, boolean force);
 
@@ -193,7 +207,10 @@ public interface HumanEntity extends LivingEntity, AnimalTamer, InventoryHolder
      *     no inventory will be opened and null will be returned.
      * @return The newly opened inventory view, or null if it could not be
      *     opened.
+     * @deprecated This method should be replaced by {@link MenuType#ANVIL}
+     * see {@link MenuType.Typed#builder()} and its options for more information.
      */
+    @Deprecated(since = "1.21.4")
     @Nullable
     public InventoryView openAnvil(@Nullable Location location, boolean force);
 
@@ -207,7 +224,10 @@ public interface HumanEntity extends LivingEntity, AnimalTamer, InventoryHolder
      *     no inventory will be opened and null will be returned.
      * @return The newly opened inventory view, or null if it could not be
      *     opened.
+     * @deprecated This method should be replaced by {@link MenuType#CARTOGRAPHY_TABLE}
+     * see {@link MenuType.Typed#builder()} and its options for more information.
      */
+    @Deprecated(since = "1.21.4")
     @Nullable
     public InventoryView openCartographyTable(@Nullable Location location, boolean force);
 
@@ -221,7 +241,10 @@ public interface HumanEntity extends LivingEntity, AnimalTamer, InventoryHolder
      *     no inventory will be opened and null will be returned.
      * @return The newly opened inventory view, or null if it could not be
      *     opened.
+     * @deprecated This method should be replaced by {@link MenuType#GRINDSTONE}
+     * see {@link MenuType.Typed#builder()} and its options for more information.
      */
+    @Deprecated(since = "1.21.4")
     @Nullable
     public InventoryView openGrindstone(@Nullable Location location, boolean force);
 
@@ -235,7 +258,10 @@ public interface HumanEntity extends LivingEntity, AnimalTamer, InventoryHolder
      *     no inventory will be opened and null will be returned.
      * @return The newly opened inventory view, or null if it could not be
      *     opened.
+     * @deprecated This method should be replaced by {@link MenuType#LOOM}
+     * see {@link MenuType.Typed#builder()} and its options for more information.
      */
+    @Deprecated(since = "1.21.4")
     @Nullable
     public InventoryView openLoom(@Nullable Location location, boolean force);
 
@@ -249,7 +275,10 @@ public interface HumanEntity extends LivingEntity, AnimalTamer, InventoryHolder
      *     no inventory will be opened and null will be returned.
      * @return The newly opened inventory view, or null if it could not be
      *     opened.
+     * @deprecated This method should be replaced by {@link MenuType#SMITHING}
+     * see {@link MenuType.Typed#builder()} and its options for more information.
      */
+    @Deprecated(since = "1.21.4")
     @Nullable
     public InventoryView openSmithingTable(@Nullable Location location, boolean force);
 
@@ -263,7 +292,10 @@ public interface HumanEntity extends LivingEntity, AnimalTamer, InventoryHolder
      *     no inventory will be opened and null will be returned.
      * @return The newly opened inventory view, or null if it could not be
      *     opened.
+     * @deprecated This method should be replaced by {@link MenuType#STONECUTTER}
+     * see {@link MenuType.Typed#builder()} and its options for more information.
      */
+    @Deprecated(since = "1.21.4")
     @Nullable
     public InventoryView openStonecutter(@Nullable Location location, boolean force);
     // Paper end
@@ -421,9 +453,25 @@ public interface HumanEntity extends LivingEntity, AnimalTamer, InventoryHolder
      * is still valid.
      *
      * @return Bed Location if has slept in one, otherwise null.
+     * @see #getPotentialRespawnLocation()
+     * @deprecated Misleading name. This method also returns the location of
+     * respawn anchors.
      */
     @Nullable
-    public Location getPotentialBedLocation();
+    @Deprecated(since = "1.21.4")
+    default Location getPotentialBedLocation() {
+        return this.getPotentialRespawnLocation();
+    }
+
+    /**
+     * Gets the Location where the player will spawn at, null if they
+     * don't have a valid respawn point. This method will not attempt
+     * to validate if the current respawn location is still valid.
+     *
+     * @return respawn location if exists, otherwise null.
+     */
+    @Nullable
+    Location getPotentialRespawnLocation();
     // Paper end
     // Paper start
     /**
@@ -703,8 +751,115 @@ public interface HumanEntity extends LivingEntity, AnimalTamer, InventoryHolder
      *
      * @param dropAll True to drop entire stack, false to drop 1 of the stack
      * @return True if item was dropped successfully
+     * @apiNote You should instead use {@link #dropItem(EquipmentSlot, int)} or {@link #dropItem(EquipmentSlot)} with a {@link EquipmentSlot#HAND} parameter.
+     */
+    @ApiStatus.Obsolete(since = "1.21.4")
+    boolean dropItem(boolean dropAll);
+
+    /**
+     * Makes the player drop all items from their inventory based on the inventory slot.
+     *
+     * @param slot the equipment slot to drop
+     * @return the dropped item entity, or null if the action was unsuccessful
+     */
+    @Nullable
+    default Item dropItem(final int slot) {
+        return this.dropItem(slot, Integer.MAX_VALUE);
+    }
+
+    /**
+     * Makes the player drop an item from their inventory based on the inventory slot.
+     *
+     * @param slot   the slot to drop
+     * @param amount the number of items to drop from this slot. Values below one always return null
+     * @return the dropped item entity, or null if the action was unsuccessful
+     * @throws IllegalArgumentException if the slot is negative or bigger than the player's inventory
+     */
+    @Nullable
+    default Item dropItem(final int slot, final int amount) {
+        return this.dropItem(slot, amount, false, null);
+    }
+
+    /**
+     * Makes the player drop an item from their inventory based on the inventory slot.
+     *
+     * @param slot            the slot to drop
+     * @param amount          the number of items to drop from this slot. Values below one always return null
+     * @param throwRandomly   controls the randomness of the dropped items velocity, where {@code true} mimics dropped
+     *                        items during a player's death, while {@code false} acts like a normal item drop.
+     * @param entityOperation the function to be run before adding the entity into the world
+     * @return the dropped item entity, or null if the action was unsuccessful
+     * @throws IllegalArgumentException if the slot is negative or bigger than the player's inventory
+     */
+    @Nullable
+    Item dropItem(int slot, int amount, boolean throwRandomly, @Nullable Consumer<Item> entityOperation);
+
+    /**
+     * Makes the player drop all items from their inventory based on the equipment slot.
+     *
+     * @param slot the equipment slot to drop
+     * @return the dropped item entity, or null if the action was unsuccessful
      */
-    public boolean dropItem(boolean dropAll);
+    @Nullable
+    default Item dropItem(final @NotNull EquipmentSlot slot) {
+        return this.dropItem(slot, Integer.MAX_VALUE);
+    }
+
+    /**
+     * Makes the player drop an item from their inventory based on the equipment slot.
+     *
+     * @param slot   the equipment slot to drop
+     * @param amount the amount of items to drop from this equipment slot. Values below one always return null
+     * @return the dropped item entity, or null if the action was unsuccessful
+     */
+    @Nullable
+    default Item dropItem(final @NotNull EquipmentSlot slot, final int amount) {
+        return this.dropItem(slot, amount, false, null);
+    }
+
+    /**
+     * Makes the player drop an item from their inventory based on the equipment slot.
+     *
+     * @param slot            the equipment slot to drop
+     * @param amount          The amount of items to drop from this equipment slot. Values below one always return null
+     * @param throwRandomly   controls the randomness of the dropped items velocity, where {@code true} mimics dropped
+     *                        items during a player's death, while {@code false} acts like a normal item drop.
+     * @param entityOperation the function to be run before adding the entity into the world
+     * @return the dropped item entity, or null if the action was unsuccessful
+     */
+    @Nullable
+    Item dropItem(@NotNull EquipmentSlot slot, int amount, boolean throwRandomly, @Nullable Consumer<Item> entityOperation);
+
+    /**
+     * Makes the player drop any arbitrary {@link ItemStack}, independently of whether the player actually
+     * has that item in their inventory.
+     * <p>
+     * This method modifies neither the item nor the player's inventory.
+     * Item removal has to be handled by the method caller.
+     *
+     * @param itemStack the itemstack to drop
+     * @return the dropped item entity, or null if the action was unsuccessful
+     */
+    @Nullable
+    default Item dropItem(final @NotNull ItemStack itemStack) {
+        return this.dropItem(itemStack, false, null);
+    }
+
+    /**
+     * Makes the player drop any arbitrary {@link ItemStack}, independently of whether the player actually
+     * has that item in their inventory.
+     * <p>
+     * This method modifies neither the item nor the player's inventory.
+     * Item removal has to be handled by the method caller.
+     *
+     * @param itemStack       the itemstack to drop
+     * @param throwRandomly   controls the randomness of the dropped items velocity, where {@code true} mimics dropped
+     *                        items during a player's death, while {@code false} acts like a normal item drop.
+     * @param entityOperation the function to be run before adding the entity into the world
+     * @return the dropped item entity, or null if the action was unsuccessful
+     */
+    @Nullable
+    Item dropItem(final @NotNull ItemStack itemStack, boolean throwRandomly, @Nullable Consumer<Item> entityOperation);
 
     /**
      * Gets the players current exhaustion level.
diff --git a/src/main/java/org/bukkit/entity/Mob.java b/src/main/java/org/bukkit/entity/Mob.java
index 9a10262a952e330f42187d6e4edab5a225bfba62..ca773a807e60fae0cc012460349a4c8a1ccb1812 100644
--- a/src/main/java/org/bukkit/entity/Mob.java
+++ b/src/main/java/org/bukkit/entity/Mob.java
@@ -191,7 +191,7 @@ public interface Mob extends LivingEntity, Lootable, io.papermc.paper.entity.Lea
      * set by {@link #setAggressive(boolean)}. {@link Panda}'s are always
      * aggressive if their combined {@link Panda.Gene} is {@link Panda.Gene#AGGRESSIVE}.
      *
-     * @return wether the mob is aggressive or not
+     * @return whether the mob is aggressive or not
      */
     boolean isAggressive();
 
@@ -199,7 +199,7 @@ public interface Mob extends LivingEntity, Lootable, io.papermc.paper.entity.Lea
      * Some mobs will raise their arm(s) when aggressive,
      * see {@link #isAggressive()} for full list.
      *
-     * @param aggressive wether the mob should be aggressive or not
+     * @param aggressive whether the mob should be aggressive or not
      * @see #isAggressive()
      */
     void setAggressive(boolean aggressive);
diff --git a/src/main/java/org/bukkit/entity/Player.java b/src/main/java/org/bukkit/entity/Player.java
index fac4aec289e07231d80a9890653432f688355afa..7d21ee64c9b9c14412a1eddb63fae812a91e7d9c 100644
--- a/src/main/java/org/bukkit/entity/Player.java
+++ b/src/main/java/org/bukkit/entity/Player.java
@@ -9,6 +9,7 @@ import java.util.Date;
 import java.util.Map;
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
+import io.papermc.paper.entity.LookAnchor;
 import org.bukkit.BanEntry;
 import org.bukkit.DyeColor;
 import org.bukkit.Effect;
@@ -1309,8 +1310,8 @@ public interface Player extends HumanEntity, Conversable, OfflinePlayer, PluginM
      * they have seen it before because this method was called.
      * Note this method does not make the player invulnerable, which is normally expected when viewing credits.
      *
-     * @see #hasSeenWinScreen() 
-     * @see #setHasSeenWinScreen(boolean) 
+     * @see #hasSeenWinScreen()
+     * @see #setHasSeenWinScreen(boolean)
      * @see <a href="https://minecraft.wiki/wiki/End_Poem#Technical_details">https://minecraft.wiki/wiki/End_Poem#Technical_details</a>
      */
     public void showWinScreen();
@@ -2307,7 +2308,7 @@ public interface Player extends HumanEntity, Conversable, OfflinePlayer, PluginM
      *     long.
      */
     @Deprecated // Paper - adventure
-    public void setResourcePack(@NotNull String url, @Nullable byte[] hash);
+    public void setResourcePack(@NotNull String url, byte @Nullable [] hash);
 
     /**
      * Request that the player's client download and switch resource packs.
@@ -2352,7 +2353,7 @@ public interface Player extends HumanEntity, Conversable, OfflinePlayer, PluginM
      *     long.
      */
     @Deprecated // Paper - adventure
-    public void setResourcePack(@NotNull String url, @Nullable byte[] hash, @Nullable String prompt);
+    public void setResourcePack(@NotNull String url, byte @Nullable [] hash, @Nullable String prompt);
 
     // Paper start
     /**
@@ -2446,7 +2447,7 @@ public interface Player extends HumanEntity, Conversable, OfflinePlayer, PluginM
      * @deprecated in favour of {@link #sendResourcePacks(net.kyori.adventure.resource.ResourcePackRequest)}
      */
     @Deprecated // Paper - adventure
-    public void setResourcePack(@NotNull String url, @Nullable byte[] hash, boolean force);
+    public void setResourcePack(@NotNull String url, byte @Nullable [] hash, boolean force);
 
     /**
      * Request that the player's client download and switch resource packs.
@@ -2493,7 +2494,7 @@ public interface Player extends HumanEntity, Conversable, OfflinePlayer, PluginM
      * @deprecated in favour of {@link #sendResourcePacks(net.kyori.adventure.resource.ResourcePackRequest)}
      */
     @Deprecated // Paper
-    public void setResourcePack(@NotNull String url, @Nullable byte[] hash, @Nullable String prompt, boolean force);
+    public void setResourcePack(@NotNull String url, byte @Nullable [] hash, @Nullable String prompt, boolean force);
 
     // Paper start
     /**
@@ -2591,7 +2592,7 @@ public interface Player extends HumanEntity, Conversable, OfflinePlayer, PluginM
      * @deprecated in favour of {@link #sendResourcePacks(net.kyori.adventure.resource.ResourcePackRequest)}
      */
     @Deprecated // Paper - adventure
-    public void setResourcePack(@NotNull UUID id, @NotNull String url, @Nullable byte[] hash, @Nullable String prompt, boolean force);
+    public void setResourcePack(@NotNull UUID id, @NotNull String url, byte @Nullable [] hash, @Nullable String prompt, boolean force);
 
     // Paper start
     /**
@@ -3392,7 +3393,7 @@ public interface Player extends HumanEntity, Conversable, OfflinePlayer, PluginM
      * @param simulationDistance the player's new simulation distance
      */
     public void setSimulationDistance(int simulationDistance);
-    
+
     /**
      * Gets the no-ticking view distance for this player.
      * <p>
@@ -3730,26 +3731,6 @@ public interface Player extends HumanEntity, Conversable, OfflinePlayer, PluginM
      */
     void setRotation(float yaw, float pitch);
 
-    /**
-     * Causes the player to look towards the given position.
-     *
-     * @param x x coordinate
-     * @param y y coordinate
-     * @param z z coordinate
-     * @param playerAnchor What part of the player should face the given position
-     */
-    void lookAt(double x, double y, double z, @NotNull io.papermc.paper.entity.LookAnchor playerAnchor);
-
-    /**
-     * Causes the player to look towards the given position.
-     *
-     * @param position Position to look at in the player's current world
-     * @param playerAnchor What part of the player should face the given position
-     */
-    default void lookAt(@NotNull io.papermc.paper.math.Position position, @NotNull io.papermc.paper.entity.LookAnchor playerAnchor) {
-        this.lookAt(position.x(), position.y(), position.z(), playerAnchor);
-    }
-
     /**
      * Causes the player to look towards the given entity.
      *
@@ -3757,7 +3738,7 @@ public interface Player extends HumanEntity, Conversable, OfflinePlayer, PluginM
      * @param playerAnchor What part of the player should face the entity
      * @param entityAnchor What part of the entity the player should face
      */
-    void lookAt(@NotNull org.bukkit.entity.Entity entity, @NotNull io.papermc.paper.entity.LookAnchor playerAnchor, @NotNull io.papermc.paper.entity.LookAnchor entityAnchor);
+    void lookAt(@NotNull org.bukkit.entity.Entity entity, @NotNull LookAnchor playerAnchor, @NotNull LookAnchor entityAnchor);
     // Paper end - Teleport API
 
     // Paper start
diff --git a/src/main/java/org/bukkit/entity/Turtle.java b/src/main/java/org/bukkit/entity/Turtle.java
index aa83615a0c6565c9874c906a83cfe20c2a964b22..3b26e9e48a56ab5a09e4d89c02faed96d1e80a4e 100644
--- a/src/main/java/org/bukkit/entity/Turtle.java
+++ b/src/main/java/org/bukkit/entity/Turtle.java
@@ -22,7 +22,6 @@ public interface Turtle extends Animals {
      */
     boolean isLayingEgg();
 
-    // Paper start
     /**
      * Get the turtle's home location
      *
@@ -49,8 +48,12 @@ public interface Turtle extends Animals {
      * Get if turtle is digging to lay eggs
      *
      * @return True if digging
+     * @deprecated in favor of {@link #isLayingEgg()}
      */
-    boolean isDigging();
+    @Deprecated(since = "1.21.4")
+    default boolean isDigging() {
+        return this.isLayingEgg();
+    }
 
     /**
      * Set if turtle is carrying egg
@@ -58,5 +61,4 @@ public interface Turtle extends Animals {
      * @param hasEgg True if carrying egg
      */
     void setHasEgg(boolean hasEgg);
-    // Paper end
 }
diff --git a/src/main/java/org/bukkit/entity/Wolf.java b/src/main/java/org/bukkit/entity/Wolf.java
index c73489f4b745bc84501ce94f0227b034d9768eae..346fdddd2ed8f0b8b66860c969f5e80c51c6d622 100644
--- a/src/main/java/org/bukkit/entity/Wolf.java
+++ b/src/main/java/org/bukkit/entity/Wolf.java
@@ -1,5 +1,7 @@
 package org.bukkit.entity;
 
+import io.papermc.paper.registry.RegistryAccess;
+import io.papermc.paper.registry.RegistryKey;
 import org.bukkit.DyeColor;
 import org.bukkit.Keyed;
 import org.bukkit.NamespacedKey;
@@ -105,7 +107,7 @@ public interface Wolf extends Tameable, Sittable, io.papermc.paper.entity.Collar
 
         @NotNull
         private static Variant getVariant(@NotNull String key) {
-            return Registry.WOLF_VARIANT.getOrThrow(NamespacedKey.minecraft(key));
+            return RegistryAccess.registryAccess().getRegistry(RegistryKey.WOLF_VARIANT).getOrThrow(NamespacedKey.minecraft(key));
         }
     }
 }
diff --git a/src/main/java/org/bukkit/event/HandlerList.java b/src/main/java/org/bukkit/event/HandlerList.java
index 2292bd460ce2be113beb4ba6b4eb19350060f01c..64d8916a8ca1cc5678a34c17a8bbbff45323beb0 100644
--- a/src/main/java/org/bukkit/event/HandlerList.java
+++ b/src/main/java/org/bukkit/event/HandlerList.java
@@ -203,8 +203,7 @@ public class HandlerList {
      *
      * @return the array of registered listeners
      */
-    @NotNull
-    public RegisteredListener[] getRegisteredListeners() {
+    public @NotNull RegisteredListener @NotNull [] getRegisteredListeners() {
         RegisteredListener[] handlers;
         while ((handlers = this.handlers) == null) bake(); // This prevents fringe cases of returning null
         return handlers;
diff --git a/src/main/java/org/bukkit/event/block/BlockDispenseEvent.java b/src/main/java/org/bukkit/event/block/BlockDispenseEvent.java
index 14d1eb5d93fd5a87473a0b8df240cf09f1752360..e8ed75ba7dafaf9db66910bff20d80dee43725e8 100644
--- a/src/main/java/org/bukkit/event/block/BlockDispenseEvent.java
+++ b/src/main/java/org/bukkit/event/block/BlockDispenseEvent.java
@@ -65,7 +65,7 @@ public class BlockDispenseEvent extends BlockEvent implements Cancellable {
      * @param vel the velocity of the item being dispensed
      */
     public void setVelocity(@NotNull Vector vel) {
-        velocity = vel;
+        velocity = vel.clone();
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/event/block/FluidLevelChangeEvent.java b/src/main/java/org/bukkit/event/block/FluidLevelChangeEvent.java
index 9bd0440c3776c0b73c6eb11274070b11d0ade856..c61f6b1bd5f08b6a287cfc7a33a2f3fee0e5f4e1 100644
--- a/src/main/java/org/bukkit/event/block/FluidLevelChangeEvent.java
+++ b/src/main/java/org/bukkit/event/block/FluidLevelChangeEvent.java
@@ -43,7 +43,7 @@ public class FluidLevelChangeEvent extends BlockEvent implements Cancellable {
         Preconditions.checkArgument(newData != null, "newData null");
         Preconditions.checkArgument(this.newData.getMaterial().equals(newData.getMaterial()), "Cannot change fluid type");
 
-        this.newData = newData;
+        this.newData = newData.clone();
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/event/entity/EntityDeathEvent.java b/src/main/java/org/bukkit/event/entity/EntityDeathEvent.java
index 086bec9daa89315b1d4719ab74de0e889f93e340..42ffb81708b327f765ba3235fdd1ab69cd7589fd 100644
--- a/src/main/java/org/bukkit/event/entity/EntityDeathEvent.java
+++ b/src/main/java/org/bukkit/event/entity/EntityDeathEvent.java
@@ -11,7 +11,7 @@ import org.jetbrains.annotations.Nullable;
 /**
  * Thrown whenever a LivingEntity dies
  */
-public class EntityDeathEvent extends EntityEvent implements org.bukkit.event.Cancellable {  // Paper - make cancellable
+public class EntityDeathEvent extends EntityEvent implements org.bukkit.event.Cancellable { // Paper - make cancellable
     private static final HandlerList handlers = new HandlerList();
     private final DamageSource damageSource;
     private final List<ItemStack> drops;
diff --git a/src/main/java/org/bukkit/event/entity/EntityKnockbackEvent.java b/src/main/java/org/bukkit/event/entity/EntityKnockbackEvent.java
index 0d465629ecd86ba796e99d35c0492597535cb258..6c0c2f78de55467914d4da615ab214322b8136b7 100644
--- a/src/main/java/org/bukkit/event/entity/EntityKnockbackEvent.java
+++ b/src/main/java/org/bukkit/event/entity/EntityKnockbackEvent.java
@@ -99,7 +99,7 @@ public class EntityKnockbackEvent extends EntityEvent implements Cancellable {
     public void setFinalKnockback(@NotNull Vector knockback) {
         Preconditions.checkArgument(knockback != null, "Knockback cannot be null");
 
-        this.knockback = knockback;
+        this.knockback = knockback.clone();
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/event/entity/EntityRemoveEvent.java b/src/main/java/org/bukkit/event/entity/EntityRemoveEvent.java
index 8ed5d1ccc44951089999db360219b556db89b4ba..2a826175fed73cb40613dbb65a2e9cdacc56a695 100644
--- a/src/main/java/org/bukkit/event/entity/EntityRemoveEvent.java
+++ b/src/main/java/org/bukkit/event/entity/EntityRemoveEvent.java
@@ -1,9 +1,7 @@
 package org.bukkit.event.entity;
 
-import com.destroystokyo.paper.event.entity.EntityRemoveFromWorldEvent;
 import org.bukkit.entity.Entity;
 import org.bukkit.event.HandlerList;
-import org.jetbrains.annotations.ApiStatus;
 import org.jetbrains.annotations.NotNull;
 
 /**
@@ -12,9 +10,11 @@ import org.jetbrains.annotations.NotNull;
  * This event should only be used for monitoring. The result
  * of modifying the entity during or after this event is unspecified.
  * This event is not called for a {@link org.bukkit.entity.Player}.
- * @deprecated use {@link EntityRemoveFromWorldEvent} instead
+ * <p>
+ * It differs from {@link com.destroystokyo.paper.event.entity.EntityRemoveFromWorldEvent} as to when it is called.
+ * Modifications to the entity, as noted above, are not defined and are expected to not be persisted in e.g., chunk
+ * unloads.
  */
-@Deprecated(forRemoval = true)
 public class EntityRemoveEvent extends EntityEvent {
 
     private static final HandlerList handlers = new HandlerList();
diff --git a/src/main/java/org/bukkit/event/entity/EntityTeleportEvent.java b/src/main/java/org/bukkit/event/entity/EntityTeleportEvent.java
index a7918049ae599a583a9188d90eb86922fd948296..bffad21c0282235a7d554b37d369e5ab41db6dc2 100644
--- a/src/main/java/org/bukkit/event/entity/EntityTeleportEvent.java
+++ b/src/main/java/org/bukkit/event/entity/EntityTeleportEvent.java
@@ -52,7 +52,7 @@ public class EntityTeleportEvent extends EntityEvent implements Cancellable {
      * @param from New location this entity moved from
      */
     public void setFrom(@NotNull Location from) {
-        this.from = from;
+        this.from = from.clone();
     }
 
     /**
@@ -71,7 +71,7 @@ public class EntityTeleportEvent extends EntityEvent implements Cancellable {
      * @param to New Location this entity moved to
      */
     public void setTo(@Nullable Location to) {
-        this.to = to;
+        this.to = to != null ? to.clone() : null;
     }
 
     @NotNull
diff --git a/src/main/java/org/bukkit/event/inventory/InventoryAction.java b/src/main/java/org/bukkit/event/inventory/InventoryAction.java
index b2bcc891196d487cf4c1962b51ec439e921f49f6..b84aaf7f377e8a3abb6cda6a96539d378a4524c4 100644
--- a/src/main/java/org/bukkit/event/inventory/InventoryAction.java
+++ b/src/main/java/org/bukkit/event/inventory/InventoryAction.java
@@ -93,5 +93,29 @@ public enum InventoryAction {
      * An unrecognized ClickType.
      */
     UNKNOWN,
+    /**
+     * The first stack of items in the clicked bundle is moved to the cursor.
+     */
+    PICKUP_FROM_BUNDLE,
+    /**
+     * All of the items on the clicked slot are moved into the bundle on the cursor.
+     */
+    PICKUP_ALL_INTO_BUNDLE,
+    /**
+     * Some of the items on the clicked slot are moved into the bundle on the cursor.
+     */
+    PICKUP_SOME_INTO_BUNDLE,
+    /**
+     * The first stack of items is moved to the clicked slot.
+     */
+    PLACE_FROM_BUNDLE,
+    /**
+     * All of the items on the cursor are moved into the bundle in the clicked slot.
+     */
+    PLACE_ALL_INTO_BUNDLE,
+    /**
+     * Some of the items on the cursor are moved into the bundle in the clicked slot.
+     */
+    PLACE_SOME_INTO_BUNDLE,
     ;
 }
diff --git a/src/main/java/org/bukkit/event/player/PlayerInteractEvent.java b/src/main/java/org/bukkit/event/player/PlayerInteractEvent.java
index 69c800d367d36c8730781b89e3530a75487d000a..759aaa9351027394d4393e8c3ef2847d82b9ff82 100644
--- a/src/main/java/org/bukkit/event/player/PlayerInteractEvent.java
+++ b/src/main/java/org/bukkit/event/player/PlayerInteractEvent.java
@@ -241,7 +241,10 @@ public class PlayerInteractEvent extends PlayerEvent implements Cancellable {
     @Nullable
     @Deprecated // Paper
     public Vector getClickedPosition() {
-        return clickedPosistion;
+        if (this.clickedPosistion == null) {
+            return null;
+        }
+        return clickedPosistion.clone();
     }
 
     // Paper start
diff --git a/src/main/java/org/bukkit/event/player/PlayerMoveEvent.java b/src/main/java/org/bukkit/event/player/PlayerMoveEvent.java
index b484abf3b06b1fb3577b43d50d64498dcd7652c9..237d65477363fd4e747f64da747e008ed6836236 100644
--- a/src/main/java/org/bukkit/event/player/PlayerMoveEvent.java
+++ b/src/main/java/org/bukkit/event/player/PlayerMoveEvent.java
@@ -70,7 +70,7 @@ public class PlayerMoveEvent extends PlayerEvent implements Cancellable {
      */
     public void setFrom(@NotNull Location from) {
         validateLocation(from);
-        this.from = from;
+        this.from = from.clone();
     }
 
     /**
@@ -90,7 +90,7 @@ public class PlayerMoveEvent extends PlayerEvent implements Cancellable {
      */
     public void setTo(@NotNull Location to) {
         validateLocation(to);
-        this.to = to;
+        this.to = to.clone();
     }
 
     // Paper start - PlayerMoveEvent improvements
diff --git a/src/main/java/org/bukkit/event/player/PlayerRespawnEvent.java b/src/main/java/org/bukkit/event/player/PlayerRespawnEvent.java
index 4d925774f75e8982a8141a28de71e568834e1433..d1dd5cf0ad75a72bd6208d21331083f8679cf81f 100644
--- a/src/main/java/org/bukkit/event/player/PlayerRespawnEvent.java
+++ b/src/main/java/org/bukkit/event/player/PlayerRespawnEvent.java
@@ -69,7 +69,7 @@ public class PlayerRespawnEvent extends PlayerEvent {
         Preconditions.checkArgument(respawnLocation != null, "Respawn location can not be null");
         Preconditions.checkArgument(respawnLocation.getWorld() != null, "Respawn world can not be null");
 
-        this.respawnLocation = respawnLocation;
+        this.respawnLocation = respawnLocation.clone();
     }
 
     /**
diff --git a/src/main/java/org/bukkit/event/player/PlayerVelocityEvent.java b/src/main/java/org/bukkit/event/player/PlayerVelocityEvent.java
index 61e098d94af9261de1755e743a49657f79427995..87b15dcabfaa4e3e2631f41087502e111e0e466b 100644
--- a/src/main/java/org/bukkit/event/player/PlayerVelocityEvent.java
+++ b/src/main/java/org/bukkit/event/player/PlayerVelocityEvent.java
@@ -45,7 +45,7 @@ public class PlayerVelocityEvent extends PlayerEvent implements Cancellable {
      * @param velocity The velocity vector that will be sent to the player
      */
     public void setVelocity(@NotNull Vector velocity) {
-        this.velocity = velocity;
+        this.velocity = velocity.clone();
     }
 
     @NotNull
diff --git a/src/main/java/org/bukkit/event/world/AsyncStructureSpawnEvent.java b/src/main/java/org/bukkit/event/world/AsyncStructureSpawnEvent.java
index 5f05b32bdf0b24650d247e7a11c87bc812a3639f..978790b97b16f6117700f9b14dcfc093e9c6449d 100644
--- a/src/main/java/org/bukkit/event/world/AsyncStructureSpawnEvent.java
+++ b/src/main/java/org/bukkit/event/world/AsyncStructureSpawnEvent.java
@@ -45,7 +45,7 @@ public class AsyncStructureSpawnEvent extends WorldEvent implements Cancellable
      */
     @NotNull
     public BoundingBox getBoundingBox() {
-        return boundingBox;
+        return boundingBox.clone();
     }
 
     /**
diff --git a/src/main/java/org/bukkit/generator/structure/Structure.java b/src/main/java/org/bukkit/generator/structure/Structure.java
index b6920f834f8f5992214734abd093af54fc01991c..228df69a66d341678be37612ca6e0cec860e4e6d 100644
--- a/src/main/java/org/bukkit/generator/structure/Structure.java
+++ b/src/main/java/org/bukkit/generator/structure/Structure.java
@@ -1,5 +1,7 @@
 package org.bukkit.generator.structure;
 
+import io.papermc.paper.registry.RegistryAccess;
+import io.papermc.paper.registry.RegistryKey;
 import org.bukkit.Keyed;
 import org.bukkit.NamespacedKey;
 import org.bukkit.Registry;
@@ -10,7 +12,7 @@ import org.jetbrains.annotations.NotNull;
  *
  * Listed structures are present in the default server. Depending on the server
  * there might be additional structures present (for example structures added by
- * data packs), which can be received via {@link Registry#STRUCTURE}.
+ * data packs), which can be received via {@link io.papermc.paper.registry.RegistryAccess#getRegistry(io.papermc.paper.registry.RegistryKey)} and {@link io.papermc.paper.registry.RegistryKey#STRUCTURE}.
  */
 public abstract class Structure implements Keyed {
 
@@ -51,7 +53,7 @@ public abstract class Structure implements Keyed {
 
     @NotNull
     private static Structure getStructure(@NotNull String name) {
-        return Registry.STRUCTURE.getOrThrow(NamespacedKey.minecraft(name));
+        return RegistryAccess.registryAccess().getRegistry(RegistryKey.STRUCTURE).getOrThrow(NamespacedKey.minecraft(name));
     }
 
     /**
diff --git a/src/main/java/org/bukkit/inventory/EntityEquipment.java b/src/main/java/org/bukkit/inventory/EntityEquipment.java
index 4264cf878c0999f1c0c2a679028becb858743495..b81e853ad0abe4534ed548b59513d2d11619f685 100644
--- a/src/main/java/org/bukkit/inventory/EntityEquipment.java
+++ b/src/main/java/org/bukkit/inventory/EntityEquipment.java
@@ -329,7 +329,7 @@ public interface EntityEquipment {
      *
      * @param items The items to set the armor as. Individual items may be null.
      */
-    void setArmorContents(@NotNull ItemStack[] items);
+    void setArmorContents(@NotNull ItemStack @NotNull [] items);
 
     /**
      * Clears the entity of all armor and held items
diff --git a/src/main/java/org/bukkit/inventory/EquipmentSlotGroup.java b/src/main/java/org/bukkit/inventory/EquipmentSlotGroup.java
index 2c4353e8fa3090d2ae38ec6f29c88185e7dde6ed..83b5128f911874819a21273d6adf13a85c718e55 100644
--- a/src/main/java/org/bukkit/inventory/EquipmentSlotGroup.java
+++ b/src/main/java/org/bukkit/inventory/EquipmentSlotGroup.java
@@ -25,7 +25,7 @@ public final class EquipmentSlotGroup implements Predicate<EquipmentSlot> {
     public static final EquipmentSlotGroup LEGS = get("legs", EquipmentSlot.LEGS);
     public static final EquipmentSlotGroup CHEST = get("chest", EquipmentSlot.CHEST);
     public static final EquipmentSlotGroup HEAD = get("head", EquipmentSlot.HEAD);
-    public static final EquipmentSlotGroup ARMOR = get("armor", (test) -> test == EquipmentSlot.FEET || test == EquipmentSlot.LEGS || test == EquipmentSlot.CHEST || test == EquipmentSlot.HEAD || test == EquipmentSlot.BODY, EquipmentSlot.CHEST);  // Paper - add missing slot type
+    public static final EquipmentSlotGroup ARMOR = get("armor", (test) -> test == EquipmentSlot.FEET || test == EquipmentSlot.LEGS || test == EquipmentSlot.CHEST || test == EquipmentSlot.HEAD || test == EquipmentSlot.BODY, EquipmentSlot.CHEST); // Paper - add missing slot type
     public static final EquipmentSlotGroup BODY = get("body", EquipmentSlot.BODY); // Paper - add missing slot group
     //
     private final String key;
diff --git a/src/main/java/org/bukkit/inventory/Inventory.java b/src/main/java/org/bukkit/inventory/Inventory.java
index 0d519813c12d98b28d62e6d01d7ec6e8c2dba3c3..dfcb16dfe0abeadcb9fed25691a36752ae22dd8f 100644
--- a/src/main/java/org/bukkit/inventory/Inventory.java
+++ b/src/main/java/org/bukkit/inventory/Inventory.java
@@ -48,11 +48,13 @@ public interface Inventory extends Iterable<ItemStack> {
      * <b>Caveats:</b>
      * <ul>
      * <li>Not all inventories respect this value.
-     * <li>Stacks larger than 127 may be clipped when the world is saved.
+     * <li>Stacks larger than 99 will throw errors when serialized.
      * <li>This value is not guaranteed to be preserved; be sure to set it
      *     before every time you want to set a slot over the max stack size.
      * <li>Stacks larger than the default max size for this type of inventory
-     *     may not display correctly in the client.
+     *     are ignored by the client, resulting in the vanilla client
+     *     always trimming it down to default maximum stack size.
+     * <li>Most operations ignore this value if it is over {@link ItemStack#getMaxStackSize()}
      * </ul>
      *
      * @param size The new maximum stack size for items in this inventory.
@@ -85,12 +87,12 @@ public interface Inventory extends Iterable<ItemStack> {
      * index of the varargs parameter. If all items are stored, it will return
      * an empty HashMap.
      * <p>
-     * If you pass in ItemStacks which exceed the maximum stack size for the
-     * Material, first they will be added to partial stacks where
-     * Material.getMaxStackSize() is not exceeded, up to
-     * Material.getMaxStackSize(). When there are no partial stacks left
-     * stacks will be split on Inventory.getMaxStackSize() allowing you to
-     * exceed the maximum stack size for that material.
+     * Items resulted from this method will not exceed the minimum
+     * of {@link ItemStack#getMaxStackSize()} and {@link #getMaxStackSize()}.
+     * <p>
+     * First, this method will try to fill all the partial stacks in the inventory.
+     * Then it will try to fill empty slots, over-stacked items being able to
+     * fill several empty slots. The rest are placed in the returned map.
      * <p>
      * It is known that in some implementations this method will also set
      * the inputted argument amount to the number of that item not placed in
diff --git a/src/main/java/org/bukkit/inventory/ItemCraftResult.java b/src/main/java/org/bukkit/inventory/ItemCraftResult.java
index ebb4d19e0a84c578ae57bd7328c7c265bb77313f..74d4785bd9fe5d7c1a780d3baa6c0a3a56c120c2 100644
--- a/src/main/java/org/bukkit/inventory/ItemCraftResult.java
+++ b/src/main/java/org/bukkit/inventory/ItemCraftResult.java
@@ -24,8 +24,7 @@ public interface ItemCraftResult {
      *
      * @return resulting matrix
      */
-    @NotNull
-    public ItemStack[] getResultingMatrix();
+    public @NotNull ItemStack @NotNull [] getResultingMatrix();
 
     /**
      * Gets the overflowed items for items that don't fit back into the crafting
diff --git a/src/main/java/org/bukkit/inventory/ItemStack.java b/src/main/java/org/bukkit/inventory/ItemStack.java
index 8c9654cd19af8b28fa276a55c5060eb389e60c1c..55457c7539c08e861263333ae40cbfe9d25814f4 100644
--- a/src/main/java/org/bukkit/inventory/ItemStack.java
+++ b/src/main/java/org/bukkit/inventory/ItemStack.java
@@ -2,9 +2,11 @@ package org.bukkit.inventory;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableMap;
+import io.papermc.paper.registry.RegistryKey;
 import java.util.LinkedHashMap;
 import java.util.Locale;
 import java.util.Map;
+import net.kyori.adventure.text.Component;
 import org.bukkit.Bukkit;
 import org.bukkit.Material;
 import org.bukkit.NamespacedKey;
@@ -542,7 +544,7 @@ public class ItemStack implements Cloneable, ConfigurationSerializable, Translat
                     stringKey = Bukkit.getUnsafe().get(Enchantment.class, stringKey);
                     NamespacedKey key = NamespacedKey.fromString(stringKey.toLowerCase(Locale.ROOT));
 
-                    Enchantment enchantment = Bukkit.getUnsafe().get(Registry.ENCHANTMENT, key);
+                    Enchantment enchantment = Bukkit.getUnsafe().get(RegistryKey.ENCHANTMENT, key);
 
                     if ((enchantment != null) && (entry.getValue() instanceof Integer)) {
                         result.addUnsafeEnchantment(enchantment, (Integer) entry.getValue());
@@ -710,6 +712,17 @@ public class ItemStack implements Cloneable, ConfigurationSerializable, Translat
         return Bukkit.getServer().getItemFactory().displayName(this);
     }
 
+    /**
+     * Gets the effective name of this item stack shown to player in inventory.
+     * It takes into account the display name (with italics) from the item meta,
+     * the potion effect, translatable name, rarity etc.
+     *
+     * @return the effective name of this item stack
+     */
+    public @NotNull Component effectiveName() {
+        return this.craftDelegate.effectiveName();
+    }
+
     /**
      * Minecraft updates are converting simple item stacks into more complex NBT oriented Item Stacks.
      *
@@ -732,8 +745,7 @@ public class ItemStack implements Cloneable, ConfigurationSerializable, Translat
      * @param bytes bytes representing an item in NBT
      * @return ItemStack migrated to this version of Minecraft if needed.
      */
-    @NotNull
-    public static ItemStack deserializeBytes(@NotNull byte[] bytes) {
+    public static @NotNull ItemStack deserializeBytes(final byte @NotNull [] bytes) {
         return org.bukkit.Bukkit.getUnsafe().deserializeItem(bytes);
     }
 
@@ -742,8 +754,7 @@ public class ItemStack implements Cloneable, ConfigurationSerializable, Translat
      * use the built in data converter instead of bukkits dangerous serialization system.
      * @return bytes representing this item in NBT.
      */
-    @NotNull
-    public byte[] serializeAsBytes() {
+    public byte @NotNull [] serializeAsBytes() {
         return org.bukkit.Bukkit.getUnsafe().serializeItem(this);
     }
 
diff --git a/src/main/java/org/bukkit/inventory/MenuType.java b/src/main/java/org/bukkit/inventory/MenuType.java
index 529143c9007d6da4f671576f9934933f2e5d6f23..2442361ce782531a44f55e3e1b5ad7904595bd88 100644
--- a/src/main/java/org/bukkit/inventory/MenuType.java
+++ b/src/main/java/org/bukkit/inventory/MenuType.java
@@ -14,6 +14,9 @@ import org.bukkit.inventory.view.LecternView;
 import org.bukkit.inventory.view.LoomView;
 import org.bukkit.inventory.view.MerchantView;
 import org.bukkit.inventory.view.StonecutterView;
+import org.bukkit.inventory.view.builder.InventoryViewBuilder;
+import org.bukkit.inventory.view.builder.LocationInventoryViewBuilder;
+import org.bukkit.inventory.view.builder.MerchantInventoryViewBuilder;
 import org.jetbrains.annotations.ApiStatus;
 import org.jetbrains.annotations.NotNull;
 
@@ -27,104 +30,104 @@ public interface MenuType extends Keyed, io.papermc.paper.world.flag.FeatureDepe
     /**
      * A MenuType which represents a chest with 1 row.
      */
-    MenuType.Typed<InventoryView> GENERIC_9X1 = get("generic_9x1");
+    MenuType.Typed<InventoryView, InventoryViewBuilder<InventoryView>> GENERIC_9X1 = get("generic_9x1");
     /**
      * A MenuType which represents a chest with 2 rows.
      */
-    MenuType.Typed<InventoryView> GENERIC_9X2 = get("generic_9x2");
+    MenuType.Typed<InventoryView, InventoryViewBuilder<InventoryView>> GENERIC_9X2 = get("generic_9x2");
     /**
      * A MenuType which represents a chest with 3 rows.
      */
-    MenuType.Typed<InventoryView> GENERIC_9X3 = get("generic_9x3");
+    MenuType.Typed<InventoryView, LocationInventoryViewBuilder<InventoryView>> GENERIC_9X3 = get("generic_9x3");
     /**
      * A MenuType which represents a chest with 4 rows.
      */
-    MenuType.Typed<InventoryView> GENERIC_9X4 = get("generic_9x4");
+    MenuType.Typed<InventoryView, InventoryViewBuilder<InventoryView>> GENERIC_9X4 = get("generic_9x4");
     /**
      * A MenuType which represents a chest with 5 rows.
      */
-    MenuType.Typed<InventoryView> GENERIC_9X5 = get("generic_9x5");
+    MenuType.Typed<InventoryView, InventoryViewBuilder<InventoryView>> GENERIC_9X5 = get("generic_9x5");
     /**
      * A MenuType which represents a chest with 6 rows.
      */
-    MenuType.Typed<InventoryView> GENERIC_9X6 = get("generic_9x6");
+    MenuType.Typed<InventoryView, LocationInventoryViewBuilder<InventoryView>> GENERIC_9X6 = get("generic_9x6");
     /**
      * A MenuType which represents a dispenser/dropper like menu with 3 columns
      * and 3 rows.
      */
-    MenuType.Typed<InventoryView> GENERIC_3X3 = get("generic_3x3");
+    MenuType.Typed<InventoryView, LocationInventoryViewBuilder<InventoryView>> GENERIC_3X3 = get("generic_3x3");
     /**
      * A MenuType which represents a crafter
      */
-    MenuType.Typed<CrafterView> CRAFTER_3X3 = get("crafter_3x3");
+    MenuType.Typed<CrafterView, LocationInventoryViewBuilder<CrafterView>> CRAFTER_3X3 = get("crafter_3x3");
     /**
      * A MenuType which represents an anvil.
      */
-    MenuType.Typed<AnvilView> ANVIL = get("anvil");
+    MenuType.Typed<AnvilView, LocationInventoryViewBuilder<AnvilView>> ANVIL = get("anvil");
     /**
      * A MenuType which represents a beacon.
      */
-    MenuType.Typed<BeaconView> BEACON = get("beacon");
+    MenuType.Typed<BeaconView, LocationInventoryViewBuilder<BeaconView>> BEACON = get("beacon");
     /**
      * A MenuType which represents a blast furnace.
      */
-    MenuType.Typed<FurnaceView> BLAST_FURNACE = get("blast_furnace");
+    MenuType.Typed<FurnaceView, LocationInventoryViewBuilder<FurnaceView>> BLAST_FURNACE = get("blast_furnace");
     /**
      * A MenuType which represents a brewing stand.
      */
-    MenuType.Typed<BrewingStandView> BREWING_STAND = get("brewing_stand");
+    MenuType.Typed<BrewingStandView, LocationInventoryViewBuilder<BrewingStandView>> BREWING_STAND = get("brewing_stand");
     /**
      * A MenuType which represents a crafting table.
      */
-    MenuType.Typed<InventoryView> CRAFTING = get("crafting");
+    MenuType.Typed<InventoryView, LocationInventoryViewBuilder<InventoryView>> CRAFTING = get("crafting");
     /**
      * A MenuType which represents an enchantment table.
      */
-    MenuType.Typed<EnchantmentView> ENCHANTMENT = get("enchantment");
+    MenuType.Typed<EnchantmentView, LocationInventoryViewBuilder<EnchantmentView>> ENCHANTMENT = get("enchantment");
     /**
      * A MenuType which represents a furnace.
      */
-    MenuType.Typed<FurnaceView> FURNACE = get("furnace");
+    MenuType.Typed<FurnaceView, LocationInventoryViewBuilder<FurnaceView>> FURNACE = get("furnace");
     /**
      * A MenuType which represents a grindstone.
      */
-    MenuType.Typed<InventoryView> GRINDSTONE = get("grindstone");
+    MenuType.Typed<InventoryView, LocationInventoryViewBuilder<InventoryView>> GRINDSTONE = get("grindstone");
     /**
      * A MenuType which represents a hopper.
      */
-    MenuType.Typed<InventoryView> HOPPER = get("hopper");
+    MenuType.Typed<InventoryView, LocationInventoryViewBuilder<InventoryView>> HOPPER = get("hopper");
     /**
      * A MenuType which represents a lectern, a book like view.
      */
-    MenuType.Typed<LecternView> LECTERN = get("lectern");
+    MenuType.Typed<LecternView, LocationInventoryViewBuilder<LecternView>> LECTERN = get("lectern");
     /**
      * A MenuType which represents a loom.
      */
-    MenuType.Typed<LoomView> LOOM = get("loom");
+    MenuType.Typed<LoomView, LocationInventoryViewBuilder<LoomView>> LOOM = get("loom");
     /**
      * A MenuType which represents a merchant.
      */
-    MenuType.Typed<MerchantView> MERCHANT = get("merchant");
+    MenuType.Typed<MerchantView, MerchantInventoryViewBuilder<MerchantView>> MERCHANT = get("merchant");
     /**
      * A MenuType which represents a shulker box.
      */
-    MenuType.Typed<InventoryView> SHULKER_BOX = get("shulker_box");
+    MenuType.Typed<InventoryView, LocationInventoryViewBuilder<InventoryView>> SHULKER_BOX = get("shulker_box");
     /**
      * A MenuType which represents a stonecutter.
      */
-    MenuType.Typed<InventoryView> SMITHING = get("smithing");
+    MenuType.Typed<InventoryView, LocationInventoryViewBuilder<InventoryView>> SMITHING = get("smithing");
     /**
      * A MenuType which represents a smoker.
      */
-    MenuType.Typed<FurnaceView> SMOKER = get("smoker");
+    MenuType.Typed<FurnaceView, LocationInventoryViewBuilder<FurnaceView>> SMOKER = get("smoker");
     /**
      * A MenuType which represents a cartography table.
      */
-    MenuType.Typed<InventoryView> CARTOGRAPHY_TABLE = get("cartography_table");
+    MenuType.Typed<InventoryView, LocationInventoryViewBuilder<InventoryView>> CARTOGRAPHY_TABLE = get("cartography_table");
     /**
      * A MenuType which represents a stonecutter.
      */
-    MenuType.Typed<StonecutterView> STONECUTTER = get("stonecutter");
+    MenuType.Typed<StonecutterView, LocationInventoryViewBuilder<StonecutterView>> STONECUTTER = get("stonecutter");
 
     /**
      * Typed represents a subtype of {@link MenuType}s that have a known
@@ -133,7 +136,7 @@ public interface MenuType extends Keyed, io.papermc.paper.world.flag.FeatureDepe
      * @param <V> the generic type of {@link InventoryView} that represents the
      * view type.
      */
-    interface Typed<V extends InventoryView> extends MenuType {
+    interface Typed<V extends InventoryView, B extends InventoryViewBuilder<V>> extends MenuType {
 
         /**
          * Creates a view of the specified menu type.
@@ -166,6 +169,9 @@ public interface MenuType extends Keyed, io.papermc.paper.world.flag.FeatureDepe
         @NotNull
         V create(@NotNull HumanEntity player, @NotNull net.kyori.adventure.text.Component title);
         // Paper end - adventure
+
+        @NotNull
+        B builder();
     }
 
     // Paper start - adventure
@@ -191,7 +197,7 @@ public interface MenuType extends Keyed, io.papermc.paper.world.flag.FeatureDepe
      * @return the typed MenuType.
      */
     @NotNull
-    MenuType.Typed<InventoryView> typed();
+    MenuType.Typed<InventoryView, InventoryViewBuilder<InventoryView>> typed();
 
     /**
      * Yields this MenuType as a typed version of itself with a specific
@@ -201,12 +207,14 @@ public interface MenuType extends Keyed, io.papermc.paper.world.flag.FeatureDepe
      * {@link InventoryView} with.
      * @param <V> the generic type of the InventoryView to get this MenuType
      * with
+     * @param <B> the generic type of the InventoryViewBuilder to get this
+     * MenuType with
      * @return the typed MenuType
      * @throws IllegalArgumentException if the provided viewClass cannot be
      * typed to this MenuType
      */
     @NotNull
-    <V extends InventoryView> MenuType.Typed<V> typed(@NotNull final Class<V> viewClass) throws IllegalArgumentException;
+    <V extends InventoryView, B extends InventoryViewBuilder<V>> MenuType.Typed<V, B> typed(@NotNull final Class<V> viewClass) throws IllegalArgumentException;
 
     /**
      * Gets the {@link InventoryView} class of this MenuType.
diff --git a/src/main/java/org/bukkit/inventory/PlayerInventory.java b/src/main/java/org/bukkit/inventory/PlayerInventory.java
index 58fcfaf2e3645293e920d42c17ace3eaceae086d..c31f1cebfda4748975c0e0027a83666f3ee13835 100644
--- a/src/main/java/org/bukkit/inventory/PlayerInventory.java
+++ b/src/main/java/org/bukkit/inventory/PlayerInventory.java
@@ -118,7 +118,7 @@ public interface PlayerInventory extends Inventory {
      *
      * @param items The ItemStacks to use as armour
      */
-    public void setArmorContents(@Nullable ItemStack[] items);
+    public void setArmorContents(@Nullable ItemStack @NotNull [] items);
 
     /**
      * Put the given ItemStacks into the extra slots
@@ -127,7 +127,7 @@ public interface PlayerInventory extends Inventory {
      *
      * @param items The ItemStacks to use as extra
      */
-    public void setExtraContents(@Nullable ItemStack[] items);
+    public void setExtraContents(@Nullable ItemStack @NotNull [] items);
 
     /**
      * Put the given ItemStack into the helmet slot. This does not check if
diff --git a/src/main/java/org/bukkit/inventory/ShapedRecipe.java b/src/main/java/org/bukkit/inventory/ShapedRecipe.java
index f0268829c79701bbe6ecb097885dd371aff215ca..462a6d1da59b8695306071d38e2fb766d5e96916 100644
--- a/src/main/java/org/bukkit/inventory/ShapedRecipe.java
+++ b/src/main/java/org/bukkit/inventory/ShapedRecipe.java
@@ -234,8 +234,7 @@ public class ShapedRecipe extends CraftingRecipe {
      * @return The recipe's shape.
      * @throws NullPointerException when not set yet
      */
-    @NotNull
-    public String[] getShape() {
+    public @NotNull String @NotNull [] getShape() {
         return rows.clone();
     }
 }
diff --git a/src/main/java/org/bukkit/inventory/meta/trim/TrimMaterial.java b/src/main/java/org/bukkit/inventory/meta/trim/TrimMaterial.java
index 7e8a4b4ec625072cb4aff1f9e113d9d0c162dc8c..0910dd287dd33cb36d5c6cf9daf625d305a48dc3 100644
--- a/src/main/java/org/bukkit/inventory/meta/trim/TrimMaterial.java
+++ b/src/main/java/org/bukkit/inventory/meta/trim/TrimMaterial.java
@@ -1,5 +1,7 @@
 package org.bukkit.inventory.meta.trim;
 
+import io.papermc.paper.registry.RegistryAccess;
+import io.papermc.paper.registry.RegistryKey;
 import org.bukkit.Keyed;
 import org.bukkit.Material;
 import org.bukkit.NamespacedKey;
@@ -59,7 +61,7 @@ public interface TrimMaterial extends Keyed, Translatable {
 
     @NotNull
     private static TrimMaterial getTrimMaterial(@NotNull String key) {
-        return Registry.TRIM_MATERIAL.getOrThrow(NamespacedKey.minecraft(key));
+        return RegistryAccess.registryAccess().getRegistry(RegistryKey.TRIM_MATERIAL).getOrThrow(NamespacedKey.minecraft(key));
     }
 
     // Paper start - adventure
diff --git a/src/main/java/org/bukkit/inventory/meta/trim/TrimPattern.java b/src/main/java/org/bukkit/inventory/meta/trim/TrimPattern.java
index b2fa0d565b2492aa812b0ac036ecd74889f67f76..9360e27b0b1d464addd312e9442159dfafa83fe2 100644
--- a/src/main/java/org/bukkit/inventory/meta/trim/TrimPattern.java
+++ b/src/main/java/org/bukkit/inventory/meta/trim/TrimPattern.java
@@ -1,5 +1,7 @@
 package org.bukkit.inventory.meta.trim;
 
+import io.papermc.paper.registry.RegistryAccess;
+import io.papermc.paper.registry.RegistryKey;
 import org.bukkit.Keyed;
 import org.bukkit.Material;
 import org.bukkit.NamespacedKey;
@@ -87,7 +89,7 @@ public interface TrimPattern extends Keyed, Translatable {
 
     @NotNull
     private static TrimPattern getTrimPattern(@NotNull String key) {
-        return Registry.TRIM_PATTERN.getOrThrow(NamespacedKey.minecraft(key));
+        return RegistryAccess.registryAccess().getRegistry(RegistryKey.TRIM_PATTERN).getOrThrow(NamespacedKey.minecraft(key));
     }
 
     // Paper start - adventure
diff --git a/src/main/java/org/bukkit/inventory/view/EnchantmentView.java b/src/main/java/org/bukkit/inventory/view/EnchantmentView.java
index 73740c2f570dd149bf3f00766cdfa9a25098de1a..b82b70c9f0e98012b3ffd93e4fe0b5d59b8832c2 100644
--- a/src/main/java/org/bukkit/inventory/view/EnchantmentView.java
+++ b/src/main/java/org/bukkit/inventory/view/EnchantmentView.java
@@ -4,6 +4,7 @@ import org.bukkit.enchantments.EnchantmentOffer;
 import org.bukkit.inventory.EnchantingInventory;
 import org.bukkit.inventory.InventoryView;
 import org.jetbrains.annotations.NotNull;
+import org.jspecify.annotations.Nullable;
 
 /**
  * An instance of {@link InventoryView} which provides extra methods related to
@@ -36,8 +37,7 @@ public interface EnchantmentView extends InventoryView {
      *
      * @return The enchantment offers that are provided
      */
-    @NotNull
-    EnchantmentOffer[] getOffers();
+    @Nullable EnchantmentOffer @NotNull [] getOffers();
 
     /**
      * Sets the offers to provide to the player.
@@ -45,5 +45,5 @@ public interface EnchantmentView extends InventoryView {
      * @param offers The offers to provide
      * @throws IllegalArgumentException if the array length isn't 3
      */
-    void setOffers(@NotNull EnchantmentOffer[] offers) throws IllegalArgumentException;
+    void setOffers(@Nullable EnchantmentOffer @NotNull [] offers) throws IllegalArgumentException;
 }
diff --git a/src/main/java/org/bukkit/inventory/view/builder/InventoryViewBuilder.java b/src/main/java/org/bukkit/inventory/view/builder/InventoryViewBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..9f07522283b3c46042c5341cb1084aaa50d90e17
--- /dev/null
+++ b/src/main/java/org/bukkit/inventory/view/builder/InventoryViewBuilder.java
@@ -0,0 +1,38 @@
+package org.bukkit.inventory.view.builder;
+
+import net.kyori.adventure.text.Component;
+import org.bukkit.entity.HumanEntity;
+import org.bukkit.inventory.InventoryView;
+import org.jetbrains.annotations.ApiStatus;
+
+/**
+ * Generic Builder for InventoryView's with no special attributes or parameters
+ *
+ * @param <V> the type of InventoryView created from this builder
+ */
+@ApiStatus.Experimental
+public interface InventoryViewBuilder<V extends InventoryView> {
+
+    /**
+     * Makes a copy of this builder
+     *
+     * @return a copy of this builder
+     */
+    InventoryViewBuilder<V> copy();
+
+    /**
+     * Sets the title of the builder
+     *
+     * @param title the title
+     * @return this builder
+     */
+    InventoryViewBuilder<V> title(final Component title);
+
+    /**
+     * Builds this builder into a InventoryView
+     *
+     * @param player the player to assign to the view
+     * @return the created InventoryView
+     */
+    V build(final HumanEntity player);
+}
diff --git a/src/main/java/org/bukkit/inventory/view/builder/LocationInventoryViewBuilder.java b/src/main/java/org/bukkit/inventory/view/builder/LocationInventoryViewBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..9666aa356905a545433e2543357cca65fdef75a8
--- /dev/null
+++ b/src/main/java/org/bukkit/inventory/view/builder/LocationInventoryViewBuilder.java
@@ -0,0 +1,55 @@
+package org.bukkit.inventory.view.builder;
+
+import net.kyori.adventure.text.Component;
+import org.bukkit.Location;
+import org.bukkit.inventory.InventoryView;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An InventoryViewBuilder that can be bound by location within the world
+ *
+ * @param <V> the type of InventoryView created from this builder
+ */
+@ApiStatus.Experimental
+public interface LocationInventoryViewBuilder<V extends InventoryView> extends InventoryViewBuilder<V> {
+
+    @Override
+    LocationInventoryViewBuilder<V> copy();
+
+    @Override
+    LocationInventoryViewBuilder<V> title(final @NotNull Component title);
+
+    /**
+     * Determines whether or not the server should check if the player can reach
+     * the location.
+     * <p>
+     * Not providing a location but setting checkReachable to true will
+     * automatically close the view when opened.
+     * <p>
+     * If checkReachable is set to false and a location is set on the builder if
+     * the target block exists and this builder is the correct menu for that
+     * block, e.g. MenuType.GENERIC_9X3 builder and target block set to chest,
+     * if that block is destroyed the view would persist.
+     *
+     * @param checkReachable whether or not to check if the view is "reachable"
+     * @return this builder
+     */
+    LocationInventoryViewBuilder<V> checkReachable(final boolean checkReachable);
+
+    /**
+     * Binds a location to this builder.
+     * <p>
+     * By binding a location in an unloaded chunk to this builder it is likely
+     * that the given chunk the location is will load. That means that when,
+     * building this view it may come with the costs associated with chunk
+     * loading.
+     * <p>
+     * Providing a location of a tile entity with a non matching menu comes with
+     * extra costs associated with ensuring that the correct view is created.
+     *
+     * @param location the location to bind to this view
+     * @return this builder
+     */
+    LocationInventoryViewBuilder<V> location(final Location location);
+}
diff --git a/src/main/java/org/bukkit/inventory/view/builder/MerchantInventoryViewBuilder.java b/src/main/java/org/bukkit/inventory/view/builder/MerchantInventoryViewBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..76aecb54a90c05db1f1d9a631868726ce66dec76
--- /dev/null
+++ b/src/main/java/org/bukkit/inventory/view/builder/MerchantInventoryViewBuilder.java
@@ -0,0 +1,44 @@
+package org.bukkit.inventory.view.builder;
+
+import net.kyori.adventure.text.Component;
+import org.bukkit.Server;
+import org.bukkit.inventory.InventoryView;
+import org.bukkit.inventory.Merchant;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An InventoryViewBuilder for creating merchant views
+ *
+ * @param <V> the type of InventoryView created by this builder
+ */
+@ApiStatus.Experimental
+public interface MerchantInventoryViewBuilder<V extends InventoryView> extends InventoryViewBuilder<V> {
+
+    @Override
+    MerchantInventoryViewBuilder<V> copy();
+
+    @Override
+    MerchantInventoryViewBuilder<V> title(final @NotNull Component title);
+
+    /**
+     * Adds a merchant to this builder
+     *
+     * @param merchant the merchant
+     * @return this builder
+     */
+    MerchantInventoryViewBuilder<V> merchant(final Merchant merchant);
+
+    /**
+     * Determines whether or not the server should check if the player can reach
+     * the location.
+     * <p>
+     * Given checkReachable is provided and a virtual merchant is provided to
+     * the builder from {@link Server#createMerchant(net.kyori.adventure.text.Component)} this method will
+     * have no effect on the actual menu status.
+     *
+     * @param checkReachable whether or not to check if the view is "reachable"
+     * @return this builder
+     */
+    MerchantInventoryViewBuilder<V> checkReachable(final boolean checkReachable);
+}
diff --git a/src/main/java/org/bukkit/inventory/view/builder/package-info.java b/src/main/java/org/bukkit/inventory/view/builder/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..b1e4203daeac3c4be9eee722fd0c284fbdfad493
--- /dev/null
+++ b/src/main/java/org/bukkit/inventory/view/builder/package-info.java
@@ -0,0 +1,9 @@
+/**
+ * A Package that contains builders for building InventoryViews.
+ */
+@NullMarked
+@ApiStatus.Experimental
+package org.bukkit.inventory.view.builder;
+
+import org.jetbrains.annotations.ApiStatus;
+import org.jspecify.annotations.NullMarked;
diff --git a/src/main/java/org/bukkit/loot/LootContext.java b/src/main/java/org/bukkit/loot/LootContext.java
index 4a8b2538a83c8446ea7bf14bc157e975cd6bdd71..470f712e8dda61dadf6eee02751e84ec678b293e 100644
--- a/src/main/java/org/bukkit/loot/LootContext.java
+++ b/src/main/java/org/bukkit/loot/LootContext.java
@@ -24,7 +24,7 @@ public final class LootContext {
     private LootContext(@NotNull Location location, float luck, int lootingModifier, @Nullable Entity lootedEntity, @Nullable HumanEntity killer) {
         Preconditions.checkArgument(location != null, "LootContext location cannot be null");
         Preconditions.checkArgument(location.getWorld() != null, "LootContext World cannot be null");
-        this.location = location;
+        this.location = location.clone();
         this.luck = luck;
         this.lootingModifier = lootingModifier;
         this.lootedEntity = lootedEntity;
@@ -38,7 +38,7 @@ public final class LootContext {
      */
     @NotNull
     public Location getLocation() {
-        return location;
+        return location.clone();
     }
 
     /**
@@ -110,7 +110,7 @@ public final class LootContext {
          * @param location the location the LootContext should use
          */
         public Builder(@NotNull Location location) {
-            this.location = location;
+            this.location = location.clone();
         }
 
         /**
diff --git a/src/main/java/org/bukkit/loot/Lootable.java b/src/main/java/org/bukkit/loot/Lootable.java
index 649dd959035843604525a637dba639a4fbd34f97..4fe5696095e52305e11a50c901d887bb33d66b75 100644
--- a/src/main/java/org/bukkit/loot/Lootable.java
+++ b/src/main/java/org/bukkit/loot/Lootable.java
@@ -16,7 +16,7 @@ public interface Lootable {
     /**
      * Set the loot table for a container or entity.
      * <br>
-     * To remove a loot table use null.
+     * If the provided loot table is null, the loot table will be reset to its default behavior.
      *
      * @param table the Loot Table this {@link org.bukkit.block.Container} or
      * {@link org.bukkit.entity.Mob} will have.
@@ -38,6 +38,8 @@ public interface Lootable {
     // Paper start
     /**
      * Set the loot table and seed for a container or entity at the same time.
+     * <br>
+     * If the provided loot table is null, the loot table will be reset to its default behavior.
      *
      * @param table the Loot Table this {@link org.bukkit.block.Container} or {@link org.bukkit.entity.Mob} will have.
      * @param seed the seed to used to generate loot. Default is 0.
@@ -53,7 +55,8 @@ public interface Lootable {
     }
 
     /**
-     * Clears the associated Loot Table to this object
+     * Clears the associated Loot Table to this object, essentially resetting it to default
+     * @see #setLootTable(LootTable)
      */
     default void clearLootTable() {
         this.setLootTable(null);
diff --git a/src/main/java/org/bukkit/map/MapFont.java b/src/main/java/org/bukkit/map/MapFont.java
index a45ce8198eafc57fd62c3ae86f68837cc90fd9e0..0f17a1750d536108ec3fe06411eaef1ecfcb037a 100644
--- a/src/main/java/org/bukkit/map/MapFont.java
+++ b/src/main/java/org/bukkit/map/MapFont.java
@@ -112,7 +112,7 @@ public class MapFont {
         private final int height;
         private final boolean[] data;
 
-        public CharacterSprite(int width, int height, @NotNull boolean[] data) {
+        public CharacterSprite(int width, int height, boolean @NotNull [] data) {
             this.width = width;
             this.height = height;
             this.data = data;
diff --git a/src/main/java/org/bukkit/plugin/EventExecutor.java b/src/main/java/org/bukkit/plugin/EventExecutor.java
index 60e086be70529e0804280b24a2a3e7ae72d8d363..187a127c49faae9edffdc314c70791e107fc76ab 100644
--- a/src/main/java/org/bukkit/plugin/EventExecutor.java
+++ b/src/main/java/org/bukkit/plugin/EventExecutor.java
@@ -1,24 +1,15 @@
 package org.bukkit.plugin;
 
+import com.google.common.base.Preconditions;
+import io.papermc.paper.event.executor.EventExecutorFactory;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
 import org.bukkit.event.Event;
 import org.bukkit.event.EventException;
 import org.bukkit.event.Listener;
+import org.bukkit.plugin.java.JavaPlugin;
 import org.jetbrains.annotations.NotNull;
 
-// Paper start
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import java.util.function.Function;
-
-import com.destroystokyo.paper.event.executor.MethodHandleEventExecutor;
-import com.destroystokyo.paper.event.executor.StaticMethodHandleEventExecutor;
-import com.destroystokyo.paper.event.executor.asm.ASMEventExecutorGenerator;
-import com.destroystokyo.paper.event.executor.asm.ClassDefiner;
-import com.google.common.base.Preconditions;
-// Paper end
-
 /**
  * Interface which defines the class for event call backs to plugins
  */
@@ -26,69 +17,25 @@ public interface EventExecutor {
     public void execute(@NotNull Listener listener, @NotNull Event event) throws EventException;
 
     // Paper start
-    ConcurrentMap<Method, Class<? extends EventExecutor>> eventExecutorMap = new ConcurrentHashMap<Method, Class<? extends EventExecutor>>() {
-        @NotNull
-        @Override
-        public Class<? extends EventExecutor> computeIfAbsent(@NotNull Method key, @NotNull Function<? super Method, ? extends Class<? extends EventExecutor>> mappingFunction) {
-            Class<? extends EventExecutor> executorClass = get(key);
-            if (executorClass != null)
-                return executorClass;
-
-            //noinspection SynchronizationOnLocalVariableOrMethodParameter
-            synchronized (key) {
-                executorClass = get(key);
-                if (executorClass != null)
-                    return executorClass;
-
-                return super.computeIfAbsent(key, mappingFunction);
-            }
-        }
-    };
-
     @NotNull
-    public static EventExecutor create(@NotNull Method m, @NotNull Class<? extends Event> eventClass) {
+    static EventExecutor create(@NotNull Method m, @NotNull Class<? extends Event> eventClass) {
         Preconditions.checkNotNull(m, "Null method");
         Preconditions.checkArgument(m.getParameterCount() != 0, "Incorrect number of arguments %s", m.getParameterCount());
         Preconditions.checkArgument(m.getParameterTypes()[0] == eventClass, "First parameter %s doesn't match event class %s", m.getParameterTypes()[0], eventClass);
-        ClassDefiner definer = ClassDefiner.getInstance();
         if (m.getReturnType() != Void.TYPE) {
-            final org.bukkit.plugin.java.JavaPlugin plugin = org.bukkit.plugin.java.JavaPlugin.getProvidingPlugin(m.getDeclaringClass());
+            final JavaPlugin plugin = JavaPlugin.getProvidingPlugin(m.getDeclaringClass());
             org.bukkit.Bukkit.getLogger().warning("@EventHandler method " + m.getDeclaringClass().getName() + (Modifier.isStatic(m.getModifiers()) ? '.' : '#') + m.getName()
                 + " returns non-void type " + m.getReturnType().getName() + ". This is unsupported behavior and will no longer work in a future version of Paper."
                 + " This should be reported to the developers of " + plugin.getPluginMeta().getDisplayName() + " (" + String.join(",", plugin.getPluginMeta().getAuthors()) + ')');
         }
-        if (Modifier.isStatic(m.getModifiers())) {
-            return new StaticMethodHandleEventExecutor(eventClass, m);
-        } else if (definer.isBypassAccessChecks() || Modifier.isPublic(m.getDeclaringClass().getModifiers()) && Modifier.isPublic(m.getModifiers())) {
-            // get the existing generated EventExecutor class for the Method or generate one
-            Class<? extends EventExecutor> executorClass = eventExecutorMap.computeIfAbsent(m, (__) -> {
-                String name = ASMEventExecutorGenerator.generateName();
-                byte[] classData = ASMEventExecutorGenerator.generateEventExecutor(m, name);
-                return definer.defineClass(m.getDeclaringClass().getClassLoader(), name, classData).asSubclass(EventExecutor.class);
-            });
-
-            try {
-                EventExecutor asmExecutor = executorClass.newInstance();
-                // Define a wrapper to conform to bukkit stupidity (passing in events that don't match and wrapper exception)
-                return new EventExecutor() {
-                    @Override
-                    public void execute(@NotNull Listener listener, @NotNull Event event) throws EventException {
-                        if (!eventClass.isInstance(event)) return;
-                        asmExecutor.execute(listener, event);
-                    }
-
-                    @Override
-                    @NotNull
-                    public String toString() {
-                        return "ASMEventExecutor['" + m + "']";
-                    }
-                };
-            } catch (InstantiationException | IllegalAccessException e) {
-                throw new AssertionError("Unable to initialize generated event executor", e);
-            }
-        } else {
-            return new MethodHandleEventExecutor(eventClass, m);
+        if (!m.trySetAccessible()) {
+            final JavaPlugin plugin = JavaPlugin.getProvidingPlugin(m.getDeclaringClass());
+            throw new AssertionError(
+                "@EventHandler method " + m.getDeclaringClass().getName() + (Modifier.isStatic(m.getModifiers()) ? '.' : '#') + m.getName() + " is not accessible."
+                    + " This should be reported to the developers of " + plugin.getDescription().getName() + " (" + String.join(",", plugin.getDescription().getAuthors()) + ')'
+            );
         }
+        return EventExecutorFactory.create(m, eventClass);
     }
     // Paper end
 }
diff --git a/src/main/java/org/bukkit/plugin/java/JavaPlugin.java b/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
index e0203f199700c397961a0667a79792497da7f796..a04100646040c0342f219e489a0a6b8c46f219e5 100644
--- a/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
+++ b/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
@@ -26,7 +26,6 @@ import org.bukkit.generator.ChunkGenerator;
 import org.bukkit.plugin.PluginBase;
 import org.bukkit.plugin.PluginDescriptionFile;
 import org.bukkit.plugin.PluginLoader;
-import org.bukkit.plugin.PluginLogger;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
@@ -41,30 +40,27 @@ public abstract class JavaPlugin extends PluginBase {
     private Server server = null;
     private File file = null;
     private PluginDescriptionFile description = null;
-    private io.papermc.paper.plugin.configuration.PluginMeta pluginMeta = null; // Paper
+    private io.papermc.paper.plugin.configuration.PluginMeta pluginMeta = null;
     private File dataFolder = null;
     private ClassLoader classLoader = null;
     private boolean naggable = true;
     private FileConfiguration newConfig = null;
     private File configFile = null;
-    private Logger logger = null; // Paper - PluginLogger -> Logger
-    // Paper start - lifecycle events
+    private Logger logger = null;
     @SuppressWarnings("deprecation")
     private final io.papermc.paper.plugin.lifecycle.event.LifecycleEventManager<org.bukkit.plugin.Plugin> lifecycleEventManager = org.bukkit.Bukkit.getUnsafe().createPluginLifecycleEventManager(this, () -> this.allowsLifecycleRegistration);
     private boolean allowsLifecycleRegistration = true;
-    // Paper end
+    private boolean isBeingEnabled = false;
 
     public JavaPlugin() {
-        // Paper start
         if (this.getClass().getClassLoader() instanceof io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader configuredPluginClassLoader) {
             configuredPluginClassLoader.init(this);
         } else {
             throw new IllegalStateException("JavaPlugin requires to be created by a valid classloader.");
         }
-        // Paper end
     }
 
-    @Deprecated(forRemoval = true) // Paper
+    @Deprecated(forRemoval = true)
     protected JavaPlugin(@NotNull final JavaPluginLoader loader, @NotNull final PluginDescriptionFile description, @NotNull final File dataFolder, @NotNull final File file) {
         final ClassLoader classLoader = this.getClass().getClassLoader();
         if (classLoader instanceof PluginClassLoader) {
@@ -94,7 +90,7 @@ public abstract class JavaPlugin extends PluginBase {
      */
     @NotNull
     @Override
-    @Deprecated(forRemoval = true) // Paper
+    @Deprecated(forRemoval = true)
     public final PluginLoader getPluginLoader() {
         return loader;
     }
@@ -111,8 +107,7 @@ public abstract class JavaPlugin extends PluginBase {
     }
 
     /**
-     * Returns a value indicating whether or not this plugin is currently
-     * enabled
+     * Returns a value indicating whether this plugin is currently enabled
      *
      * @return true if this plugin is enabled, otherwise false
      */
@@ -278,22 +273,25 @@ public abstract class JavaPlugin extends PluginBase {
      *
      * @param enabled true if enabled, otherwise false
      */
-    @org.jetbrains.annotations.ApiStatus.Internal // Paper
-    public final void setEnabled(final boolean enabled) { // Paper
+    @org.jetbrains.annotations.ApiStatus.Internal
+    public final void setEnabled(final boolean enabled) {
         if (isEnabled != enabled) {
             isEnabled = enabled;
 
             if (isEnabled) {
-                try { // Paper - lifecycle events
-                onEnable();
-                } finally { this.allowsLifecycleRegistration = false; } // Paper - lifecycle events
+                this.isBeingEnabled = true;
+                try {
+                    onEnable();
+                } finally {
+                    this.allowsLifecycleRegistration = false;
+                    this.isBeingEnabled = false;
+                }
             } else {
                 onDisable();
             }
         }
     }
 
-    // Paper start
     private static class DummyPluginLoaderImplHolder {
         private static final PluginLoader INSTANCE =  net.kyori.adventure.util.Services.service(PluginLoader.class)
             .orElseThrow();
@@ -303,23 +301,22 @@ public abstract class JavaPlugin extends PluginBase {
         this.pluginMeta = description;
     }
     public final void init(@NotNull Server server, @NotNull PluginDescriptionFile description, @NotNull File dataFolder, @NotNull File file, @NotNull ClassLoader classLoader, @Nullable io.papermc.paper.plugin.configuration.PluginMeta configuration, @NotNull Logger logger) {
-    // Paper end
-        this.loader = DummyPluginLoaderImplHolder.INSTANCE; // Paper
+        this.loader = DummyPluginLoaderImplHolder.INSTANCE;
         this.server = server;
         this.file = file;
         this.description = description;
         this.dataFolder = dataFolder;
         this.classLoader = classLoader;
         this.configFile = new File(dataFolder, "config.yml");
-        this.pluginMeta = configuration; // Paper
-        this.logger = logger; // Paper
+        this.pluginMeta = configuration;
+        this.logger = logger;
     }
 
     /**
      * {@inheritDoc}
      */
     @Override
-    public boolean onCommand(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args) {
+    public boolean onCommand(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String @NotNull [] args) {
         return false;
     }
 
@@ -328,7 +325,7 @@ public abstract class JavaPlugin extends PluginBase {
      */
     @Override
     @Nullable
-    public List<String> onTabComplete(@NotNull CommandSender sender, @NotNull Command command, @NotNull String alias, @NotNull String[] args) {
+    public List<String> onTabComplete(@NotNull CommandSender sender, @NotNull Command command, @NotNull String alias, @NotNull String @NotNull [] args) {
         return null;
     }
 
@@ -339,9 +336,18 @@ public abstract class JavaPlugin extends PluginBase {
      *
      * @param name name or alias of the command
      * @return the plugin command if found, otherwise null
+     * @throws UnsupportedOperationException if this plugin is a paper plugin and the method is called in {@link #onEnable()}
      */
     @Nullable
     public PluginCommand getCommand(@NotNull String name) {
+        if (this.isBeingEnabled && !(pluginMeta instanceof PluginDescriptionFile)) {
+            throw new UnsupportedOperationException("""
+                You are trying to call JavaPlugin#getCommand on a Paper plugin during startup:
+                you are probably trying to get a command you tried to define in paper-plugin.yml.
+                Paper plugins do not support YAML-based command declarations!
+                Please check the documentation for more information on how to define commands in Paper plugins: https://docs.papermc.io/paper/dev/getting-started/paper-plugins#commands
+                """);
+        }
         String alias = name.toLowerCase(Locale.ROOT);
         PluginCommand command = getServer().getPluginCommand(alias);
 
@@ -429,10 +435,10 @@ public abstract class JavaPlugin extends PluginBase {
             throw new IllegalArgumentException(clazz + " does not extend " + JavaPlugin.class);
         }
         final ClassLoader cl = clazz.getClassLoader();
-        if (!(cl instanceof io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader configuredPluginClassLoader)) { // Paper
-            throw new IllegalArgumentException(clazz + " is not initialized by a " + io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader.class); // Paper
+        if (!(cl instanceof io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader configuredPluginClassLoader)) {
+            throw new IllegalArgumentException(clazz + " is not initialized by a " + io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader.class);
         }
-        JavaPlugin plugin = configuredPluginClassLoader.getPlugin(); // Paper
+        JavaPlugin plugin = configuredPluginClassLoader.getPlugin();
         if (plugin == null) {
             throw new IllegalStateException("Cannot get plugin for " + clazz + " from a static initializer");
         }
@@ -455,20 +461,18 @@ public abstract class JavaPlugin extends PluginBase {
     public static JavaPlugin getProvidingPlugin(@NotNull Class<?> clazz) {
         Preconditions.checkArgument(clazz != null, "Null class cannot have a plugin");
         final ClassLoader cl = clazz.getClassLoader();
-        if (!(cl instanceof io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader configuredPluginClassLoader)) { // Paper
-            throw new IllegalArgumentException(clazz + " is not provided by a " + io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader.class); // Paper
+        if (!(cl instanceof io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader configuredPluginClassLoader)) {
+            throw new IllegalArgumentException(clazz + " is not provided by a " + io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader.class);
         }
-        JavaPlugin plugin = configuredPluginClassLoader.getPlugin(); // Paper
+        JavaPlugin plugin = configuredPluginClassLoader.getPlugin();
         if (plugin == null) {
             throw new IllegalStateException("Cannot get plugin for " + clazz + " from a static initializer");
         }
         return plugin;
     }
 
-    // Paper start - lifecycle events
     @Override
     public final io.papermc.paper.plugin.lifecycle.event.@NotNull LifecycleEventManager<org.bukkit.plugin.Plugin> getLifecycleManager() {
         return this.lifecycleEventManager;
     }
-    // Paper end - lifecycle events
 }
diff --git a/src/main/java/org/bukkit/plugin/messaging/Messenger.java b/src/main/java/org/bukkit/plugin/messaging/Messenger.java
index 754fac6b2a45399efa34b06c6aa61f88c19e3d2b..2554d383d3108e2117dbc4978919ff4373cc2226 100644
--- a/src/main/java/org/bukkit/plugin/messaging/Messenger.java
+++ b/src/main/java/org/bukkit/plugin/messaging/Messenger.java
@@ -229,5 +229,5 @@ public interface Messenger {
      * @param channel Channel that the message was sent by.
      * @param message Raw payload of the message.
      */
-    public void dispatchIncomingMessage(@NotNull Player source, @NotNull String channel, @NotNull byte[] message);
+    public void dispatchIncomingMessage(@NotNull Player source, @NotNull String channel, byte @NotNull [] message);
 }
diff --git a/src/main/java/org/bukkit/plugin/messaging/PluginMessageListener.java b/src/main/java/org/bukkit/plugin/messaging/PluginMessageListener.java
index eb962efd5086cb2682ee22977da0a2735e86892b..70463cd059dee2cf0aa8851a1555244bea629cad 100644
--- a/src/main/java/org/bukkit/plugin/messaging/PluginMessageListener.java
+++ b/src/main/java/org/bukkit/plugin/messaging/PluginMessageListener.java
@@ -17,5 +17,5 @@ public interface PluginMessageListener {
      * @param player Source of the message.
      * @param message The raw message that was sent.
      */
-    public void onPluginMessageReceived(@NotNull String channel, @NotNull Player player, @NotNull byte[] message);
+    public void onPluginMessageReceived(@NotNull String channel, @NotNull Player player, byte @NotNull [] message);
 }
diff --git a/src/main/java/org/bukkit/plugin/messaging/PluginMessageRecipient.java b/src/main/java/org/bukkit/plugin/messaging/PluginMessageRecipient.java
index 281ae60a6be7e39aab4f27b4c7de3d49ada9a557..4a350155b44ada2f0cd3a7237537728a5263454a 100644
--- a/src/main/java/org/bukkit/plugin/messaging/PluginMessageRecipient.java
+++ b/src/main/java/org/bukkit/plugin/messaging/PluginMessageRecipient.java
@@ -27,7 +27,7 @@ public interface PluginMessageRecipient {
      * @throws ChannelNotRegisteredException Thrown if the channel is not
      *     registered for this plugin.
      */
-    public void sendPluginMessage(@NotNull Plugin source, @NotNull String channel, @NotNull byte[] message);
+    public void sendPluginMessage(@NotNull Plugin source, @NotNull String channel, byte @NotNull [] message);
 
     /**
      * Gets a set containing all the Plugin Channels that this client is
diff --git a/src/main/java/org/bukkit/plugin/messaging/StandardMessenger.java b/src/main/java/org/bukkit/plugin/messaging/StandardMessenger.java
index 7449d2f7876545bc598725ccdd0a327e601869ed..5580fdfe88df4122616fa6bab8f1874b9e8b1e7b 100644
--- a/src/main/java/org/bukkit/plugin/messaging/StandardMessenger.java
+++ b/src/main/java/org/bukkit/plugin/messaging/StandardMessenger.java
@@ -439,7 +439,7 @@ public class StandardMessenger implements Messenger {
     }
 
     @Override
-    public void dispatchIncomingMessage(@NotNull Player source, @NotNull String channel, @NotNull byte[] message) {
+    public void dispatchIncomingMessage(@NotNull Player source, @NotNull String channel, byte @NotNull [] message) {
         if (source == null) {
             throw new IllegalArgumentException("Player source cannot be null");
         }
@@ -534,7 +534,7 @@ public class StandardMessenger implements Messenger {
      * @throws ChannelNotRegisteredException Thrown if the channel is not
      *     registered for this plugin.
      */
-    public static void validatePluginMessage(@NotNull Messenger messenger, @NotNull Plugin source, @NotNull String channel, @NotNull byte[] message) {
+    public static void validatePluginMessage(@NotNull Messenger messenger, @NotNull Plugin source, @NotNull String channel, byte @NotNull [] message) {
         if (messenger == null) {
             throw new IllegalArgumentException("Messenger cannot be null");
         }
diff --git a/src/main/java/org/bukkit/potion/PotionEffect.java b/src/main/java/org/bukkit/potion/PotionEffect.java
index ab8f3c089ff50f4414d4c35810e65b2e73e2f678..7cac918e02cd62bedc8af63648f5d89f3506ff6e 100644
--- a/src/main/java/org/bukkit/potion/PotionEffect.java
+++ b/src/main/java/org/bukkit/potion/PotionEffect.java
@@ -2,6 +2,7 @@ package org.bukkit.potion;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableMap;
+import io.papermc.paper.registry.RegistryKey;
 import java.util.Map;
 import java.util.NoSuchElementException;
 import org.bukkit.Bukkit;
@@ -175,7 +176,7 @@ public class PotionEffect implements ConfigurationSerializable {
     private static PotionEffectType getEffectType(@NotNull Map<?, ?> map) {
         PotionEffectType effect;
         if (map.get(TYPE) instanceof String value) {
-            effect = Bukkit.getUnsafe().get(Registry.EFFECT, NamespacedKey.fromString(value));
+            effect = Bukkit.getUnsafe().get(RegistryKey.MOB_EFFECT, NamespacedKey.fromString(value));
         } else {
             int type = getInt(map, TYPE);
             effect = PotionEffectType.getById(type);
diff --git a/src/main/java/org/bukkit/util/ChatPaginator.java b/src/main/java/org/bukkit/util/ChatPaginator.java
index dea3b53c298128f93f2d71dbb488e69540dd8952..1f4abed0049de7f0c87c23513f444acbb59c7f0a 100644
--- a/src/main/java/org/bukkit/util/ChatPaginator.java
+++ b/src/main/java/org/bukkit/util/ChatPaginator.java
@@ -150,7 +150,7 @@ public class ChatPaginator {
         private int pageNumber;
         private int totalPages;
 
-        public ChatPage(@NotNull String[] lines, int pageNumber, int totalPages) {
+        public ChatPage(@NotNull String @NotNull [] lines, int pageNumber, int totalPages) {
             this.lines = lines;
             this.pageNumber = pageNumber;
             this.totalPages = totalPages;
@@ -165,7 +165,7 @@ public class ChatPaginator {
         }
 
         @NotNull
-        public String[] getLines() {
+        public String @NotNull [] getLines() {
             return lines;
         }
     }
diff --git a/src/main/java/org/bukkit/util/Transformation.java b/src/main/java/org/bukkit/util/Transformation.java
index 39f9e50c7dc710ee2f523f1c7074a89a377c1cf2..9b7e3ae77e752c5a50cacf4d8db2b66f13066ea3 100644
--- a/src/main/java/org/bukkit/util/Transformation.java
+++ b/src/main/java/org/bukkit/util/Transformation.java
@@ -27,9 +27,9 @@ public class Transformation {
         Preconditions.checkArgument(scale != null, "scale cannot be null");
         Preconditions.checkArgument(rightRotation != null, "rightRotation cannot be null");
 
-        this.translation = translation;
+        this.translation = new Vector3f(translation);
         this.leftRotation = new Quaternionf(leftRotation);
-        this.scale = scale;
+        this.scale = new Vector3f(scale);
         this.rightRotation = new Quaternionf(rightRotation);
     }
 
@@ -39,10 +39,10 @@ public class Transformation {
         Preconditions.checkArgument(scale != null, "scale cannot be null");
         Preconditions.checkArgument(rightRotation != null, "rightRotation cannot be null");
 
-        this.translation = translation;
-        this.leftRotation = leftRotation;
-        this.scale = scale;
-        this.rightRotation = rightRotation;
+        this.translation = new Vector3f(translation);
+        this.leftRotation = new Quaternionf(leftRotation);
+        this.scale = new Vector3f(scale);
+        this.rightRotation = new Quaternionf(rightRotation);
     }
 
     /**
diff --git a/src/main/java/org/bukkit/util/noise/OctaveGenerator.java b/src/main/java/org/bukkit/util/noise/OctaveGenerator.java
index 618ed706e2fdc4855a9ce4fe55e092a052c911d0..6560143553042aed516b81952b80b7d311f91adb 100644
--- a/src/main/java/org/bukkit/util/noise/OctaveGenerator.java
+++ b/src/main/java/org/bukkit/util/noise/OctaveGenerator.java
@@ -12,7 +12,7 @@ public abstract class OctaveGenerator {
     protected double yScale = 1;
     protected double zScale = 1;
 
-    protected OctaveGenerator(@NotNull NoiseGenerator[] octaves) {
+    protected OctaveGenerator(@NotNull NoiseGenerator @NotNull [] octaves) {
         this.octaves = octaves;
     }
 
@@ -90,7 +90,7 @@ public abstract class OctaveGenerator {
      * @return Clone of the individual octaves
      */
     @NotNull
-    public NoiseGenerator[] getOctaves() {
+    public NoiseGenerator @NotNull [] getOctaves() {
         return octaves.clone();
     }
 
diff --git a/src/main/java/org/bukkit/util/noise/SimplexNoiseGenerator.java b/src/main/java/org/bukkit/util/noise/SimplexNoiseGenerator.java
index 775d8f40322e9ed6702eb23bf50f35442d673c30..30974a0e58eb30b7aa2a45fc7409b2daa7cc40a3 100644
--- a/src/main/java/org/bukkit/util/noise/SimplexNoiseGenerator.java
+++ b/src/main/java/org/bukkit/util/noise/SimplexNoiseGenerator.java
@@ -78,15 +78,15 @@ public class SimplexNoiseGenerator extends PerlinNoiseGenerator {
         offsetW = rand.nextDouble() * 256;
     }
 
-    protected static double dot(@NotNull int[] g, double x, double y) {
+    protected static double dot(int @NotNull [] g, double x, double y) {
         return g[0] * x + g[1] * y;
     }
 
-    protected static double dot(@NotNull int[] g, double x, double y, double z) {
+    protected static double dot(int @NotNull [] g, double x, double y, double z) {
         return g[0] * x + g[1] * y + g[2] * z;
     }
 
-    protected static double dot(@NotNull int[] g, double x, double y, double z, double w) {
+    protected static double dot(int @NotNull [] g, double x, double y, double z, double w) {
         return g[0] * x + g[1] * y + g[2] * z + g[3] * w;
     }
 
diff --git a/src/main/java/org/spigotmc/CustomTimingsHandler.java b/src/main/java/org/spigotmc/CustomTimingsHandler.java
index 12946bd55fcf7c40d39081779a7fa30049ee6165..5fbacfcf108432c5187aa9a4092d00d7d5b0fd53 100644
--- a/src/main/java/org/spigotmc/CustomTimingsHandler.java
+++ b/src/main/java/org/spigotmc/CustomTimingsHandler.java
@@ -48,7 +48,7 @@ public final class CustomTimingsHandler {
     public CustomTimingsHandler(@NotNull String name) {
         Timing timing;
 
-        new AuthorNagException("Deprecated use of CustomTimingsHandler. Please Switch to Timings.of ASAP").printStackTrace();
+        new AuthorNagException("Deprecated use of CustomTimingsHandler. Timings has been removed.").printStackTrace();
         try {
             final Method ofSafe = TimingsManager.class.getDeclaredMethod("getHandler", String.class, String.class, Timing.class);
             ofSafe.setAccessible(true);
diff --git a/src/main/java/org/spigotmc/event/player/PlayerSpawnLocationEvent.java b/src/main/java/org/spigotmc/event/player/PlayerSpawnLocationEvent.java
index 2515887c20738b5add74eff02d2e9672080623d2..eeedfedc47115e1654c2461939bff9980c9033a1 100644
--- a/src/main/java/org/spigotmc/event/player/PlayerSpawnLocationEvent.java
+++ b/src/main/java/org/spigotmc/event/player/PlayerSpawnLocationEvent.java
@@ -37,7 +37,7 @@ public class PlayerSpawnLocationEvent extends PlayerEvent {
      * @param location the spawn location
      */
     public void setSpawnLocation(@NotNull Location location) {
-        this.spawnLocation = location;
+        this.spawnLocation = location.clone();
     }
 
     @NotNull

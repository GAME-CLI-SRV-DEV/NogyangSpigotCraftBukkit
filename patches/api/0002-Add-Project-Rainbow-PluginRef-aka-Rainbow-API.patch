From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Outfit7TSB <sunnybunnies09@naver.com>
Date: Mon, 20 Jan 2025 19:23:16 +0900
Subject: [PATCH] Add Project Rainbow PluginRef aka Rainbow API

Adds Project Rainbow API
Rainbow API By Codecrafter47.
WARNING: You still need plugin.yml. this will be removed in future version.

diff --git a/build.gradle.kts b/build.gradle.kts
index 571534b42cd9c33d6a7bb6fe3bf3a28e33f8e5de..e025ac1cabe209187418b7a9075ef947a03bfece 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -38,6 +38,12 @@ abstract class MockitoAgentProvider : CommandLineArgumentProvider {
 }
 // Paper end - configure mockito agent that is needed in newer java versions
 
+repositories {
+    maven {
+        url = uri("https://repo.minebench.de/") // just in case if compile fails due to missing lib.
+    }
+}
+
 dependencies {
     api("com.mojang:brigadier:1.2.9") // Paper - Brigadier command api
     // api dependencies are listed transitively to API consumers
@@ -47,6 +53,7 @@ dependencies {
     api("net.md-5:bungeecord-chat:$bungeeCordChatVersion-deprecated+build.19") {
         exclude("com.google.guava", "guava")
     }
+	api("net.md-5:bungeecord-config:$bungeeCordChatVersion")
     // Paper - adventure
     api("org.yaml:snakeyaml:2.2")
     api("org.joml:joml:1.10.8") {
@@ -66,7 +73,7 @@ dependencies {
     apiAndDocs("net.kyori:adventure-text-logger-slf4j")
     api("org.apache.logging.log4j:log4j-api:$log4jVersion")
     api("org.slf4j:slf4j-api:$slf4jVersion")
-
+    compileOnly("codecrafter47.util:chat-utils:1.1-SNAPSHOT")
     implementation("org.ow2.asm:asm:9.7.1")
     implementation("org.ow2.asm:asm-commons:9.7.1")
     // Paper end
diff --git a/src/main/java/PluginReference/BlockHelper.java b/src/main/java/PluginReference/BlockHelper.java
new file mode 100644
index 0000000000000000000000000000000000000000..c07839de4f0a64ef09337947fda11285f79d6d8a
--- /dev/null
+++ b/src/main/java/PluginReference/BlockHelper.java
@@ -0,0 +1,111 @@
+package PluginReference;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/** 
+ * Block-related utility functions and maps available to Rainbow plugins.
+ */
+public class BlockHelper
+{
+	 /** 
+     * Map of Block ID to internal Block Name
+     * For example, 8 maps to 'flowing_water'
+     */
+	 @Deprecated
+	public static Map<Integer, String> mapBlockNames = new ConcurrentHashMap<Integer, String>();
+	 /** 
+     * Map of ID:Subtype string to friendly Block Name
+     * For example, "126:5" maps to "Dark Oak Wood Slab"
+     */
+	 @Deprecated
+	public static Map<String, String> mapItemNames = new ConcurrentHashMap<String, String>();
+	 /**
+     * Map of ID to number of subtypes
+     * For example, ID 1 maps to 7 because there are 7 stone subtypes in MC 1.8
+     */
+	 @Deprecated
+	public static Map<Integer, Integer> mapNumSubtypes = new ConcurrentHashMap<Integer, Integer>();
+
+	 /** 
+     * Get internal block name from ID.
+     * For example, returns "flowing_water" for ID 8.
+	 * @param blockID block id
+     * @return Block Name
+     */
+	 @Deprecated
+	public static String getBlockName(int blockID)
+	{
+		String res = mapBlockNames.get(blockID);
+		if (res != null) return res;
+		res = ("BlockID_" + blockID);
+		//System.out.println("----- DBG: " + res + " -----");
+		return res;
+	}
+
+	 /** 
+     * Translates (ID=139,Subtype=1) into "Mossy Cobblestone Wall" and so forth.
+	 * @param blockID
+	 * @param subType
+     * @return Friendly Name
+     */
+	 @Deprecated
+	public static String getBlockFriendlyName(int blockID, int subType)
+	{
+		Integer numSubTypes = mapNumSubtypes.get(blockID);
+		if(numSubTypes == null) numSubTypes = 1;
+		if(numSubTypes <= 1)
+		{
+			String key = blockID + ":0";
+			String res = mapItemNames.get(key);
+			return (res != null) ? res : ("BlockID_" + blockID + ":" + subType);
+		}
+
+		// Reduce by next highest power of 2...
+		// This is because the dmg value may include other bitwise markers like directional attribute
+		int powTwo = 2;
+		for(int i=0; i<5; i++)
+		{
+			if(numSubTypes <= powTwo)
+			{
+				subType %= powTwo;
+				break;
+			}
+			powTwo *= 2;
+		}
+		// Lookup based on refined dmg value...
+
+		String key = blockID + ":" + subType;
+		String res = mapItemNames.get(key);
+		if (res != null) return res;
+		
+		res = ("BlockID_" + blockID + ":" + subType);
+		//System.out.println("----- DBG: " + res + " -----");
+		return res;
+	}
+	
+	 /** 
+     * Translates Minecraft integer representation of a block into just the Block ID.
+     * See PluginBase.onBlockBroke() for an example of where this is used. 
+     * @param  blockKey ID
+     * @return Block ID
+     */
+	 @Deprecated
+	public static int getBlockID_FromKey(int blockKey)
+	{
+		int blockID = blockKey & ((1 << 12) - 1);
+		return blockID;
+	}
+
+	 /** 
+     * Translates Minecraft integer representation of a block into just the Block Subtype
+     * See PluginBase.onBlockBroke() for an example of where this is used.
+	 * @param  blockKey ID
+     * @return Block Subtype
+     */
+	 @Deprecated
+	public static int getBlockSubtype_FromKey(int blockKey)
+	{
+		return (blockKey >> 12);
+	}
+}
diff --git a/src/main/java/PluginReference/ChatColor.java b/src/main/java/PluginReference/ChatColor.java
new file mode 100644
index 0000000000000000000000000000000000000000..6223baf10c5414721b6db556e0226d55ffc446fc
--- /dev/null
+++ b/src/main/java/PluginReference/ChatColor.java
@@ -0,0 +1,67 @@
+package PluginReference;
+
+/** 
+ * Class containing color codes and related functions.
+ */ 			
+public class ChatColor {
+        public static String ColorPrefix   = "\u00A7";
+        public static char   ColorChar     = '\u00A7';
+        public static String BLACK         = ColorPrefix + "0";
+        public static String DARK_BLUE     = ColorPrefix + "1";
+        public static String DARK_GREEN    = ColorPrefix + "2";
+        public static String DARK_AQUA     = ColorPrefix + "3";
+        public static String DARK_RED      = ColorPrefix + "4";
+        public static String DARK_PURPLE   = ColorPrefix + "5";
+        public static String GOLD          = ColorPrefix + "6";
+        public static String GRAY          = ColorPrefix + "7";
+        public static String DARK_GRAY     = ColorPrefix + "8";
+        public static String BLUE          = ColorPrefix + "9";
+        public static String GREEN         = ColorPrefix + "a";
+        public static String AQUA          = ColorPrefix + "b";
+        public static String RED           = ColorPrefix + "c";
+        public static String LIGHT_PURPLE  = ColorPrefix + "d";
+        public static String YELLOW        = ColorPrefix + "e";
+        public static String WHITE         = ColorPrefix + "f";
+        public static String MAGIC         = ColorPrefix + "k";
+        public static String BOLD          = ColorPrefix + "l";
+        public static String STRIKETHROUGH = ColorPrefix + "m";
+        public static String UNDERLINE     = ColorPrefix + "n";
+        public static String ITALIC        = ColorPrefix + "o";
+        public static String RESET         = ColorPrefix + "r";
+        
+	
+	
+	public static String StripColor(String str) {
+		if(str == null) return "";
+		
+		StringBuilder sb = new StringBuilder();
+		
+		char colorChar = ColorPrefix.charAt(0);
+		boolean colorMode = false;
+		for(int i=0; i<str.length(); i++) {
+			char ch = str.charAt(i);
+			if(ch == colorChar){
+				colorMode = true;
+				continue;
+			} if(colorMode) {
+				colorMode = false;
+				continue;
+			}
+			if(ch == '\u205A') continue; // skip special character used by TextLabel()
+			
+			sb.append(ch);
+		}
+		return sb.toString();		
+	}
+    
+    public static String translateAlternateColorCodes(char altColorChar, String textToTranslate) {
+        char[] a = textToTranslate.toCharArray();
+        for (int b = 0; b < a.length - 1; b++) {
+            if (a[b] == altColorChar && "0123456789AaBbCcDdEeFfKkLlMmNnOoRr".indexOf(a[b+1]) > -1) {
+                a[b] = ColorChar;
+                a[b+1] = Character.toLowerCase(a[b+1]);
+            }
+        }
+        return String.valueOf(a);
+    }
+}
diff --git a/src/main/java/PluginReference/MC_Animal.java b/src/main/java/PluginReference/MC_Animal.java
new file mode 100644
index 0000000000000000000000000000000000000000..bc29347ee3613aecf03bf83051c29640d2ddf0b7
--- /dev/null
+++ b/src/main/java/PluginReference/MC_Animal.java
@@ -0,0 +1,9 @@
+package PluginReference;
+
+/** 
+ * Interface representing an Animal
+ */ 			
+public interface MC_Animal extends MC_EntityAgeable
+{
+
+}
diff --git a/src/main/java/PluginReference/MC_AnimalTameable.java b/src/main/java/PluginReference/MC_AnimalTameable.java
new file mode 100644
index 0000000000000000000000000000000000000000..fce096fd1b14bf7bb300c4fed5409a9ab64669db
--- /dev/null
+++ b/src/main/java/PluginReference/MC_AnimalTameable.java
@@ -0,0 +1,72 @@
+package PluginReference;
+
+/** 
+ * Interface representing a tameable animal
+ */ 			
+public interface MC_AnimalTameable extends MC_Animal
+{
+	 /** 
+     * Check if an Animal is tamed
+     * @return True if tamed, False otherwise
+     */ 		
+	public boolean isTamed();
+	 /** 
+     * Sets tamed setting
+     * 
+     * @param flag True to tame, false otherwise
+     */ 		
+	public void setTamed(boolean flag);
+
+	 /** 
+     * Check if an Animal is sitting
+     * @return True if sitting, False otherwise
+     */ 		
+	public boolean getSitting();
+	 /** 
+     * Sets the sitting status
+     * 
+     * @param flag True to sit, False otherwise
+     */ 		
+	public void setSitting(boolean flag);
+
+	 /** 
+     * Get UUID of Owner
+     * 
+     * @return UUID of Owner    
+     */ 			
+	public String getUUIDOfOwner();
+	 /** 
+     * Sets UUID of owning player
+     * 
+     * @param uuid UUID of owning player
+     */ 		
+	public void setUUIDOfOwner(String uuid);
+	 /** 
+     * Sets owner to player
+     * 
+     * @param plr Player object
+     */ 		
+	public void setOwner(MC_Player plr);
+	 /** 
+     * Get Owning Player
+     * 
+     * @return Player Object    
+     */ 			
+	public MC_Player getOwner();
+	 /** 
+     * Check if owned by specified player
+     * 
+     * @param plr Player object
+     * @return True if owned by player, False otherwise    
+     */ 			
+	public boolean isOwnedBy(MC_Player plr);
+
+
+	 /** 
+     * Initiates a particle effect, true for hearts, false for smoke.
+     * 
+     * @param flag True for Love, False for Hate
+     */ 		
+	public void showLoveHateEffect(boolean flag); // true = hearts, false = smoke particles
+	
+}
diff --git a/src/main/java/PluginReference/MC_ArmorSlotType.java b/src/main/java/PluginReference/MC_ArmorSlotType.java
new file mode 100644
index 0000000000000000000000000000000000000000..1f07addced8e44db3dc8b5c7cab69c6e570abe14
--- /dev/null
+++ b/src/main/java/PluginReference/MC_ArmorSlotType.java
@@ -0,0 +1,12 @@
+package PluginReference;
+
+/** 
+ * Defines values used when specifying armor slots.
+ */ 			
+public class MC_ArmorSlotType
+{
+	public static int BOOTS = 0;
+	public static int LEGS = 1;
+	public static int CHEST = 2;
+	public static int HAT = 3;
+}
diff --git a/src/main/java/PluginReference/MC_ArmorStand.java b/src/main/java/PluginReference/MC_ArmorStand.java
new file mode 100644
index 0000000000000000000000000000000000000000..c3c5501214c62bb807a8bb1285e8c75a80781679
--- /dev/null
+++ b/src/main/java/PluginReference/MC_ArmorStand.java
@@ -0,0 +1,77 @@
+package PluginReference;
+
+import java.util.List;
+
+/** 
+ * Armor Stand
+ */ 			
+public interface MC_ArmorStand extends MC_Entity
+{
+	 /** 
+     * Check if Armor Stand has arms
+     * 
+     * @return True if has arms, False otherwise 
+     */ 		
+	public boolean hasArms();
+	 /** 
+     * Check if Armor Stand has base plate
+     * 
+     * @return True if has base plate, False otherwise 
+     */ 		
+	public boolean hasBase();
+
+	 /** 
+     * Set whether Armor Stand has arms
+     * 
+     * @param flag True if has arms, False otherwise
+     */ 		
+	public void setHasArms(boolean flag);
+	 /** 
+     * Set whether Armor Stand has base plate
+     * 
+     * @param flag True if has base plate, False otherwise
+     */ 		
+	public void setHasBase(boolean flag);
+	
+	 /** 
+     * Gets rotational pose values for head, body, left arm, right arm, left leg, and right leg.
+     * 
+     * @return Array of triplets representing 3d rotations for each component 
+     */ 		
+	public List<MC_FloatTriplet> getPose();
+	 /** 
+     * Set rotational pose values for head, body, left arm, right arm, left leg, and right leg.
+     * 
+     * @param pose Array of triplets representing 3d rotations for each component
+     */ 		
+	public void setPose(List<MC_FloatTriplet> pose);
+	
+	 /** 
+     * Gets item in hand
+     * 
+     * @return Item in hand 
+     */ 		
+	public MC_ItemStack getItemInHand();
+
+	/** 
+     * Sets item in hand
+     * 
+     * @param item Item in hand
+     */ 		
+	public void setItemInHand(MC_ItemStack item);
+
+	/**
+	 * Get Item in off-hand
+	 *
+	 * @return Item in off-hand
+	 */
+	public MC_ItemStack getItemInOffHand();
+
+	/**
+	 * Sets item in off-hand
+	 *
+	 * @param item Item
+	 */
+	public void setItemInOffHand(MC_ItemStack item);
+	
+}
diff --git a/src/main/java/PluginReference/MC_ArmorStandActionType.java b/src/main/java/PluginReference/MC_ArmorStandActionType.java
new file mode 100644
index 0000000000000000000000000000000000000000..f6ac8f20849979d77bde5d6c3f5ca5dd6c8943fd
--- /dev/null
+++ b/src/main/java/PluginReference/MC_ArmorStandActionType.java
@@ -0,0 +1,15 @@
+package PluginReference;
+
+/** 
+ * Defines values associated with the location Armor Stand interactions
+ */ 			
+public enum MC_ArmorStandActionType
+{
+	UNSPECIFIED,
+	HEAD,
+	BODY,
+	LEGS,
+	FEET,
+	HELD_ITEM,
+	OFFHAND_ITEM
+}
diff --git a/src/main/java/PluginReference/MC_Arrow.java b/src/main/java/PluginReference/MC_Arrow.java
new file mode 100644
index 0000000000000000000000000000000000000000..128dfd8c7cfa3c3babe1bbbf1f4ef27f6bb427c0
--- /dev/null
+++ b/src/main/java/PluginReference/MC_Arrow.java
@@ -0,0 +1,8 @@
+package PluginReference;
+
+/**
+ * Arrow
+ */
+public interface MC_Arrow extends MC_Projectile {
+
+}
diff --git a/src/main/java/PluginReference/MC_Attribute.java b/src/main/java/PluginReference/MC_Attribute.java
new file mode 100644
index 0000000000000000000000000000000000000000..9334f7c3cd6f419c72073c7735555f5480054485
--- /dev/null
+++ b/src/main/java/PluginReference/MC_Attribute.java
@@ -0,0 +1,59 @@
+package PluginReference;
+
+import java.util.Collection;
+
+/**
+ * An attribute associated with a specific entity.
+ */
+public interface MC_Attribute {
+
+    /**
+     * Get the type of this attribute.
+     *
+     * @return the type
+     */
+    MC_AttributeType getType();
+
+    /**
+     * Get the base value of this attribute. The base value of an attribute is
+     * different for different entities.
+     *
+     * @return the base value
+     */
+    double getBaseValue();
+
+    /**
+     * Set the base value of this attribute.
+     *
+     * @param baseValue the new base value
+     */
+    void setBaseValue(double baseValue);
+
+    /**
+     * Get the value of this attribute after applying the modifiers.
+     *
+     * @return the effective value
+     */
+    double getEffectiveValue();
+
+    /**
+     * Get all modifiers of this attribute.
+     *
+     * @return an immutable collection of the modifiers
+     */
+    Collection<? extends MC_AttributeModifier> getModifiers();
+
+    /**
+     * Remove a modifier from this attribute.
+     *
+     * @param modifier the modifier to remove
+     */
+    void removeModifier(MC_AttributeModifier modifier);
+
+    /**
+     * Add a modifier to this attribute.
+     *
+     * @param modifier the modifier to add
+     */
+    void addModifier(MC_AttributeModifier modifier);
+}
diff --git a/src/main/java/PluginReference/MC_AttributeModifier.java b/src/main/java/PluginReference/MC_AttributeModifier.java
new file mode 100644
index 0000000000000000000000000000000000000000..0b1f91fa3551428097ecef3afcfcb1c17b7f84ee
--- /dev/null
+++ b/src/main/java/PluginReference/MC_AttributeModifier.java
@@ -0,0 +1,65 @@
+package PluginReference;
+
+import java.util.UUID;
+
+/**
+ * An attribute modifier.
+ * <p>
+ * New instances of this class can be created using the
+ * {@link MC_Server#createAttributeModifier} factory method.
+ */
+public interface MC_AttributeModifier {
+
+    /**
+     * Get the operator used by this attribute modifier.
+     *
+     * @return the operator
+     */
+    Operator getOperator();
+
+    /**
+     * Get the value of this attribute modifier.
+     *
+     * @return the value
+     */
+    double getValue();
+
+    /**
+     * Get the name of this attribute modifier.
+     *
+     * @return the name
+     */
+    String getName();
+
+    /**
+     * Get the uuid of the attribute modifier. Each attribute modifier must have
+     * a unique UUID
+     *
+     * @return the UUID
+     */
+    UUID getUUID();
+
+    /**
+     * Operator of the attribute modifier.
+     */
+    enum Operator {
+
+        /**
+         * Add a fixed value to the base value.
+         */
+        ADD_CONSTANT,
+
+        /**
+         * Add a scalar amount relative to the value of the attribute after
+         * applying the ADD_CONSTANT modifiers.
+         */
+        ADD_SCALAR_BASE,
+
+        /**
+         * Increment the value of the attribute by a scalar amount. These
+         * modifiers are applied after the ADD_CONSTANT and ADD_SCALAR_BASE
+         * modifiers.
+         */
+        ADD_SCALAR
+    }
+}
diff --git a/src/main/java/PluginReference/MC_AttributeType.java b/src/main/java/PluginReference/MC_AttributeType.java
new file mode 100644
index 0000000000000000000000000000000000000000..8fa5ec262b1f3f7f40998ececb60b65e7876c30c
--- /dev/null
+++ b/src/main/java/PluginReference/MC_AttributeType.java
@@ -0,0 +1,18 @@
+package PluginReference;
+
+/**
+ * Available types for {@link MC_Attribute}
+ */
+public enum MC_AttributeType {
+    MAX_HEALTH,
+    FOLLOW_RANGE,
+    KNOCKBACK_RESISTANCE,
+    MOVEMENT_SPEED,
+    ATTACK_DAMAGE,
+    ARMOR,
+    ARMOR_TOUGHNESS,
+    PLAYER_ATTACK_SPEED,
+    PLAYER_LUCK,
+    HORSE_JUMP_STRENGTH,
+    ZOMBIE_REINFORCEMENT_CHANCE;
+}
diff --git a/src/main/java/PluginReference/MC_Block.java b/src/main/java/PluginReference/MC_Block.java
new file mode 100644
index 0000000000000000000000000000000000000000..e52cfedd12d2054fa1d37897dd06b70c2a899b84
--- /dev/null
+++ b/src/main/java/PluginReference/MC_Block.java
@@ -0,0 +1,44 @@
+package PluginReference;
+
+/** 
+ * Interface representing a Minecraft block.
+ */ 			
+public interface MC_Block
+{
+	 /** 
+     * Get the Minecraft ID for this block.
+     * @return Minecraft ID
+     */
+	 @Deprecated
+	public int getId();
+	
+	 /** 
+     * Get the subtype for this block type
+     * @return Subtype value
+     */
+	 @Deprecated
+	public int getSubtype();
+	
+	 /** 
+     * Check if block is solid
+     * @return True if solid, False otherwise
+     */ 		
+	public boolean isSolid();
+	 /** 
+     * Check if block is liquid
+     * @return True if liquid, False otherwise
+     */ 		
+	public boolean isLiquid();
+
+	 /** 
+     * Set Subtype value
+     * @param idx Subtype value
+     */
+	 @Deprecated
+	public void setSubtype(int idx);
+
+	 public String getOfficialName();
+
+	 public String getFriendlyName();
+	
+}
diff --git a/src/main/java/PluginReference/MC_BlockType.java b/src/main/java/PluginReference/MC_BlockType.java
new file mode 100644
index 0000000000000000000000000000000000000000..cc2c61d13c4ad06abb3a53d45d5de4c711c24b18
--- /dev/null
+++ b/src/main/java/PluginReference/MC_BlockType.java
@@ -0,0 +1,265 @@
+package PluginReference;
+
+/**
+ * Convenience variables to use instead of Minecraft IDs
+ */
+@Deprecated
+public class MC_BlockType {
+    public static final int AIR = 0;
+    public static final int STONE = 1;
+    public static final int GRASS = 2;
+    public static final int DIRT = 3;
+    public static final int COBBLESTONE = 4;
+    public static final int PLANKS = 5;
+    public static final int SAPLING = 6;
+    public static final int BEDROCK = 7;
+    public static final int FLOWING_WATER = 8;
+    public static final int WATER = 9;
+    public static final int FLOWING_LAVA = 10;
+    public static final int LAVA = 11;
+    public static final int SAND = 12;
+    public static final int GRAVEL = 13;
+    public static final int GOLD_ORE = 14;
+    public static final int IRON_ORE = 15;
+    public static final int COAL_ORE = 16;
+    public static final int LOG = 17;
+    public static final int LEAVES = 18;
+    public static final int SPONGE = 19;
+    public static final int GLASS = 20;
+    public static final int LAPIS_ORE = 21;
+    public static final int LAPIS_BLOCK = 22;
+    public static final int DISPENSER = 23;
+    public static final int SANDSTONE = 24;
+    public static final int NOTEBLOCK = 25;
+    public static final int BED = 26;
+    public static final int GOLDEN_RAIL = 27;
+    public static final int DETECTOR_RAIL = 28;
+    public static final int STICKY_PISTON = 29;
+    public static final int WEB = 30;
+    public static final int TALLGRASS = 31;
+    public static final int DEADBUSH = 32;
+    public static final int PISTON = 33;
+    public static final int PISTON_HEAD = 34;
+    public static final int WOOL = 35;
+    public static final int PISTON_EXTENSION = 36;
+    public static final int YELLOW_FLOWER = 37;
+    public static final int RED_FLOWER = 38;
+    public static final int BROWN_MUSHROOM = 39;
+    public static final int RED_MUSHROOM = 40;
+    public static final int GOLD_BLOCK = 41;
+    public static final int IRON_BLOCK = 42;
+    public static final int DOUBLE_STONE_SLAB = 43;
+    public static final int STONE_SLAB = 44;
+    public static final int BRICK_BLOCK = 45;
+    public static final int TNT = 46;
+    public static final int BOOKSHELF = 47;
+    public static final int MOSSY_COBBLESTONE = 48;
+    public static final int OBSIDIAN = 49;
+    public static final int TORCH = 50;
+    public static final int FIRE = 51;
+    public static final int MOB_SPAWNER = 52;
+    public static final int OAK_STAIRS = 53;
+    public static final int CHEST = 54;
+    public static final int REDSTONE_WIRE = 55;
+    public static final int DIAMOND_ORE = 56;
+    public static final int DIAMOND_BLOCK = 57;
+    public static final int CRAFTING_TABLE = 58;
+    public static final int WHEAT = 59;
+    public static final int FARMLAND = 60;
+    public static final int FURNACE = 61;
+    public static final int LIT_FURNACE = 62;
+    public static final int STANDING_SIGN = 63;
+    public static final int WOODEN_DOOR = 64;
+    public static final int LADDER = 65;
+    public static final int RAIL = 66;
+    public static final int STONE_STAIRS = 67;
+    public static final int WALL_SIGN = 68;
+    public static final int LEVER = 69;
+    public static final int STONE_PRESSURE_PLATE = 70;
+    public static final int IRON_DOOR = 71;
+    public static final int WOODEN_PRESSURE_PLATE = 72;
+    public static final int REDSTONE_ORE = 73;
+    public static final int LIT_REDSTONE_ORE = 74;
+    public static final int UNLIT_REDSTONE_TORCH = 75;
+    public static final int REDSTONE_TORCH = 76;
+    public static final int STONE_BUTTON = 77;
+    public static final int SNOW_LAYER = 78;
+    public static final int ICE = 79;
+    public static final int SNOW = 80;
+    public static final int CACTUS = 81;
+    public static final int CLAY = 82;
+    public static final int REEDS = 83;
+    public static final int JUKEBOX = 84;
+    public static final int FENCE = 85;
+    public static final int PUMPKIN = 86;
+    public static final int NETHERRACK = 87;
+    public static final int SOUL_SAND = 88;
+    public static final int GLOWSTONE = 89;
+    public static final int PORTAL = 90;
+    public static final int LIT_PUMPKIN = 91;
+    public static final int CAKE = 92;
+    public static final int UNPOWERED_REPEATER = 93;
+    public static final int POWERED_REPEATER = 94;
+    public static final int STAINED_GLASS = 95;
+    public static final int TRAPDOOR = 96;
+    public static final int MONSTER_EGG = 97;
+    public static final int STONEBRICK = 98;
+    public static final int BROWN_MUSHROOM_BLOCK = 99;
+    public static final int RED_MUSHROOM_BLOCK = 100;
+    public static final int IRON_BARS = 101;
+    public static final int GLASS_PANE = 102;
+    public static final int MELON_BLOCK = 103;
+    public static final int PUMPKIN_STEM = 104;
+    public static final int MELON_STEM = 105;
+    public static final int VINE = 106;
+    public static final int FENCE_GATE = 107;
+    public static final int BRICK_STAIRS = 108;
+    public static final int STONE_BRICK_STAIRS = 109;
+    public static final int MYCELIUM = 110;
+    public static final int WATERLILY = 111;
+    public static final int NETHER_BRICK = 112;
+    public static final int NETHER_BRICK_FENCE = 113;
+    public static final int NETHER_BRICK_STAIRS = 114;
+    public static final int NETHER_WART = 115;
+    public static final int ENCHANTING_TABLE = 116;
+    public static final int BREWING_STAND = 117;
+    public static final int CAULDRON = 118;
+    public static final int END_PORTAL = 119;
+    public static final int END_PORTAL_FRAME = 120;
+    public static final int END_STONE = 121;
+    public static final int DRAGON_EGG = 122;
+    public static final int REDSTONE_LAMP = 123;
+    public static final int LIT_REDSTONE_LAMP = 124;
+    public static final int DOUBLE_WOODEN_SLAB = 125;
+    public static final int WOODEN_SLAB = 126;
+    public static final int COCOA = 127;
+    public static final int SANDSTONE_STAIRS = 128;
+    public static final int EMERALD_ORE = 129;
+    public static final int ENDER_CHEST = 130;
+    public static final int TRIPWIRE_HOOK = 131;
+    public static final int TRIPWIRE = 132;
+    public static final int EMERALD_BLOCK = 133;
+    public static final int SPRUCE_STAIRS = 134;
+    public static final int BIRCH_STAIRS = 135;
+    public static final int JUNGLE_STAIRS = 136;
+    public static final int COMMAND_BLOCK = 137;
+    public static final int BEACON = 138;
+    public static final int COBBLESTONE_WALL = 139;
+    public static final int FLOWER_POT = 140;
+    public static final int CARROTS = 141;
+    public static final int POTATOES = 142;
+    public static final int WOODEN_BUTTON = 143;
+    public static final int SKULL = 144;
+    public static final int ANVIL = 145;
+    public static final int TRAPPED_CHEST = 146;
+    public static final int LIGHT_WEIGHTED_PRESSURE_PLATE = 147;
+    public static final int HEAVY_WEIGHTED_PRESSURE_PLATE = 148;
+    public static final int UNPOWERED_COMPARATOR = 149;
+    public static final int POWERED_COMPARATOR = 150;
+    public static final int DAYLIGHT_DETECTOR = 151;
+    public static final int REDSTONE_BLOCK = 152;
+    public static final int QUARTZ_ORE = 153;
+    public static final int HOPPER = 154;
+    public static final int QUARTZ_BLOCK = 155;
+    public static final int QUARTZ_STAIRS = 156;
+    public static final int ACTIVATOR_RAIL = 157;
+    public static final int DROPPER = 158;
+    public static final int STAINED_HARDENED_CLAY = 159;
+    public static final int STAINED_GLASS_PANE = 160;
+    public static final int LEAVES2 = 161;
+    public static final int LOG2 = 162;
+    public static final int ACACIA_STAIRS = 163;
+    public static final int DARK_OAK_STAIRS = 164;
+    public static final int SLIME = 165;
+    public static final int BARRIER = 166;
+    public static final int IRON_TRAPDOOR = 167;
+    public static final int PRISMARINE = 168;
+    public static final int SEA_LANTERN = 169;
+    public static final int HAY_BLOCK = 170;
+    public static final int CARPET = 171;
+    public static final int HARDENED_CLAY = 172;
+    public static final int COAL_BLOCK = 173;
+    public static final int PACKED_ICE = 174;
+    public static final int DOUBLE_PLANT = 175;
+    public static final int STANDING_BANNER = 176;
+    public static final int WALL_BANNER = 177;
+    public static final int DAYLIGHT_DETECTOR_INVERTED = 178;
+    public static final int RED_SANDSTONE = 179;
+    public static final int RED_SANDSTONE_STAIRS = 180;
+    public static final int DOUBLE_STONE_SLAB2 = 181;
+    public static final int STONE_SLAB2 = 182;
+    public static final int SPRUCE_FENCE_GATE = 183;
+    public static final int BIRCH_FENCE_GATE = 184;
+    public static final int JUNGLE_FENCE_GATE = 185;
+    public static final int DARK_OAK_FENCE_GATE = 186;
+    public static final int ACACIA_FENCE_GATE = 187;
+    public static final int SPRUCE_FENCE = 188;
+    public static final int BIRCH_FENCE = 189;
+    public static final int JUNGLE_FENCE = 190;
+    public static final int DARK_OAK_FENCE = 191;
+    public static final int ACACIA_FENCE = 192;
+    public static final int SPRUCE_DOOR = 193;
+    public static final int BIRCH_DOOR = 194;
+    public static final int JUNGLE_DOOR = 195;
+    public static final int ACACIA_DOOR = 196;
+    public static final int DARK_OAK_DOOR = 197;
+    public static final int END_ROD = 198;
+    public static final int CHORUS_PLANT = 199;
+    public static final int CHORUS_FLOWER = 200;
+    public static final int PURPUR_BLOCK = 201;
+    public static final int PURPUR_PILLAR = 202;
+    public static final int PURPUR_STAIRS = 203;
+    public static final int PURPUR_DOUBLE_SLAB = 204;
+    public static final int PURPUR_SLAB = 205;
+    public static final int END_BRICKS = 206;
+    public static final int BEETROOTS = 207;
+    public static final int GRASS_PATH = 208;
+    public static final int END_GATEWAY = 209;
+    public static final int REPEATING_COMMAND_BLOCK = 210;
+    public static final int CHAIN_COMMAND_BLOCK = 211;
+    public static final int FROSTED_ICE = 212;
+    public static final int MAGMA = 213;
+    public static final int NETHER_WART_BLOCK = 214;
+    public static final int RED_NETHER_BRICK = 215;
+    public static final int BONE_BLOCK = 216;
+    public static final int STRUCTURE_VOID = 217;
+    public static final int OBSERVER = 218;
+    public static final int SHULKER_BOX_WHITE = 219;
+    public static final int SHULKER_BOX_ORANGE = 220;
+    public static final int SHULKER_BOX_MAGENTA = 221;
+    public static final int SHULKER_BOX_LIGHT_BLUE = 222;
+    public static final int SHULKER_BOX_YELLOW = 223;
+    public static final int SHULKER_BOX_LIME = 224;
+    public static final int SHULKER_BOX_PINK = 225;
+    public static final int SHULKER_BOX_GRAY = 226;
+    public static final int SHULKER_BOX_SILVER = 227;
+    public static final int SHULKER_BOX_CYAN = 228;
+    public static final int SHULKER_BOX_PURPLE = 229;
+    public static final int SHULKER_BOX_BLUE = 230;
+    public static final int SHULKER_BOX_BROWN = 231;
+    public static final int SHULKER_BOX_GREEN = 232;
+    public static final int SHULKER_BOX_RED = 233;
+    public static final int SHULKER_BOX_BLACK = 234;
+    public static final int TERRACOTTA_WHITE = 235;
+    public static final int TERRACOTTA_ORANGE = 236;
+    public static final int TERRACOTTA_MAGENTA = 237;
+    public static final int TERRACOTTA_LIGHT_BLUE = 238;
+    public static final int TERRACOTTA_YELLOW = 239;
+    public static final int TERRACOTTA_LIME = 240;
+    public static final int TERRACOTTA_PINK = 241;
+    public static final int TERRACOTTA_GRAY = 242;
+    public static final int TERRACOTTA_SILVER = 243;
+    public static final int TERRACOTTA_CYAN = 244;
+    public static final int TERRACOTTA_PURPLE = 245;
+    public static final int TERRACOTTA_BLUE = 246;
+    public static final int TERRACOTTA_BROWN = 247;
+    public static final int TERRACOTTA_GREEN = 248;
+    public static final int TERRACOTTA_RED = 249;
+    public static final int TERRACOTTA_BLACK = 250;
+    public static final int CONCRETE = 251;
+    public static final int CONCRETE_POWDER = 252;
+
+
+    public static final int STRUCTURE_BLOCK = 255;
+
+}
diff --git a/src/main/java/PluginReference/MC_Chest.java b/src/main/java/PluginReference/MC_Chest.java
new file mode 100644
index 0000000000000000000000000000000000000000..b8dc472edc89a5d734b9287d95ebe01e5ad227a7
--- /dev/null
+++ b/src/main/java/PluginReference/MC_Chest.java
@@ -0,0 +1,45 @@
+package PluginReference;
+
+import java.util.List;
+
+/** 
+ * Interface representing a Chest
+ */ 			
+public interface MC_Chest
+{
+	 /** 
+     * Get the contents of a chest
+     * 
+     * @return List of items 
+     */ 		
+	public List<MC_ItemStack> getInventory();
+	
+	 /** 
+     * Set contents of this chest
+     * 
+     * @param items List of items 
+     */ 		
+	public void setInventory(List<MC_ItemStack> items);
+
+	 /** 
+     * Get connected chest at a direction
+     * 
+     * @param dir Direction to inspect
+     * @return Connected chest object at that direction 
+     */ 		
+	public MC_Chest GetLinkedChestAt(MC_DirectionNESWUD dir);
+
+	 /** 
+     * Get the Block ID for this chest (for determining chest type)
+     * 
+     * @return Block ID 
+     */
+	 @Deprecated
+	public int getBlockId();
+
+	/**
+	 * Get the block associated with this chest
+	 * @return a block
+	 */
+	public MC_Block getBlock();
+}
diff --git a/src/main/java/PluginReference/MC_Chunk.java b/src/main/java/PluginReference/MC_Chunk.java
new file mode 100644
index 0000000000000000000000000000000000000000..54e44a442c835464cf7beb265fed8174db2545b0
--- /dev/null
+++ b/src/main/java/PluginReference/MC_Chunk.java
@@ -0,0 +1,21 @@
+package PluginReference;
+
+/** 
+ * Interface representing a Chunk
+ */ 			
+public interface MC_Chunk
+{
+	 /** 
+     * Get Chunk X Coordinate
+     * 
+     * @return Chunk X Coordinate (i.e. x &gt;&gt; 4)
+     */ 			
+	public int getCX();
+
+	 /** 
+     * Get Chunk Z Coordinate
+     * 
+     * @return Chunk Z Coordinate (i.e. z &gt;&gt; 4)
+     */ 			
+	public int getCZ();
+}
diff --git a/src/main/java/PluginReference/MC_Command.java b/src/main/java/PluginReference/MC_Command.java
new file mode 100644
index 0000000000000000000000000000000000000000..f10269a47b90523970a797bd37f529dbf154fc25
--- /dev/null
+++ b/src/main/java/PluginReference/MC_Command.java
@@ -0,0 +1,58 @@
+package PluginReference;
+
+import java.util.List;
+
+/** 
+ * Interface representing a Command object
+ */ 			
+public interface MC_Command
+{
+	 /** 
+     * Get the command name.
+     * 
+     * @return Command name. 
+     */ 		
+	public String getCommandName();
+	 /** 
+     * Get aliases for this command (if any)
+     * 
+     * @return List of aliases 
+     */ 		
+	public List<String> getAliases();
+	
+	 /** 
+     * Get string that appears when user does /help
+     * 
+     * @param plr Player Object
+     * @return Help text 
+     */ 		
+	public String getHelpLine(MC_Player plr);
+	
+	 /** 
+     * Called when user runs command registered for this instance
+     * 
+     * @param plr Player object, null if non-player (like Console)
+     * @param args List of parameters
+     */ 		
+	public void handleCommand(MC_Player plr, String[] args);
+
+	 /** 
+     * Called to check if user has permission to this command.
+     * 
+     * @param plr Player Object
+     * @return True if has permission, False otherwise. 
+     */ 			
+	public boolean hasPermissionToUse(MC_Player plr);
+
+	 /** 
+     * Called when user uses [tab] key with your command.
+     * 
+     * @param plr Player Object
+     * @param args Current arguments being passed
+     * @return Help text 
+     */ 		
+	public List<String> getTabCompletionList(MC_Player plr, String[] args);
+	
+	
+}
+
diff --git a/src/main/java/PluginReference/MC_CommandSenderInfo.java b/src/main/java/PluginReference/MC_CommandSenderInfo.java
new file mode 100644
index 0000000000000000000000000000000000000000..894ad4f5d3b9d80fd6f3a089c303c3eb060d048c
--- /dev/null
+++ b/src/main/java/PluginReference/MC_CommandSenderInfo.java
@@ -0,0 +1,7 @@
+package PluginReference;
+
+public class MC_CommandSenderInfo
+{
+	public String lastCommand = "";
+	public MC_CommandSenderType senderType;
+}
diff --git a/src/main/java/PluginReference/MC_CommandSenderType.java b/src/main/java/PluginReference/MC_CommandSenderType.java
new file mode 100644
index 0000000000000000000000000000000000000000..b988ec20a9a49f51dd072d26c0127eb9d872e071
--- /dev/null
+++ b/src/main/java/PluginReference/MC_CommandSenderType.java
@@ -0,0 +1,11 @@
+package PluginReference;
+
+public enum MC_CommandSenderType
+{
+	UNSPECIFIED,
+	PLAYER,
+	CONSOLE,
+	COMMANDBLOCK,
+	ENTITY,
+	RCON
+}
diff --git a/src/main/java/PluginReference/MC_Container.java b/src/main/java/PluginReference/MC_Container.java
new file mode 100644
index 0000000000000000000000000000000000000000..21fe4dfe4bd563ed29e9c552bcaaf48fe904d211
--- /dev/null
+++ b/src/main/java/PluginReference/MC_Container.java
@@ -0,0 +1,40 @@
+package PluginReference;
+
+/** 
+ * Interface representing a Container
+ */ 			
+public interface MC_Container
+{
+	 /** 
+     * Gets the size of the container (how many items it holds)
+     * 
+     * @return Size of container 
+     */ 		
+	public int getSize();
+	
+	/** 
+     * Get item at specified position (index) within container
+     *
+     * @param idx Index of item
+     * @return Item at specified index 
+     */ 		
+	public MC_ItemStack getItemAtIdx(int idx);
+
+	
+	 /** 
+     * Set item at specified position (index) within container
+     *
+     * @param idx Index of item
+     * @param is Item to set
+     */ 		
+	public void setItemAtIdx(int idx, MC_ItemStack is);
+	
+	
+	 /** 
+     * Clear contents of container
+     */ 		
+	public void clearContents();
+
+
+	//public MC_ContainerType getContainerType();
+}
diff --git a/src/main/java/PluginReference/MC_ContainerType.java b/src/main/java/PluginReference/MC_ContainerType.java
new file mode 100644
index 0000000000000000000000000000000000000000..ed65bc39c8b470dba36c276cd49bd46d4555214e
--- /dev/null
+++ b/src/main/java/PluginReference/MC_ContainerType.java
@@ -0,0 +1,36 @@
+package PluginReference;
+
+/** 
+ * Minecraft Container Types
+ */ 			
+public enum MC_ContainerType
+{
+	UNSPECIFIED,
+	
+	PLAYER_INVENTORY,
+	BACKPACK,
+	
+	CHEST_SINGLE,
+	CHEST_DOUBLE,
+	CHEST_TRAPPED,
+	CHEST_ENDER,
+	CHEST_HORSE,
+
+	MINECART_CHEST,
+	MINECART_HOPPER,
+
+	HOPPER,
+	DROPPER,
+	DISPENSER,
+	BREWING_STAND,
+	CRAFTING_TABLE,
+
+	ANVIL,
+	BEACON,
+	FURNACE,
+	ENCHANTING_TABLE,
+	
+	VILLAGER
+	
+}
+
diff --git a/src/main/java/PluginReference/MC_DamageType.java b/src/main/java/PluginReference/MC_DamageType.java
new file mode 100644
index 0000000000000000000000000000000000000000..8f35f8b0288b4e15eb8fe2fec998ac8b95138e7a
--- /dev/null
+++ b/src/main/java/PluginReference/MC_DamageType.java
@@ -0,0 +1,38 @@
+package PluginReference;
+
+/** 
+ * Damage Types
+ */ 			
+public enum MC_DamageType {
+	UNSPECIFIED,
+	IN_FIRE,
+	LIGHTING_BOLT,
+	ON_FIRE,
+	LAVA,
+	IN_WALL,
+	DROWN,
+	STARVE,
+	CACTUS,
+	FALL,
+	OUT_OF_WORLD,
+	GENERIC,
+	MAGIC,
+	WITHER,
+	ANVIL,
+	FALLING_BLOCK,
+    HOT_FLOOR,
+    DRAGON_BREATH,
+    CRAMMING,
+    FLY_INTO_WALL,
+    FIREWORKS,
+
+	MOB,
+	PLAYER,
+	ARROW,
+	FIREBALL,
+	THROWN,
+	INDIRECT_MAGIC,
+	THORNS,
+	EXPLOSION,
+	EXPLOSION_PLAYER
+}
diff --git a/src/main/java/PluginReference/MC_DimensionType.java b/src/main/java/PluginReference/MC_DimensionType.java
new file mode 100644
index 0000000000000000000000000000000000000000..1b0fa202b07d2c7b809ade294b5421940395a7ef
--- /dev/null
+++ b/src/main/java/PluginReference/MC_DimensionType.java
@@ -0,0 +1,8 @@
+package PluginReference;
+
+public class MC_DimensionType
+{
+	public static int OVERWORLD = 0; 
+	public static int NETHER = -1;
+	public static int THE_END = 1;
+}
diff --git a/src/main/java/PluginReference/MC_DirectionNESWUD.java b/src/main/java/PluginReference/MC_DirectionNESWUD.java
new file mode 100644
index 0000000000000000000000000000000000000000..ff64edd714ce2b83553c4f4325304e7a32e99474
--- /dev/null
+++ b/src/main/java/PluginReference/MC_DirectionNESWUD.java
@@ -0,0 +1,16 @@
+package PluginReference;
+
+/** 
+ * Direction
+ */ 			
+public enum MC_DirectionNESWUD
+{
+	UNSPECIFIED,
+	DOWN,
+	UP,
+	NORTH,
+	SOUTH,
+	WEST,
+	EAST
+
+}
diff --git a/src/main/java/PluginReference/MC_Enchantment.java b/src/main/java/PluginReference/MC_Enchantment.java
new file mode 100644
index 0000000000000000000000000000000000000000..5e11eb99360ff58cc3827b3769ae53741f26c6a2
--- /dev/null
+++ b/src/main/java/PluginReference/MC_Enchantment.java
@@ -0,0 +1,16 @@
+package PluginReference;
+
+/** 
+ * Represents an Item Enchantment
+ */ 			
+public class MC_Enchantment
+{
+	public MC_EnchantmentType type = MC_EnchantmentType.UNKNOWN;
+	public int level = 0;
+	
+	public MC_Enchantment(MC_EnchantmentType argType, int argLevel)
+	{
+		type = argType;
+		level = argLevel;
+	}
+}
diff --git a/src/main/java/PluginReference/MC_EnchantmentType.java b/src/main/java/PluginReference/MC_EnchantmentType.java
new file mode 100644
index 0000000000000000000000000000000000000000..a7ac9e722bb7a9f2bef20aa805d9380c8a21fda3
--- /dev/null
+++ b/src/main/java/PluginReference/MC_EnchantmentType.java
@@ -0,0 +1,39 @@
+package PluginReference;
+
+/** 
+ * Type of Item Enchantment
+ */ 			
+public enum MC_EnchantmentType
+{
+	PROTECTION,
+	FIRE_PROTECTION,
+	FEATHER_FALLING,
+	BLAST_PROTECTION,
+	PROJECTILE_PROTECTION,
+	RESPIRATION,
+	AQUA_AFFINITY,
+	THORNS,
+	DEPTH_STRIDER,
+	FROST_WALKER,
+	CURSE_OF_BINDING,
+	SHARPNESS,
+	SMITE,
+	BANE_OF_ARTHROPODS,
+	KNOCKBACK,
+	FIRE_ASPECT,
+	LOOTING,
+	SWEEPING,
+	EFFICIENCY,
+	SILK_TOUCH,
+	UNBREAKING,
+	FORTUNE,
+	POWER,
+	PUNCH,
+	FLAME,
+	INFINITY,
+	LUCK_OF_THE_SEA,
+	LURE,
+	MENDING,
+	CURSE_OF_VANISHING,
+	UNKNOWN
+}
diff --git a/src/main/java/PluginReference/MC_Enderman.java b/src/main/java/PluginReference/MC_Enderman.java
new file mode 100644
index 0000000000000000000000000000000000000000..e5868b4b9022367f341f143abc87fdd08a5a7cf7
--- /dev/null
+++ b/src/main/java/PluginReference/MC_Enderman.java
@@ -0,0 +1,21 @@
+package PluginReference;
+
+/** 
+ * Represents a Minecraft Enderman
+ */ 			
+public interface MC_Enderman extends MC_LivingEntity
+{
+	 /** 
+     * Get carried block
+     *
+     * @return Carried block
+     */ 		
+	public MC_Block getCarriedBlock();
+
+	/** 
+     * Set carried block
+     *
+     * @param blk Carried block
+     */ 		
+	public void setCarriedBlock(MC_Block blk);
+}
diff --git a/src/main/java/PluginReference/MC_Entity.java b/src/main/java/PluginReference/MC_Entity.java
new file mode 100644
index 0000000000000000000000000000000000000000..db84cdadc93d3e073f3150ed2abac3367119f4d0
--- /dev/null
+++ b/src/main/java/PluginReference/MC_Entity.java
@@ -0,0 +1,333 @@
+package PluginReference;
+
+import java.util.List;
+import java.util.UUID;
+
+/** 
+ * Interface for an Entity
+ */ 			
+public interface MC_Entity 
+{
+	 /**
+     * Gets name of this entity
+     * 
+     * @return Entity Name 
+     */ 			
+	public String getName();
+	
+	 /** 
+     * Gets location of entity
+     * 
+     * @return Location of entity 
+     */ 				
+	public MC_Location getLocation();
+	
+	 /** 
+     * Gets World object this entity is in.
+     * 
+     * @return World object 
+     */ 				
+	public MC_World getWorld();
+	
+	 /** 
+     * Gets Entity Type
+     * @return Entity Type 
+     */ 			
+	public MC_EntityType getType();
+	 /** 
+     * Check if entity is sneaking
+     * @return True if sneaking, False otherwise
+     */ 		
+	public boolean isSneaking();
+	 /** 
+     * Check if entity is sprinting
+     * @return True if sprinting, False otherwise
+     */ 		
+	public boolean isSprinting();
+	 /** 
+     * Check if entity is invisible
+     * @return True if invisible, False otherwise
+     */ 		
+	public boolean isInvisible();
+	 /** 
+     * Sets entity as invisible
+     * 
+     * @param flag True for Invisible, False for Visible
+     */ 		
+	public void setInvisible(boolean flag);
+
+	// Life/Death
+	 /** 
+     * Check if entity is dead
+     * @return True if dead, False otherwise
+     */ 		
+	public boolean isDead();	
+	 /** 
+     * Kills entity with max damage (drops items)
+     */ 			
+	public void kill();
+
+	 /** 
+     * Get Vehicle entity
+     * 
+     * @return Vehicle entity or NULL if none. 
+     */ 			
+	public MC_Entity getVehicle();
+	 /** 
+     * Get Rider entity
+     * 
+     * @return Rider entity or NULL if none. 
+     */ 			
+	public MC_Entity getRider();
+	 /** 
+     * Sets the entity as a rider for this entity
+     * 
+     * @param ent Entity to set as rider
+     */ 		
+	public void setRider(MC_Entity ent);
+	 /** 
+     * Sets the entity as a vehicle for this entity
+     * 
+     * @param ent Entity to set as vehicle
+     */ 		
+	public void setVehicle(MC_Entity ent);
+	
+	 /** 
+     * Get Armor as a list of Items
+     * 
+     * @return List of armor (3=hat, 2=chest, 1=legs, 0=boots).    
+     */ 			
+	public List<MC_ItemStack> getArmor();
+	 /** 
+     * Sets the armor for this entity
+     * 
+     * @param items List of armor (3=hat, 2=chest, 1=legs, 0=boots)
+     */ 		
+	public void setArmor(List<MC_ItemStack> items);
+	
+	 /** 
+     * Internal Use Only, Not Documented
+     * 
+     * @return Undocumented    
+     */ 			
+	public String internalInfo();
+	
+	 /** 
+     * Get Number of ticks (1/20th second) entity is on fire
+     * 
+     * @return Number of ticks    
+     */ 			
+	public int getFireTicks();
+	 /** 
+     * Sets number of ticks to stay on fire
+     * 
+     * @param val Number of Ticks
+     */ 		
+	public void setFireTicks(int val);
+	
+	 /** 
+     * Gets motion-related data for this entity
+     * 
+     * @return Motion Related data structure    
+     */ 			
+	public MC_MotionData getMotionData();
+	 /** 
+     * Sets various motion fields for a player
+     * 
+     * @param data Motion data
+     */ 		
+	public void setMotionData(MC_MotionData data);
+	
+	 /** 
+     * Check if entity has a custom name
+     * @return True if has a custom name, False otherwise
+     */ 		
+	public boolean hasCustomName();
+	 /** 
+     * Sets custom name for this entity
+     * 
+     * @param str Custom Name
+     */ 		
+	public void setCustomName(String str);
+	 /** 
+     * Gets custom name for this entity
+     * 
+     * @return Custom name    
+     */ 			
+	public String getCustomName();
+
+	// Basic Info
+	UUID getUUID();
+
+	/**
+    * Teleports a player somewhere
+    *
+    * @param loc Location to teleport
+    */
+	void teleport(MC_Location loc);
+
+	/**
+	 * Teleports a player somewhere
+	 *
+	 * @param loc Location to teleport
+	 * @param safe if true the player will be teleported to a nearby safe
+	 *             location if you try to teleport the player into a wall
+	 */
+	void teleport(MC_Location loc, boolean safe);
+
+	/**
+     * Get Current health of this entity
+     * 
+     * @return Health Value    
+     */ 			
+	public float getHealth();
+	 /** 
+     * Sets current health (won't exceed maximum).
+     * 
+     * @param argHealth Health value
+     */ 		
+	public void setHealth(float argHealth);
+	 /** 
+     * Get Maximum Health of this entity
+     * 
+     * @return Maximum Health    
+     */ 			
+	public float getMaxHealth();
+	 /** 
+     * Sets maximum health
+     * 
+     * @param argHealth Health value
+     */ 		
+	public void setMaxHealth(float argHealth);
+
+	/**
+	 * Get base armor score (doesn't include enchantments, potion effects, etc).
+	 * Full set of diamond armor is 20. 
+	 * Full set of iron armor is 15. 
+	 * Full set of chain armor is 12. 
+	 * Full set of gold armor is 11. 
+	 * Full set of leather armor is 7. 
+     * @return Base armor score (as of 1.8, a number between 0 and 20)    
+	 */
+	public int getBaseArmorScore();
+
+	/**
+	 * Get damage amount after armor applied
+	 *
+     * @param dmgType Type of damage (some types go through armor)
+     * @param dmg Amount of damage before armor considered
+     * @return Armor adjusted damage value    
+	 */
+	public float getArmorAdjustedDamage(MC_DamageType dmgType, float dmg);
+
+	/**
+	 * Get total damage amount after armor, absorption, effects, and enchantments applied
+	 *
+     * @param dmgType Type of damage (some types go through armor)
+     * @param dmg Amount of damage before armor considered
+     * @return Total adjusted damage value
+	 */
+	public float getTotalAdjustedDamage(MC_DamageType dmgType, float dmg);
+	
+	/**
+	 * Gets absorption amount (used up before damage applies, like a shield value)
+	 *
+     * @return Absorption amount    
+	 */
+	public float getAbsorptionAmount();
+	/**
+	 * Sets absorption amount
+	 *
+     * @param val New absorption value
+	 */
+	public void setAbsorptionAmount(float val);
+	
+	/**
+	 * Sets number of arrows sticking out. Up to 127.
+	 *
+     * @param numArrows Number of arrows
+	 */
+	public void setNumberOfArrowsHitWith(int numArrows);
+
+	 /** 
+     * Gets attacker (valid during certain events like onAttemptEntityDamage)
+     * 
+     * @return Attacking entity 
+     */ 			
+	public MC_Entity getAttacker();
+
+	 /** 
+     * Gets the active potion effects on this entity
+     * 
+     * @return List of potion effects 
+     */ 			
+	public List<MC_PotionEffect> getPotionEffects();
+
+	 /** 
+     * Sets the active potion effects on this entity. Use null or empty list to cancel all potion effects
+     * 
+     * @param potionEffects List of potion effects
+     */ 			
+	public void  setPotionEffects(List<MC_PotionEffect> potionEffects);
+
+	/** 
+     * Sets adjusted damage if called from onAttemptEntityDamage
+     * 
+     * @param dmg Damage value
+     */ 			
+	public void setAdjustedIncomingDamage(float dmg);
+
+	/** 
+     * Returns an integer ID representing this entity.
+     * 
+     * @return Entity ID
+     */ 			
+	public int getEntityId();
+	
+
+	 /** 
+     * Gets a list of nearby entities (up to a specified radius)
+     * 
+     * @param radius Euclidean Radius in Blocks
+     * @return List of entities 
+     */ 			
+	public List<MC_Entity> getNearbyEntities(float radius);
+
+	/** 
+     * Removes entity (no item drops).  Ignores player entities.
+     */ 			
+	public void removeEntity();
+
+	 /** 
+     * Get Riders
+     * 
+     * @return List of Rider entity or NULL if none. 
+     */ 			
+	public List<MC_Entity> getRiders();
+
+	 /** 
+     * Add a rider
+     * 
+     * @param ent Entity to set as rider
+     */ 		
+	public void addRider(MC_Entity ent);
+
+	 /** 
+     * Remove a rider
+     * 
+     * @param ent Entity to set as rider
+     */ 		
+	public void removeRider(MC_Entity ent);
+
+    /**
+     * Serialize an entity to a byte array. Use MC_World.spawnEntity() to create
+     * spawn the entity.
+     *
+     * If you use this on a player an IllegalStateException is thrown.
+     *
+     * @return Byte array representation of the entity.
+     */
+	byte[] serialize();
+	
+}
+
diff --git a/src/main/java/PluginReference/MC_EntityAgeable.java b/src/main/java/PluginReference/MC_EntityAgeable.java
new file mode 100644
index 0000000000000000000000000000000000000000..867d9fb62b53726fe25e09848a2540b7fc63fa3f
--- /dev/null
+++ b/src/main/java/PluginReference/MC_EntityAgeable.java
@@ -0,0 +1,21 @@
+package PluginReference;
+
+/** 
+ * Interface for an Entity supporting aging.
+ */ 			
+public interface MC_EntityAgeable extends MC_LivingEntity
+{
+	 /** 
+     * Get the age value
+     * 
+     * @return Age (-1=baby, 1=adult)  
+     */ 		
+	public int getAge();
+	
+	 /** 
+     * Sets age of entity
+     * 
+     * @param idx Age (-1=baby, 1=adult)
+     */ 		
+	public void setAge(int idx); 
+}
diff --git a/src/main/java/PluginReference/MC_EntityType.java b/src/main/java/PluginReference/MC_EntityType.java
new file mode 100644
index 0000000000000000000000000000000000000000..252502c5e334e8510f04ec3ea286f9a60eb3d4fe
--- /dev/null
+++ b/src/main/java/PluginReference/MC_EntityType.java
@@ -0,0 +1,122 @@
+package PluginReference;
+
+/**
+ * Entity Type
+ */
+public enum MC_EntityType {
+    UNSPECIFIED,
+	PLAYER,
+
+	// Normal Mobs
+	BAT,
+	CHICKEN,
+	COW,
+	HORSE,
+	MUSHROOM_COW,
+	OCELOT,
+	PIG,
+	RABBIT,
+	SHEEP,
+	SNOWMAN,
+	SQUID,
+	VILLAGER_GOLEM,
+	WOLF,
+	VILLAGER,
+	ENDERDRAGON,
+	WITHERBOSS,
+	BLAZE,
+	CAVE_SPIDER,
+	CREEPER,
+	ENDERMAN,
+	ENDERMITE,
+	GHAST,
+	GIANT,
+	GUARDIAN,
+	LAVA_SLIME,
+	PIG_ZOMBIE,
+	SILVERFISH,
+	SKELETON,
+	SLIME,
+	SPIDER,
+	WITCH,
+	ZOMBIE,
+	
+	// Special Mobs...
+	FISHING_HOOK,
+	ARROW,
+	SMALL_FIREBALL,
+	FIREBALL,
+	SNOWBALL,
+	THROWN_ENDERPEARL,
+	EYE_OF_ENDER_SIGNAL,
+	THROWN_EGG,
+	THROWN_POTION,
+	THROWN_EXP_BOTTLE,
+	FIREWORK,
+	ITEM,
+	MINECART,
+	BOAT,
+	PRIMED_TNT,
+	FALLING_SAND,
+	@Deprecated
+	HANGING, // i.e. painting, item_frame
+	ARMOR_STAND,
+	XP_ORB,
+	ENDER_CRYSTAL,
+	WITHER_SKULL,
+	
+	// Added during 1.9
+	LEASH_KNOT, 
+	PAINTING,
+	ITEM_FRAME, 
+	LIGHTNING_BOLT, // note: the above (Leash, Painting, Frames, ...) obvious before 1.9 but added as specific entities rather than just 'hanging' ones
+	SHULKER,
+	SHULKER_BULLET,
+	AREA_EFFECT_CLOUD,
+    SPECTRAL_ARROW,
+    DRAGON_FIREBALL,
+
+    // Added in 1.10
+    POLAR_BEAR,
+
+	// Added in 1.11
+    // Subtypes of previous entities that are now full entities
+    ZOMBIE_HORSE,
+    SKELETON_HORSE,
+    DONKEY,
+    MULE,
+    HUSK,
+    ZOMBIE_VILLAGER,
+    STRAY,
+    WHITHER_SKELETON,
+    ELDER_GUARDIAN,
+	MINECART_CHEST,
+	MINECART_FURNACE,
+	MINECART_TNT,
+	MINECART_HOPPER,
+	MINECART_SPAWNER,
+
+    // new entities
+    EVOCATION_FANGS,
+    EVOKER,
+    VEX,
+    LLAMA,
+    VINDICATOR,
+
+	// Added in 1.12
+	ILLUSIONER,
+	PARROT,
+
+	// Added in 1.13
+	COD,
+	DOLPHIN,
+	DROWNED,
+	LLAMA_SPIT,
+	MINECART_COMMAND_BLOCK,
+	PUFFER_FISH,
+	SALMON,
+	TROPICAL_FISH,
+	TURTLE,
+	PHANTOM,
+	TRIDENT,
+}
diff --git a/src/main/java/PluginReference/MC_EventInfo.java b/src/main/java/PluginReference/MC_EventInfo.java
new file mode 100644
index 0000000000000000000000000000000000000000..56cd59d587cdcfec3b0bc1b231603efe9d515f3b
--- /dev/null
+++ b/src/main/java/PluginReference/MC_EventInfo.java
@@ -0,0 +1,20 @@
+package PluginReference;
+
+/** 
+ * Event Info w/option to cancel
+ */ 			
+public class MC_EventInfo
+{
+	/** 
+	 * Set to TRUE if event is cancelled.
+	 */ 			
+	public boolean isCancelled = false;
+	/** 
+	 * Internal value, only set where explicitly documented.
+	 */ 			
+	public String tag = null;
+	/** 
+	 * Indicates event parameters (such as lists) were modified.
+	 */ 			
+	public boolean isModified = false;
+}
diff --git a/src/main/java/PluginReference/MC_EventInfoPacket.java b/src/main/java/PluginReference/MC_EventInfoPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..53b786c42244454dc4c14d078879ff3478f3eb96
--- /dev/null
+++ b/src/main/java/PluginReference/MC_EventInfoPacket.java
@@ -0,0 +1,6 @@
+package PluginReference;
+
+public class MC_EventInfoPacket extends MC_EventInfo
+{
+	public Object packetObject = null;
+}
diff --git a/src/main/java/PluginReference/MC_FloatTriplet.java b/src/main/java/PluginReference/MC_FloatTriplet.java
new file mode 100644
index 0000000000000000000000000000000000000000..14d2556bbf3ffebfb904f97619b5983805f1d1a8
--- /dev/null
+++ b/src/main/java/PluginReference/MC_FloatTriplet.java
@@ -0,0 +1,15 @@
+package PluginReference;
+
+public class MC_FloatTriplet
+{
+	public float x;
+	public float y;
+	public float z;
+	
+	public MC_FloatTriplet(float argX, float argY, float argZ)
+	{
+		x = argX;
+		y = argY;
+		z = argZ;
+	}
+}
diff --git a/src/main/java/PluginReference/MC_GameMode.java b/src/main/java/PluginReference/MC_GameMode.java
new file mode 100644
index 0000000000000000000000000000000000000000..4cd992abdc9d00e4062ff756d65372f80d608fb8
--- /dev/null
+++ b/src/main/java/PluginReference/MC_GameMode.java
@@ -0,0 +1,12 @@
+package PluginReference;
+
+/** 
+ * Player GameMode
+ */ 			
+public enum MC_GameMode {
+	UNKNOWN,
+	SURVIVAL,
+	CREATIVE,
+	ADVENTURE,
+	SPECTATOR
+}
diff --git a/src/main/java/PluginReference/MC_GameRuleType.java b/src/main/java/PluginReference/MC_GameRuleType.java
new file mode 100644
index 0000000000000000000000000000000000000000..6df03bc83bca155979e37b4036f29c6f8638b8ab
--- /dev/null
+++ b/src/main/java/PluginReference/MC_GameRuleType.java
@@ -0,0 +1,28 @@
+package PluginReference;
+
+/** 
+ * GameRule Type
+ */ 			
+public enum MC_GameRuleType
+{
+	UNSPECIFIED,
+	DO_FIRE_TICK,
+	MOB_GRIEFING,
+	KEEP_INVENTORY,
+	DO_MOB_SPAWNING,
+	DO_MOB_LOOT,
+	DO_TILE_DROPS,
+	COMMAND_BLOCK_OUTPUT,
+	NATURAL_REGENERATION,
+	DO_DAYLIGHT_CYCLE,
+	LOG_ADMIN_COMMANDS,
+	SHOW_DEATH_MESSAGES,
+	SEND_COMMAND_FEEDBACK,
+	REDUCED_DEBUG_INFO,
+	DO_ENTITY_DROPS,
+	SPECTATORS_GENERATE_CHUNKS,
+	DISABLE_ELYTRA_MOVEMENT_CHECK,
+	DO_WEATHER_CYCLE,
+	DO_LIMITED_CRAFTING,
+    ANNOUNCE_ADVANCEMENTS
+}
diff --git a/src/main/java/PluginReference/MC_GeneratedColumn.java b/src/main/java/PluginReference/MC_GeneratedColumn.java
new file mode 100644
index 0000000000000000000000000000000000000000..eb7536f9a2db7e27761fca08312c60d717a83758
--- /dev/null
+++ b/src/main/java/PluginReference/MC_GeneratedColumn.java
@@ -0,0 +1,14 @@
+package PluginReference;
+
+/** 
+ * Interface for controlling world column generation
+ */ 			
+public interface MC_GeneratedColumn
+{
+	 /** 
+     * Called when a new world column is generated.
+     * 
+     * @param arr Column block data
+     */ 		
+	public void setData(short[] arr);
+}
diff --git a/src/main/java/PluginReference/MC_Hand.java b/src/main/java/PluginReference/MC_Hand.java
new file mode 100644
index 0000000000000000000000000000000000000000..3c31e22eda66bb7de73c0e827f374562846136fb
--- /dev/null
+++ b/src/main/java/PluginReference/MC_Hand.java
@@ -0,0 +1,5 @@
+package PluginReference;
+
+public enum MC_Hand {
+    MAIN_HAND, OFF_HAND
+}
diff --git a/src/main/java/PluginReference/MC_HangingEntityType.java b/src/main/java/PluginReference/MC_HangingEntityType.java
new file mode 100644
index 0000000000000000000000000000000000000000..9127191b31a8d49ac438d5abb82cd6b4dd966e48
--- /dev/null
+++ b/src/main/java/PluginReference/MC_HangingEntityType.java
@@ -0,0 +1,12 @@
+package PluginReference;
+
+/** 
+ * Hanging Entity Type
+ */ 			
+public enum MC_HangingEntityType
+{
+	UNSPECIFIED,
+	ITEM_FRAME,
+	LEASH_KNOT,
+	PAINTING
+}
diff --git a/src/main/java/PluginReference/MC_Horse.java b/src/main/java/PluginReference/MC_Horse.java
new file mode 100644
index 0000000000000000000000000000000000000000..57b6a8fdeaca9cf93cc9586dd791a446fe4aad20
--- /dev/null
+++ b/src/main/java/PluginReference/MC_Horse.java
@@ -0,0 +1,98 @@
+package PluginReference;
+
+/**
+ * Horse Entity
+ */
+public interface MC_Horse extends MC_Animal {
+    @Deprecated
+    MC_HorseType getHorseType();
+
+    /**
+     * Sets the horse type (Horse, Donkey, etc)
+     *
+     * @param arg Horse Type
+     */
+    @Deprecated
+    void setHorseType(MC_HorseType arg);
+
+    /**
+     * Get Horse Variant
+     *
+     * @return Horse Variant
+     */
+    MC_HorseVariant getHorseVariant();
+
+    /**
+     * Sets the horse variant (Chestnut, Creamy, etc)
+     *
+     * @param arg Horse Variant
+     */
+    void setHorseVariant(MC_HorseVariant arg);
+
+    /**
+     * Check if horse has chest
+     *
+     * @return True if has chest, False otherwise
+     * @deprecated Not all horse types may have a chest
+     */
+    @Deprecated
+    boolean hasChest();
+
+    /**
+     * Sets whether horse has chest
+     *
+     * @param flag True for chest, False otherwise
+     * @deprecated Not all horse types may have a chest
+     */
+    @Deprecated
+    void setHasChest(boolean flag);
+
+    /**
+     * Sets whether horse is tamed.
+     *
+     * @param flag True for tamed, False otherwise
+     */
+    void setTamed(boolean flag);
+
+    /**
+     * Check if horse is tamed
+     *
+     * @return True if horse is tamed, False otherwise
+     */
+    boolean isTame();
+
+    /**
+     * Gets temper of Horse
+     *
+     * @return Temper value
+     */
+    int getTemper();
+
+    /**
+     * Sets temper of horse
+     *
+     * @param val New Temper
+     */
+    void setTemper(int val);
+
+    /**
+     * Gets Owner UUID
+     *
+     * @return UUID of owner
+     */
+    String getOwnerUUID();
+
+    /**
+     * Sets Owning UUID
+     *
+     * @param strUUID UUID of owner
+     */
+    void setOwnerUUID(String strUUID);
+
+    /**
+     * Sets Owning Player
+     *
+     * @param plr Player Object
+     */
+    void setOwner(MC_Player plr);
+}
diff --git a/src/main/java/PluginReference/MC_HorseType.java b/src/main/java/PluginReference/MC_HorseType.java
new file mode 100644
index 0000000000000000000000000000000000000000..80d460072b02074015138e5cff5283c536861802
--- /dev/null
+++ b/src/main/java/PluginReference/MC_HorseType.java
@@ -0,0 +1,15 @@
+package PluginReference;
+
+/**
+ * Horse Type
+ */
+@Deprecated
+public enum MC_HorseType {
+    HORSE,
+    DONKEY,
+    MULE,
+    ZOMBIE,
+    SKELETON,
+    LLAMA,
+    UNKNOWN
+}
diff --git a/src/main/java/PluginReference/MC_HorseVariant.java b/src/main/java/PluginReference/MC_HorseVariant.java
new file mode 100644
index 0000000000000000000000000000000000000000..8ef85d57e23f54fb6f395069d371c433aa2ba7e4
--- /dev/null
+++ b/src/main/java/PluginReference/MC_HorseVariant.java
@@ -0,0 +1,17 @@
+package PluginReference;
+
+/** 
+ * Horse Variant
+ */ 			
+public enum MC_HorseVariant
+{
+	WHITE,
+	CREAMY,
+	CHESTNUT,
+	BROWN,
+	BLACK,
+	GRAY,
+	DARK_BROWN,
+	UNKNOWN
+}
+
diff --git a/src/main/java/PluginReference/MC_ID.java b/src/main/java/PluginReference/MC_ID.java
new file mode 100644
index 0000000000000000000000000000000000000000..aa2d441d922b722c8495fb77677663538dafe897
--- /dev/null
+++ b/src/main/java/PluginReference/MC_ID.java
@@ -0,0 +1,469 @@
+package PluginReference;
+
+/** 
+ * Convenience variables to use instead of Minecraft IDs
+ */
+@Deprecated
+public final class MC_ID
+{
+	public static final int AIR = 0;
+	public static final int BLOCK_STONE = 1;
+	public static final int BLOCK_GRASS = 2;
+	public static final int BLOCK_DIRT = 3;
+	public static final int BLOCK_COBBLESTONE = 4;
+	public static final int BLOCK_PLANKS = 5;
+	public static final int BLOCK_SAPLING = 6;
+	public static final int BLOCK_BEDROCK = 7;
+	public static final int BLOCK_FLOWING_WATER = 8;
+	public static final int BLOCK_WATER = 9;
+	public static final int BLOCK_FLOWING_LAVA = 10;
+	public static final int BLOCK_LAVA = 11;
+	public static final int BLOCK_SAND = 12;
+	public static final int BLOCK_GRAVEL = 13;
+	public static final int BLOCK_GOLD_ORE = 14;
+	public static final int BLOCK_IRON_ORE = 15;
+	public static final int BLOCK_COAL_ORE = 16;
+	public static final int BLOCK_LOG = 17;
+	public static final int BLOCK_LEAVES = 18;
+	public static final int BLOCK_SPONGE = 19;
+	public static final int BLOCK_GLASS = 20;
+	public static final int BLOCK_LAPIS_ORE = 21;
+	public static final int BLOCK_LAPIS_BLOCK = 22;
+	public static final int BLOCK_DISPENSER = 23;
+	public static final int BLOCK_SANDSTONE = 24;
+	public static final int BLOCK_NOTEBLOCK = 25;
+	public static final int BLOCK_BED = 26;
+	public static final int BLOCK_GOLDEN_RAIL = 27;
+	public static final int BLOCK_DETECTOR_RAIL = 28;
+	public static final int BLOCK_STICKY_PISTON = 29;
+	public static final int BLOCK_WEB = 30;
+	public static final int BLOCK_TALLGRASS = 31;
+	public static final int BLOCK_DEADBUSH = 32;
+	public static final int BLOCK_PISTON = 33;
+	public static final int BLOCK_PISTON_HEAD = 34;
+	public static final int BLOCK_WOOL = 35;
+	public static final int BLOCK_PISTON_EXTENSION = 36;
+	public static final int BLOCK_YELLOW_FLOWER = 37;
+	public static final int BLOCK_RED_FLOWER = 38;
+	public static final int BLOCK_BROWN_MUSHROOM = 39;
+	public static final int BLOCK_RED_MUSHROOM = 40;
+	public static final int BLOCK_GOLD_BLOCK = 41;
+	public static final int BLOCK_IRON_BLOCK = 42;
+	public static final int BLOCK_DOUBLE_STONE_SLAB = 43;
+	public static final int BLOCK_STONE_SLAB = 44;
+	public static final int BLOCK_BRICK_BLOCK = 45;
+	public static final int BLOCK_TNT = 46;
+	public static final int BLOCK_BOOKSHELF = 47;
+	public static final int BLOCK_MOSSY_COBBLESTONE = 48;
+	public static final int BLOCK_OBSIDIAN = 49;
+	public static final int BLOCK_TORCH = 50;
+	public static final int BLOCK_FIRE = 51;
+	public static final int BLOCK_MOB_SPAWNER = 52;
+	public static final int BLOCK_OAK_STAIRS = 53;
+	public static final int BLOCK_CHEST = 54;
+	public static final int BLOCK_REDSTONE_WIRE = 55;
+	public static final int BLOCK_DIAMOND_ORE = 56;
+	public static final int BLOCK_DIAMOND_BLOCK = 57;
+	public static final int BLOCK_CRAFTING_TABLE = 58;
+	public static final int BLOCK_WHEAT = 59;
+	public static final int BLOCK_FARMLAND = 60;
+	public static final int BLOCK_FURNACE = 61;
+	public static final int BLOCK_LIT_FURNACE = 62;
+	public static final int BLOCK_STANDING_SIGN = 63;
+	public static final int BLOCK_WOODEN_DOOR = 64;
+	public static final int BLOCK_LADDER = 65;
+	public static final int BLOCK_RAIL = 66;
+	public static final int BLOCK_STONE_STAIRS = 67;
+	public static final int BLOCK_WALL_SIGN = 68;
+	public static final int BLOCK_LEVER = 69;
+	public static final int BLOCK_STONE_PRESSURE_PLATE = 70;
+	public static final int BLOCK_IRON_DOOR = 71;
+	public static final int BLOCK_WOODEN_PRESSURE_PLATE = 72;
+	public static final int BLOCK_REDSTONE_ORE = 73;
+	public static final int BLOCK_LIT_REDSTONE_ORE = 74;
+	public static final int BLOCK_UNLIT_REDSTONE_TORCH = 75;
+	public static final int BLOCK_REDSTONE_TORCH = 76;
+	public static final int BLOCK_STONE_BUTTON = 77;
+	public static final int BLOCK_SNOW_LAYER = 78;
+	public static final int BLOCK_ICE = 79;
+	public static final int BLOCK_SNOW = 80;
+	public static final int BLOCK_CACTUS = 81;
+	public static final int BLOCK_CLAY = 82;
+	public static final int BLOCK_REEDS = 83;
+	public static final int BLOCK_JUKEBOX = 84;
+	public static final int BLOCK_FENCE = 85;
+	public static final int BLOCK_PUMPKIN = 86;
+	public static final int BLOCK_NETHERRACK = 87;
+	public static final int BLOCK_SOUL_SAND = 88;
+	public static final int BLOCK_GLOWSTONE = 89;
+	public static final int BLOCK_PORTAL = 90;
+	public static final int BLOCK_LIT_PUMPKIN = 91;
+	public static final int BLOCK_CAKE = 92;
+	public static final int BLOCK_UNPOWERED_REPEATER = 93;
+	public static final int BLOCK_POWERED_REPEATER = 94;
+	public static final int BLOCK_STAINED_GLASS = 95;
+	public static final int BLOCK_TRAPDOOR = 96;
+	public static final int BLOCK_MONSTER_EGG = 97;
+	public static final int BLOCK_STONEBRICK = 98;
+	public static final int BLOCK_BROWN_MUSHROOM_BLOCK = 99;
+	public static final int BLOCK_RED_MUSHROOM_BLOCK = 100;
+	public static final int BLOCK_IRON_BARS = 101;
+	public static final int BLOCK_GLASS_PANE = 102;
+	public static final int BLOCK_MELON_BLOCK = 103;
+	public static final int BLOCK_PUMPKIN_STEM = 104;
+	public static final int BLOCK_MELON_STEM = 105;
+	public static final int BLOCK_VINE = 106;
+	public static final int BLOCK_FENCE_GATE = 107;
+	public static final int BLOCK_BRICK_STAIRS = 108;
+	public static final int BLOCK_STONE_BRICK_STAIRS = 109;
+	public static final int BLOCK_MYCELIUM = 110;
+	public static final int BLOCK_WATERLILY = 111;
+	public static final int BLOCK_NETHER_BRICK = 112;
+	public static final int BLOCK_NETHER_BRICK_FENCE = 113;
+	public static final int BLOCK_NETHER_BRICK_STAIRS = 114;
+	public static final int BLOCK_NETHER_WART = 115;
+	public static final int BLOCK_ENCHANTING_TABLE = 116;
+	public static final int BLOCK_BREWING_STAND = 117;
+	public static final int BLOCK_CAULDRON = 118;
+	public static final int BLOCK_END_PORTAL = 119;
+	public static final int BLOCK_END_PORTAL_FRAME = 120;
+	public static final int BLOCK_END_STONE = 121;
+	public static final int BLOCK_DRAGON_EGG = 122;
+	public static final int BLOCK_REDSTONE_LAMP = 123;
+	public static final int BLOCK_LIT_REDSTONE_LAMP = 124;
+	public static final int BLOCK_DOUBLE_WOODEN_SLAB = 125;
+	public static final int BLOCK_WOODEN_SLAB = 126;
+	public static final int BLOCK_COCOA = 127;
+	public static final int BLOCK_SANDSTONE_STAIRS = 128;
+	public static final int BLOCK_EMERALD_ORE = 129;
+	public static final int BLOCK_ENDER_CHEST = 130;
+	public static final int BLOCK_TRIPWIRE_HOOK = 131;
+	public static final int BLOCK_TRIPWIRE = 132;
+	public static final int BLOCK_EMERALD_BLOCK = 133;
+	public static final int BLOCK_SPRUCE_STAIRS = 134;
+	public static final int BLOCK_BIRCH_STAIRS = 135;
+	public static final int BLOCK_JUNGLE_STAIRS = 136;
+	public static final int BLOCK_COMMAND_BLOCK = 137;
+	public static final int BLOCK_BEACON = 138;
+	public static final int BLOCK_COBBLESTONE_WALL = 139;
+	public static final int BLOCK_FLOWER_POT = 140;
+	public static final int BLOCK_CARROTS = 141;
+	public static final int BLOCK_POTATOES = 142;
+	public static final int BLOCK_WOODEN_BUTTON = 143;
+	public static final int BLOCK_SKULL = 144;
+	public static final int BLOCK_ANVIL = 145;
+	public static final int BLOCK_TRAPPED_CHEST = 146;
+	public static final int BLOCK_LIGHT_WEIGHTED_PRESSURE_PLATE = 147;
+	public static final int BLOCK_HEAVY_WEIGHTED_PRESSURE_PLATE = 148;
+	public static final int BLOCK_UNPOWERED_COMPARATOR = 149;
+	public static final int BLOCK_POWERED_COMPARATOR = 150;
+	public static final int BLOCK_DAYLIGHT_DETECTOR = 151;
+	public static final int BLOCK_REDSTONE_BLOCK = 152;
+	public static final int BLOCK_QUARTZ_ORE = 153;
+	public static final int BLOCK_HOPPER = 154;
+	public static final int BLOCK_QUARTZ_BLOCK = 155;
+	public static final int BLOCK_QUARTZ_STAIRS = 156;
+	public static final int BLOCK_ACTIVATOR_RAIL = 157;
+	public static final int BLOCK_DROPPER = 158;
+	public static final int BLOCK_STAINED_HARDENED_CLAY = 159;
+	public static final int BLOCK_STAINED_GLASS_PANE = 160;
+	public static final int BLOCK_LEAVES2 = 161;
+	public static final int BLOCK_LOG2 = 162;
+	public static final int BLOCK_ACACIA_STAIRS = 163;
+	public static final int BLOCK_DARK_OAK_STAIRS = 164;
+	public static final int BLOCK_SLIME = 165;
+	public static final int BLOCK_BARRIER = 166;
+	public static final int BLOCK_IRON_TRAPDOOR = 167;
+	public static final int BLOCK_PRISMARINE = 168;
+	public static final int BLOCK_SEA_LANTERN = 169;
+	public static final int BLOCK_HAY_BLOCK = 170;
+	public static final int BLOCK_CARPET = 171;
+	public static final int BLOCK_HARDENED_CLAY = 172;
+	public static final int BLOCK_COAL_BLOCK = 173;
+	public static final int BLOCK_PACKED_ICE = 174;
+	public static final int BLOCK_DOUBLE_PLANT = 175;
+	public static final int BLOCK_STANDING_BANNER = 176;
+	public static final int BLOCK_WALL_BANNER = 177;
+	public static final int BLOCK_DAYLIGHT_DETECTOR_INVERTED = 178;
+	public static final int BLOCK_RED_SANDSTONE = 179;
+	public static final int BLOCK_RED_SANDSTONE_STAIRS = 180;
+	public static final int BLOCK_DOUBLE_STONE_SLAB2 = 181;
+	public static final int BLOCK_STONE_SLAB2 = 182;
+	public static final int BLOCK_SPRUCE_FENCE_GATE = 183;
+	public static final int BLOCK_BIRCH_FENCE_GATE = 184;
+	public static final int BLOCK_JUNGLE_FENCE_GATE = 185;
+	public static final int BLOCK_DARK_OAK_FENCE_GATE = 186;
+	public static final int BLOCK_ACACIA_FENCE_GATE = 187;
+	public static final int BLOCK_SPRUCE_FENCE = 188;
+	public static final int BLOCK_BIRCH_FENCE = 189;
+	public static final int BLOCK_JUNGLE_FENCE = 190;
+	public static final int BLOCK_DARK_OAK_FENCE = 191;
+	public static final int BLOCK_ACACIA_FENCE = 192;
+	public static final int BLOCK_SPRUCE_DOOR = 193;
+	public static final int BLOCK_BIRCH_DOOR = 194;
+	public static final int BLOCK_JUNGLE_DOOR = 195;
+	public static final int BLOCK_ACACIA_DOOR = 196;
+	public static final int BLOCK_DARK_OAK_DOOR = 197;
+	public static final int BLOCK_END_ROD = 198;
+	public static final int BLOCK_CHORUS_PLANT = 199;
+	public static final int BLOCK_CHORUS_FLOWER = 200;
+	public static final int BLOCK_PURPUR_BLOCK = 201;
+	public static final int BLOCK_PURPUR_PILLAR = 202;
+	public static final int BLOCK_PURPUR_STAIRS = 203;
+	public static final int BLOCK_PURPUR_DOUBLE_SLAB = 204;
+	public static final int BLOCK_PURPUR_SLAB = 205;
+	public static final int BLOCK_END_BRICKS = 206;
+	public static final int BLOCK_BEETROOTS = 207;
+	public static final int BLOCK_GRASS_PATH = 208;
+	public static final int BLOCK_END_GATEWAY = 209;
+	public static final int BLOCK_REPEATING_COMMAND_BLOCK = 210;
+	public static final int BLOCK_CHAIN_COMMAND_BLOCK = 211;
+	public static final int BLOCK_FROSTED_ICE = 212;
+	public static final int BLOCK_MAGMA = 213;
+	public static final int BLOCK_NETHER_WART_BLOCK = 214;
+	public static final int BLOCK_RED_NETHER_BRICK = 215;
+	public static final int BLOCK_BONE_BLOCK = 216;
+	public static final int BLOCK_STRUCTURE_VOID = 217;
+	public static final int BLOCK_OBSERVER = 218;
+	public static final int BLOCK_SHULKER_BOX_WHITE = 219;
+	public static final int BLOCK_SHULKER_BOX_ORANGE = 220;
+	public static final int BLOCK_SHULKER_BOX_MAGENTA = 221;
+	public static final int BLOCK_SHULKER_BOX_LIGHT_BLUE = 222;
+	public static final int BLOCK_SHULKER_BOX_YELLOW = 223;
+	public static final int BLOCK_SHULKER_BOX_LIME = 224;
+	public static final int BLOCK_SHULKER_BOX_PINK = 225;
+	public static final int BLOCK_SHULKER_BOX_GRAY = 226;
+	public static final int BLOCK_SHULKER_BOX_SILVER = 227;
+	public static final int BLOCK_SHULKER_BOX_CYAN = 228;
+	public static final int BLOCK_SHULKER_BOX_PURPLE = 229;
+	public static final int BLOCK_SHULKER_BOX_BLUE = 230;
+	public static final int BLOCK_SHULKER_BOX_BROWN = 231;
+	public static final int BLOCK_SHULKER_BOX_GREEN = 232;
+	public static final int BLOCK_SHULKER_BOX_RED = 233;
+	public static final int BLOCK_SHULKER_BOX_BLACK = 234;
+	public static final int BLOCK_TERRACOTTA_WHITE = 235;
+	public static final int BLOCK_TERRACOTTA_ORANGE = 236;
+	public static final int BLOCK_TERRACOTTA_MAGENTA = 237;
+	public static final int BLOCK_TERRACOTTA_LIGHT_BLUE = 238;
+	public static final int BLOCK_TERRACOTTA_YELLOW = 239;
+	public static final int BLOCK_TERRACOTTA_LIME = 240;
+	public static final int BLOCK_TERRACOTTA_PINK = 241;
+	public static final int BLOCK_TERRACOTTA_GRAY = 242;
+	public static final int BLOCK_TERRACOTTA_SILVER = 243;
+	public static final int BLOCK_TERRACOTTA_CYAN = 244;
+	public static final int BLOCK_TERRACOTTA_PURPLE = 245;
+	public static final int BLOCK_TERRACOTTA_BLUE = 246;
+	public static final int BLOCK_TERRACOTTA_BROWN = 247;
+	public static final int BLOCK_TERRACOTTA_GREEN = 248;
+	public static final int BLOCK_TERRACOTTA_RED = 249;
+	public static final int BLOCK_TERRACOTTA_BLACK = 250;
+	public static final int BLOCK_CONCRETE = 251;
+	public static final int BLOCK_CONCRETE_POWDER = 252;
+	public static final int BLOCK_STRUCTURE_BLOCK = 255;
+	public static final int ITEM_IRON_SHOVEL = 256;
+	public static final int ITEM_IRON_PICKAXE = 257;
+	public static final int ITEM_IRON_AXE = 258;
+	public static final int ITEM_FLINT_AND_STEEL = 259;
+	public static final int ITEM_APPLE = 260;
+	public static final int ITEM_BOW = 261;
+	public static final int ITEM_ARROW = 262;
+	public static final int ITEM_COAL = 263;
+	public static final int ITEM_DIAMOND = 264;
+	public static final int ITEM_IRON_INGOT = 265;
+	public static final int ITEM_GOLD_INGOT = 266;
+	public static final int ITEM_IRON_SWORD = 267;
+	public static final int ITEM_WOODEN_SWORD = 268;
+	public static final int ITEM_WOODEN_SHOVEL = 269;
+	public static final int ITEM_WOODEN_PICKAXE = 270;
+	public static final int ITEM_WOODEN_AXE = 271;
+	public static final int ITEM_STONE_SWORD = 272;
+	public static final int ITEM_STONE_SHOVEL = 273;
+	public static final int ITEM_STONE_PICKAXE = 274;
+	public static final int ITEM_STONE_AXE = 275;
+	public static final int ITEM_DIAMOND_SWORD = 276;
+	public static final int ITEM_DIAMOND_SHOVEL = 277;
+	public static final int ITEM_DIAMOND_PICKAXE = 278;
+	public static final int ITEM_DIAMOND_AXE = 279;
+	public static final int ITEM_STICK = 280;
+	public static final int ITEM_BOWL = 281;
+	public static final int ITEM_MUSHROOM_STEW = 282;
+	public static final int ITEM_GOLDEN_SWORD = 283;
+	public static final int ITEM_GOLDEN_SHOVEL = 284;
+	public static final int ITEM_GOLDEN_PICKAXE = 285;
+	public static final int ITEM_GOLDEN_AXE = 286;
+	public static final int ITEM_STRING = 287;
+	public static final int ITEM_FEATHER = 288;
+	public static final int ITEM_GUNPOWDER = 289;
+	public static final int ITEM_WOODEN_HOE = 290;
+	public static final int ITEM_STONE_HOE = 291;
+	public static final int ITEM_IRON_HOE = 292;
+	public static final int ITEM_DIAMOND_HOE = 293;
+	public static final int ITEM_GOLDEN_HOE = 294;
+	public static final int ITEM_SEEDS = 295;
+	public static final int ITEM_WHEAT = 296;
+	public static final int ITEM_BREAD = 297;
+	public static final int ITEM_LEATHER_CAP = 298;
+	public static final int ITEM_LEATHER_TUNIC = 299;
+	public static final int ITEM_LEATHER_PANTS = 300;
+	public static final int ITEM_LEATHER_BOOTS = 301;
+	public static final int ITEM_CHAIN_HELMET = 302;
+	public static final int ITEM_CHAIN_CHESTPLATE = 303;
+	public static final int ITEM_CHAIN_LEGGINGS = 304;
+	public static final int ITEM_CHAIN_BOOTS = 305;
+	public static final int ITEM_IRON_HELMET = 306;
+	public static final int ITEM_IRON_CHESTPLATE = 307;
+	public static final int ITEM_IRON_LEGGINGS = 308;
+	public static final int ITEM_IRON_BOOTS = 309;
+	public static final int ITEM_DIAMOND_HELMET = 310;
+	public static final int ITEM_DIAMOND_CHESTPLATE = 311;
+	public static final int ITEM_DIAMOND_LEGGINGS = 312;
+	public static final int ITEM_DIAMOND_BOOTS = 313;
+	public static final int ITEM_GOLDEN_HELMET = 314;
+	public static final int ITEM_GOLDEN_CHESTPLATE = 315;
+	public static final int ITEM_GOLDEN_LEGGINGS = 316;
+	public static final int ITEM_GOLDEN_BOOTS = 317;
+	public static final int ITEM_FLINT = 318;
+	public static final int ITEM_RAW_PORKCHOP = 319;
+	public static final int ITEM_COOKED_PORKCHOP = 320;
+	public static final int ITEM_PAINTING = 321;
+	public static final int ITEM_GOLDEN_APPLE = 322;
+	public static final int ITEM_SIGN = 323;
+	public static final int ITEM_OAK_DOOR = 324;
+	public static final int ITEM_BUCKET = 325;
+	public static final int ITEM_WATER_BUCKET = 326;
+	public static final int ITEM_LAVA_BUCKET = 327;
+	public static final int ITEM_MINECART = 328;
+	public static final int ITEM_SADDLE = 329;
+	public static final int ITEM_IRON_DOOR = 330;
+	public static final int ITEM_REDSTONE = 331;
+	public static final int ITEM_SNOWBALL = 332;
+	public static final int ITEM_BOAT = 333;
+	public static final int ITEM_LEATHER = 334;
+	public static final int ITEM_MILK = 335;
+	public static final int ITEM_BRICK = 336;
+	public static final int ITEM_SUGAR_CANES = 338;
+	public static final int ITEM_PAPER = 339;
+	public static final int ITEM_BOOK = 340;
+	public static final int ITEM_SLIMEBALL = 341;
+	public static final int ITEM_MINECART_WITH_CHEST = 342;
+	public static final int ITEM_MINECART_WITH_FURNACE = 343;
+	public static final int ITEM_EGG = 344;
+	public static final int ITEM_COMPASS = 345;
+	public static final int ITEM_FISHING_ROD = 346;
+	public static final int ITEM_CLOCK = 347;
+	public static final int ITEM_GLOWSTONE_DUST = 348;
+	public static final int ITEM_RAW_FISH = 349;
+	public static final int ITEM_COOKED_FISH = 350;
+	public static final int ITEM_INK_SAC = 351;
+	public static final int ITEM_BONE = 352;
+	public static final int ITEM_SUGAR = 353;
+	public static final int ITEM_CAKE = 354;
+	public static final int ITEM_BED = 355;
+	public static final int ITEM_REDSTONE_REPEATER = 356;
+	public static final int ITEM_COOKIE = 357;
+	public static final int ITEM_MAP = 358;
+	public static final int ITEM_SHEARS = 359;
+	public static final int ITEM_PUMPKIN_SEEDS = 361;
+	public static final int ITEM_MELON_SEEDS = 362;
+	public static final int ITEM_RAW_BEEF = 363;
+	public static final int ITEM_STEAK = 364;
+	public static final int ITEM_RAW_CHICKEN = 365;
+	public static final int ITEM_COOKED_CHICKEN = 366;
+	public static final int ITEM_ROTTEN_FLESH = 367;
+	public static final int ITEM_ENDER_PEARL = 368;
+	public static final int ITEM_BLAZE_ROD = 369;
+	public static final int ITEM_GHAST_TEAR = 370;
+	public static final int ITEM_GOLD_NUGGET = 371;
+	public static final int ITEM_NETHER_WART = 372;
+	public static final int ITEM_WATER_BOTTLE = 373;
+	public static final int ITEM_GLASS_BOTTLE = 374;
+	public static final int ITEM_SPIDER_EYE = 375;
+	public static final int ITEM_FERMENTED_SPIDER_EYE = 376;
+	public static final int ITEM_BLAZE_POWDER = 377;
+	public static final int ITEM_MAGMA_CREAM = 378;
+	public static final int ITEM_BREWING_STAND = 379;
+	public static final int ITEM_CAULDRON = 380;
+	public static final int ITEM_EYE_OF_ENDER = 381;
+	public static final int ITEM_GLISTERING_MELON = 382;
+	public static final int ITEM_SPAWN = 383;
+	public static final int ITEM_BOTTLE_O_ENCHANTING = 384;
+	public static final int ITEM_FIRE_CHARGE = 385;
+	public static final int ITEM_BOOK_AND_QUILL = 386;
+	public static final int ITEM_WRITTEN_BOOK = 387;
+	public static final int ITEM_EMERALD = 388;
+	public static final int ITEM_ITEM_FRAME = 389;
+	public static final int ITEM_FLOWER_POT = 390;
+	public static final int ITEM_CARROT = 391;
+	public static final int ITEM_POTATO = 392;
+	public static final int ITEM_BAKED_POTATO = 393;
+	public static final int ITEM_POISONOUS_POTATO = 394;
+	public static final int ITEM_EMPTY_MAP = 395;
+	public static final int ITEM_GOLDEN_CARROT = 396;
+	public static final int ITEM_SKELETON_SKULL = 397;
+	public static final int ITEM_CARROT_ON_A_STICK = 398;
+	public static final int ITEM_NETHER_STAR = 399;
+	public static final int ITEM_PUMPKIN_PIE = 400;
+	public static final int ITEM_FIREWORK_ROCKET = 401;
+	public static final int ITEM_FIREWORK_STAR = 402;
+	public static final int ITEM_ENCHANTED_BOOK = 403;
+	public static final int ITEM_REDSTONE_COMPARATOR = 404;
+	public static final int ITEM_NETHER_QUARTZ = 406;
+	public static final int ITEM_MINECART_WITH_TNT = 407;
+	public static final int ITEM_MINECART_WITH_HOPPER = 408;
+	public static final int ITEM_PRISMARINE_SHARD = 409;
+	public static final int ITEM_PRISMARINE_CRYSTALS = 410;
+	public static final int ITEM_RAW_RABBIT = 411;
+	public static final int ITEM_COOKED_RABBIT = 412;
+	public static final int ITEM_RABBIT_STEW = 413;
+	public static final int ITEM_RABBITS_FOOT = 414;
+	public static final int ITEM_RABBIT_HIDE = 415;
+	public static final int ITEM_ARMOR_STAND = 416;
+	public static final int ITEM_IRON_HORSE_ARMOR = 417;
+	public static final int ITEM_GOLD_HORSE_ARMOR = 418;
+	public static final int ITEM_DIAMOND_HORSE_ARMOR = 419;
+	public static final int ITEM_LEAD = 420;
+	public static final int ITEM_NAME_TAG = 421;
+	public static final int ITEM_MINECART_WITH_COMMAND_BLOCK = 422;
+	public static final int ITEM_RAW_MUTTON = 423;
+	public static final int ITEM_COOKED_MUTTON = 424;
+	public static final int ITEM_BLACK_BANNER = 425;
+	public static final int ITEM_SPRUCE_DOOR = 427;
+	public static final int ITEM_BIRCH_DOOR = 428;
+	public static final int ITEM_JUNGLE_DOOR = 429;
+	public static final int ITEM_ACACIA_DOOR = 430;
+	public static final int ITEM_DARK_OAK_DOOR = 431;
+	public static final int ITEM_CHORUS_FRUIT = 432;
+	public static final int ITEM_CHORUS_FRUIT_POPPED = 433;
+	public static final int ITEM_BEETROOT = 434;
+	public static final int ITEM_BEETROOT_SEEDS = 435;
+	public static final int ITEM_BEETROOT_SOUP = 436;
+	public static final int ITEM_DRAGON_BREATH = 437;
+	public static final int ITEM_SPLASH_POTION = 438;
+	public static final int ITEM_SPECTRAL_ARROW = 439;
+	public static final int ITEM_TIPPED_ARROW = 440;
+	public static final int ITEM_LINGERING_POTION = 441;
+	public static final int ITEM_SHIELD = 442;
+	public static final int ITEM_ELYTRA = 443;
+	public static final int ITEM_SPRUCE_BOAT = 444;
+	public static final int ITEM_BIRCH_BOAT = 445;
+	public static final int ITEM_JUNGLE_BOAT = 446;
+	public static final int ITEM_ACACIA_BOAT = 447;
+	public static final int ITEM_DARK_OAK_BOAT = 448;
+	public static final int ITEM_TOTEM = 449;
+	public static final int ITEM_SHULKER_SHELL = 450;
+	public static final int ITEM_IRON_NUGGET = 452;
+	public static final int ITEM_KNOWLEDGE_BOOK = 453;
+
+	public static final int ITEM_RECORD_13 = 2256;
+	public static final int ITEM_RECORD_CAT = 2257;
+	public static final int ITEM_RECORD_BLOCKS = 2258;
+	public static final int ITEM_RECORD_CHIRP = 2259;
+	public static final int ITEM_RECORD_FAR = 2260;
+	public static final int ITEM_RECORD_MALL = 2261;
+	public static final int ITEM_RECORD_MELLOHI = 2262;
+	public static final int ITEM_RECORD_STAL = 2263;
+	public static final int ITEM_RECORD_STRAD = 2264;
+	public static final int ITEM_RECORD_WARD = 2265;
+	public static final int ITEM_RECORD_11 = 2266;
+	public static final int ITEM_RECORD_WAIT = 2267;
+}
diff --git a/src/main/java/PluginReference/MC_Instrument.java b/src/main/java/PluginReference/MC_Instrument.java
new file mode 100644
index 0000000000000000000000000000000000000000..d23569e07509e35fdb3de5f45873cd0ddc4054fc
--- /dev/null
+++ b/src/main/java/PluginReference/MC_Instrument.java
@@ -0,0 +1,5 @@
+package PluginReference;
+
+public enum MC_Instrument {
+    HARP, BASS_DRUM, SNARE_DRUM, STICKS, BASS_GUITAR
+}
diff --git a/src/main/java/PluginReference/MC_Inventory.java b/src/main/java/PluginReference/MC_Inventory.java
new file mode 100644
index 0000000000000000000000000000000000000000..835d97b5a30a6d6b49416f353ecaea92cb1e072d
--- /dev/null
+++ b/src/main/java/PluginReference/MC_Inventory.java
@@ -0,0 +1,36 @@
+package PluginReference;
+
+/**
+ * Represents an inventory
+ */
+public interface MC_Inventory {
+
+    /**
+     * Retrieve the size of the inventory.
+     * @return size of the inventory.
+     */
+    int getSize();
+
+    /**
+     * Get the item stack at the given index.
+     *
+     * @param index the index
+     * @return the item stack
+     */
+    MC_ItemStack getItemStackAt(int index);
+
+    /**
+     * Set the item stack at the given index.
+     *
+     * @param index the index
+     * @param itemStack the item stack
+     */
+    void setItemStackAt(int index, MC_ItemStack itemStack);
+
+    /**
+     * Get the title of the inventory.
+     *
+     * @return the title
+     */
+    String getTitle();
+}
diff --git a/src/main/java/PluginReference/MC_InventoryGUI.java b/src/main/java/PluginReference/MC_InventoryGUI.java
new file mode 100644
index 0000000000000000000000000000000000000000..41ccffbe7507bb1d51dafbaf96395afef60305d5
--- /dev/null
+++ b/src/main/java/PluginReference/MC_InventoryGUI.java
@@ -0,0 +1,27 @@
+package PluginReference;
+
+/**
+ * An inventory used as GUI. The clients cannot modify the content of the inventory.
+ */
+public interface MC_InventoryGUI extends MC_Inventory {
+
+    /**
+     * Set the action to be performed when the client clicks the slot.
+     *
+     * @param slotIndex   the index of the slot
+     * @param clickHandler the action to be performed, can be null
+     */
+    void setClickHandler(int slotIndex, ClickHandler clickHandler);
+
+    /**
+     * Get the action to be performed when a slot is clicked.
+     *
+     * @param slotIndex the index of the slot
+     * @return the action to be performed
+     */
+    ClickHandler getClickHandler(int slotIndex);
+
+    interface ClickHandler {
+        void onSlotClicked(MC_Player player);
+    }
+}
diff --git a/src/main/java/PluginReference/MC_ItemEntity.java b/src/main/java/PluginReference/MC_ItemEntity.java
new file mode 100644
index 0000000000000000000000000000000000000000..1254782b3e1bda47d5d5bda56e4788d884241fe2
--- /dev/null
+++ b/src/main/java/PluginReference/MC_ItemEntity.java
@@ -0,0 +1,50 @@
+package PluginReference;
+
+/** 
+ * Represents a Dropped Item
+ */ 			
+public interface MC_ItemEntity extends MC_Entity
+{
+	 /** 
+     * Gets the ItemStack associated with this item
+     *
+     * @return MC_ItemStack object
+     */ 		
+	public MC_ItemStack getItemStack();
+	
+	 /** 
+     * Sets the ItemStack associated with this item
+     *
+     * @param is MC_ItemStack object
+     */ 		
+	public void setItemStack(MC_ItemStack is);
+
+	 /** 
+     * Gets name of person who throw this item
+     *
+     * @return Name of thrower
+     */ 		
+	public String getThrowerName();
+
+	 /** 
+     * Sets name of person who throw this item
+     *
+     * @param name Name of thrower
+     */ 		
+	public void setThrowerName(String name);
+
+	 /** 
+     * Gets name of person who owns this item (target of /give)
+     *
+     * @return Name of owner
+     */ 		
+	public String getOwnerName();
+
+	 /** 
+     * Sets name of person who owns this item (target of /give)
+     *
+     * @param name Name of owner
+     */ 		
+	public void setOwnerName(String name);
+	
+}
diff --git a/src/main/java/PluginReference/MC_ItemFrameActionType.java b/src/main/java/PluginReference/MC_ItemFrameActionType.java
new file mode 100644
index 0000000000000000000000000000000000000000..ece342f63e62781e518801cb3d4adb8fcbcf730d
--- /dev/null
+++ b/src/main/java/PluginReference/MC_ItemFrameActionType.java
@@ -0,0 +1,12 @@
+package PluginReference;
+
+/** 
+ * Type of interact occurring on an ItemFrame
+ */ 			
+public enum MC_ItemFrameActionType
+{
+	UNSPECIFIED,
+	PLACE_INNER_ITEM,
+	BREAK_INNER_ITEM,
+	ROTATE_INNER_ITEM
+}
diff --git a/src/main/java/PluginReference/MC_ItemStack.java b/src/main/java/PluginReference/MC_ItemStack.java
new file mode 100644
index 0000000000000000000000000000000000000000..3e1f3e96accd330c97b606f2dfd5467eb853aeac
--- /dev/null
+++ b/src/main/java/PluginReference/MC_ItemStack.java
@@ -0,0 +1,159 @@
+package PluginReference;
+
+import java.util.List;
+
+/** 
+ * Interface representing an Item Stack.
+ */ 			
+public interface MC_ItemStack
+{
+	 /** 
+     * Get the name player's see for this item.
+     * E.g. "Acacia Wood Planks"
+     * 
+     * @return Item Name
+     */ 		
+	public String getFriendlyName();
+
+	 /** 
+     * Get the customized name for this item (i.e. anvil renamed)
+     * 
+     * @return Item Name
+     */ 		
+	public String getCustomizedName();
+	
+	 /** 
+     * Get the Minecraft internal name.
+     * E.g. "minecraft:air"
+     * 
+     * @return Item Name
+     */ 		
+	public String getOfficialName();
+	
+	 /** 
+     * Get the Minecraft ID for this item. E.g. 1=Stone, 2=Grass
+     * 
+     * @return Minecraft ID
+     */
+	 @Deprecated
+	public int getId();
+	 /** 
+     * Gets the damage/subtype value for this item. Note: This value is
+     * also associated with the 'subtype' for certain items such as Wool.
+     * For example, with Wool this value represents the color.
+     * 
+     * @return Damage/Subtype Value
+     */ 		
+	public int getDamage();
+	 /** 
+     * Get the stack size of this item stack.
+     * 
+     * @return Stack size
+     */ 		
+	public int getCount();
+	
+	 /** 
+     * Sets the damage/subtype value for this item
+     * 
+     * @param dmg Damage/Subtype value
+     */ 		
+	public void setDamage(int dmg);
+	 /** 
+     * Sets the stack count for this item stack.
+     * 
+     * @param cnt Count of items
+     */ 		
+	public void setCount(int cnt);
+
+	 /** 
+     * Check if an item has a custom name.
+     * @return True if has custom name, False otherwise.
+     */ 		
+	public boolean hasCustomName();
+	 /** 
+     * Sets a custom name for the item.
+     * 
+     * @param str Custom name
+     */ 		
+	public void setCustomName(String str);
+	 /** 
+     * Remove custom item name (if one exists) 
+     */ 		
+	public void removeCustomName();
+	
+	 /** 
+     * Determine if an item has custom details associated with it.
+     * Such items can not normally be stacked together safely. 
+     * 
+     * @return True if has custom details, False otherwise.
+     */ 		
+	public boolean getHasCustomDetails(); // One use is to know whether can safely stack items together
+	 /** 
+     * Get the maximum stacking size for this item.  I.e. 64 for most items. 
+     * 
+     * @return Maximum stack size for this item. 
+     */ 		
+	public int getMaxStackSize();
+	
+	 /** 
+     * Get the enchantment level of a given enchantment for this item.
+     * 
+     * @param encType Enchantment Type to inspect
+     * @return Enchantment level. 
+     */ 		
+	public int getEnchantmentLevel(MC_EnchantmentType encType);
+	 /** 
+     * Sets the enchantments for this item.
+     * 
+     * @param enchants List of enchantments
+     */ 		
+	public void setEnchantments(List<MC_Enchantment> enchants);
+	 /** 
+     * Get the enchantments this item has.
+     * 
+     * @return List of enchantments 
+     */ 		
+	public List<MC_Enchantment> getEnchantments();
+	 /** 
+     * Sets the enchantment level of a given enchantment for this item.
+     * 
+     * @param encType Enchantment Type
+     * @param level Enchantment Level
+     */ 		
+	public void setEnchantmentLevel(MC_EnchantmentType encType, int level);
+
+	 /** 
+     * Clone an item 
+     * 
+     * @return Clone of item 
+     */ 		
+	public MC_ItemStack getDuplicate();
+
+	 /** 
+     * Gets the Lore settings for an item 
+     * 
+     * @return List of Lore settings as strings 
+     */ 	
+	public List<String> getLore();
+	
+	/** 
+     * Sets the Lore settings for an item
+     * 
+     * @param lore List of Lore settings as strings
+     */ 	
+	public void setLore(List<String> lore);
+
+	 /** 
+     * Convert item to a byte array. Use MC_Server.createItemStack() to construct a new item from this data. 
+     * 
+     * @return Byte array representation of the item 
+     */ 	
+	public byte[] serialize();
+
+	 /** 
+     * If item is a skull, sets the skull owner. 
+     * 
+     * @param pName Skull Name
+     */ 	
+	public void setSkullOwner(String pName);
+}
diff --git a/src/main/java/PluginReference/MC_ItemType.java b/src/main/java/PluginReference/MC_ItemType.java
new file mode 100644
index 0000000000000000000000000000000000000000..9832a9cd99910aba61dd7c918548f35603017572
--- /dev/null
+++ b/src/main/java/PluginReference/MC_ItemType.java
@@ -0,0 +1,451 @@
+package PluginReference;
+
+/** 
+ * Convenience variables to use instead of Minecraft IDs
+ */
+@Deprecated
+public class MC_ItemType {
+	public static final int AIR = 0;
+	public static final int STONE = 1;
+	public static final int GRASS = 2;
+	public static final int DIRT = 3;
+	public static final int COBBLESTONE = 4;
+	public static final int PLANKS = 5;
+	public static final int SAPLING = 6;
+	public static final int BEDROCK = 7;
+	public static final int FLOWING_WATER = 8;
+	public static final int WATER = 9;
+	public static final int FLOWING_LAVA = 10;
+	public static final int LAVA = 11;
+	public static final int SAND = 12;
+	public static final int GRAVEL = 13;
+	public static final int GOLD_ORE = 14;
+	public static final int IRON_ORE = 15;
+	public static final int COAL_ORE = 16;
+	public static final int LOG = 17;
+	public static final int LEAVES = 18;
+	public static final int SPONGE = 19;
+	public static final int GLASS = 20;
+	public static final int LAPIS_ORE = 21;
+	public static final int LAPIS_BLOCK = 22;
+	public static final int DISPENSER = 23;
+	public static final int SANDSTONE = 24;
+	public static final int NOTEBLOCK = 25;
+	//public static final int BED = 26;
+	public static final int GOLDEN_RAIL = 27;
+	public static final int DETECTOR_RAIL = 28;
+	public static final int STICKY_PISTON = 29;
+	public static final int WEB = 30;
+	public static final int TALLGRASS = 31;
+	public static final int DEADBUSH = 32;
+	public static final int PISTON = 33;
+	public static final int PISTON_HEAD = 34;
+	public static final int WOOL = 35;
+	public static final int PISTON_EXTENSION = 36;
+	public static final int YELLOW_FLOWER = 37;
+	public static final int RED_FLOWER = 38;
+	public static final int BROWN_MUSHROOM = 39;
+	public static final int RED_MUSHROOM = 40;
+	public static final int GOLD_BLOCK = 41;
+	public static final int IRON_BLOCK = 42;
+	public static final int DOUBLE_STONE_SLAB = 43;
+	public static final int STONE_SLAB = 44;
+	public static final int BRICK_BLOCK = 45;
+	public static final int TNT = 46;
+	public static final int BOOKSHELF = 47;
+	public static final int MOSSY_COBBLESTONE = 48;
+	public static final int OBSIDIAN = 49;
+	public static final int TORCH = 50;
+	public static final int FIRE = 51;
+	public static final int MOB_SPAWNER = 52;
+	public static final int OAK_STAIRS = 53;
+	public static final int CHEST = 54;
+	public static final int REDSTONE_WIRE = 55;
+	public static final int DIAMOND_ORE = 56;
+	public static final int DIAMOND_BLOCK = 57;
+	public static final int CRAFTING_TABLE = 58;
+	//public static final int WHEAT = 59;
+	public static final int FARMLAND = 60;
+	public static final int FURNACE = 61;
+	public static final int LIT_FURNACE = 62;
+	public static final int STANDING_SIGN = 63;
+	public static final int WOODEN_DOOR = 64;
+	public static final int LADDER = 65;
+	public static final int RAIL = 66;
+	public static final int STONE_STAIRS = 67;
+	public static final int WALL_SIGN = 68;
+	public static final int LEVER = 69;
+	public static final int STONE_PRESSURE_PLATE = 70;
+	//public static final int IRON_DOOR = 71;
+	public static final int WOODEN_PRESSURE_PLATE = 72;
+	public static final int REDSTONE_ORE = 73;
+	public static final int LIT_REDSTONE_ORE = 74;
+	public static final int UNLIT_REDSTONE_TORCH = 75;
+	public static final int REDSTONE_TORCH = 76;
+	public static final int STONE_BUTTON = 77;
+	public static final int SNOW_LAYER = 78;
+	public static final int ICE = 79;
+	public static final int SNOW = 80;
+	public static final int CACTUS = 81;
+	public static final int CLAY = 82;
+	public static final int REEDS = 83;
+	public static final int JUKEBOX = 84;
+	public static final int FENCE = 85;
+	public static final int PUMPKIN = 86;
+	public static final int NETHERRACK = 87;
+	public static final int SOUL_SAND = 88;
+	public static final int GLOWSTONE = 89;
+	public static final int PORTAL = 90;
+	public static final int LIT_PUMPKIN = 91;
+	//public static final int CAKE = 92;
+	public static final int UNPOWERED_REPEATER = 93;
+	public static final int POWERED_REPEATER = 94;
+	public static final int STAINED_GLASS = 95;
+	public static final int TRAPDOOR = 96;
+	public static final int MONSTER_EGG = 97;
+	public static final int STONEBRICK = 98;
+	public static final int BROWN_MUSHROOM_BLOCK = 99;
+	public static final int RED_MUSHROOM_BLOCK = 100;
+	public static final int IRON_BARS = 101;
+	public static final int GLASS_PANE = 102;
+	public static final int MELON_BLOCK = 103;
+	public static final int PUMPKIN_STEM = 104;
+	public static final int MELON_STEM = 105;
+	public static final int VINE = 106;
+	public static final int FENCE_GATE = 107;
+	public static final int BRICK_STAIRS = 108;
+	public static final int STONE_BRICK_STAIRS = 109;
+	public static final int MYCELIUM = 110;
+	public static final int WATERLILY = 111;
+	public static final int NETHER_BRICK = 112;
+	public static final int NETHER_BRICK_FENCE = 113;
+	public static final int NETHER_BRICK_STAIRS = 114;
+	//public static final int NETHER_WART = 115;
+	public static final int ENCHANTING_TABLE = 116;
+	//public static final int BREWING_STAND = 117;
+	//public static final int CAULDRON = 118;
+	public static final int END_PORTAL = 119;
+	public static final int END_PORTAL_FRAME = 120;
+	public static final int END_STONE = 121;
+	public static final int DRAGON_EGG = 122;
+	public static final int REDSTONE_LAMP = 123;
+	public static final int LIT_REDSTONE_LAMP = 124;
+	public static final int DOUBLE_WOODEN_SLAB = 125;
+	public static final int WOODEN_SLAB = 126;
+	public static final int COCOA = 127;
+	public static final int SANDSTONE_STAIRS = 128;
+	public static final int EMERALD_ORE = 129;
+	public static final int ENDER_CHEST = 130;
+	public static final int TRIPWIRE_HOOK = 131;
+	public static final int TRIPWIRE = 132;
+	public static final int EMERALD_BLOCK = 133;
+	public static final int SPRUCE_STAIRS = 134;
+	public static final int BIRCH_STAIRS = 135;
+	public static final int JUNGLE_STAIRS = 136;
+	public static final int COMMAND_BLOCK = 137;
+	public static final int BEACON = 138;
+	public static final int COBBLESTONE_WALL = 139;
+	//public static final int FLOWER_POT = 140;
+	public static final int CARROTS = 141;
+	public static final int POTATOES = 142;
+	public static final int WOODEN_BUTTON = 143;
+	public static final int SKULL = 144;
+	public static final int ANVIL = 145;
+	public static final int TRAPPED_CHEST = 146;
+	public static final int LIGHT_WEIGHTED_PRESSURE_PLATE = 147;
+	public static final int HEAVY_WEIGHTED_PRESSURE_PLATE = 148;
+	public static final int UNPOWERED_COMPARATOR = 149;
+	public static final int POWERED_COMPARATOR = 150;
+	public static final int DAYLIGHT_DETECTOR = 151;
+	public static final int REDSTONE_BLOCK = 152;
+	public static final int QUARTZ_ORE = 153;
+	public static final int HOPPER = 154;
+	public static final int QUARTZ_BLOCK = 155;
+	public static final int QUARTZ_STAIRS = 156;
+	public static final int ACTIVATOR_RAIL = 157;
+	public static final int DROPPER = 158;
+	public static final int STAINED_HARDENED_CLAY = 159;
+	public static final int STAINED_GLASS_PANE = 160;
+	public static final int LEAVES2 = 161;
+	public static final int LOG2 = 162;
+	public static final int ACACIA_STAIRS = 163;
+	public static final int DARK_OAK_STAIRS = 164;
+	public static final int SLIME = 165;
+	public static final int BARRIER = 166;
+	public static final int IRON_TRAPDOOR = 167;
+	public static final int PRISMARINE = 168;
+	public static final int SEA_LANTERN = 169;
+	public static final int HAY_BLOCK = 170;
+	public static final int CARPET = 171;
+	public static final int HARDENED_CLAY = 172;
+	public static final int COAL_BLOCK = 173;
+	public static final int PACKED_ICE = 174;
+	public static final int DOUBLE_PLANT = 175;
+	public static final int STANDING_BANNER = 176;
+	public static final int WALL_BANNER = 177;
+	public static final int DAYLIGHT_DETECTOR_INVERTED = 178;
+	public static final int RED_SANDSTONE = 179;
+	public static final int RED_SANDSTONE_STAIRS = 180;
+	public static final int DOUBLE_STONE_SLAB2 = 181;
+	public static final int STONE_SLAB2 = 182;
+	public static final int SPRUCE_FENCE_GATE = 183;
+	public static final int BIRCH_FENCE_GATE = 184;
+	public static final int JUNGLE_FENCE_GATE = 185;
+	public static final int DARK_OAK_FENCE_GATE = 186;
+	public static final int ACACIA_FENCE_GATE = 187;
+	public static final int SPRUCE_FENCE = 188;
+	public static final int BIRCH_FENCE = 189;
+	public static final int JUNGLE_FENCE = 190;
+	public static final int DARK_OAK_FENCE = 191;
+	public static final int ACACIA_FENCE = 192;
+	//public static final int SPRUCE_DOOR = 193;
+	//public static final int BIRCH_DOOR = 194;
+	//public static final int JUNGLE_DOOR = 195;
+	//public static final int ACACIA_DOOR = 196;
+	//public static final int DARK_OAK_DOOR = 197;
+	public static final int END_ROD = 198;
+	public static final int CHORUS_PLANT = 199;
+	public static final int CHORUS_FLOWER = 200;
+	public static final int PURPUR_BLOCK = 201;
+	public static final int PURPUR_PILLAR = 202;
+	public static final int PURPUR_STAIRS = 203;
+	public static final int PURPUR_DOUBLE_SLAB = 204;
+	public static final int PURPUR_SLAB = 205;
+	public static final int END_BRICKS = 206;
+	//public static final int BEETROOTS = 207;
+	public static final int GRASS_PATH = 208;
+	public static final int END_GATEWAY = 209;
+	public static final int REPEATING_COMMAND_BLOCK = 210;
+	public static final int CHAIN_COMMAND_BLOCK = 211;
+	public static final int FROSTED_ICE = 212;
+	public static final int MAGMA = 213;
+	public static final int NETHER_WART_BLOCK = 214;
+	public static final int RED_NETHER_BRICK = 215;
+	public static final int BONE_BLOCK = 216;
+	public static final int STRUCTURE_VOID = 217;
+	public static final int OBSERVER = 218;
+	public static final int SHULKER_BOX_WHITE = 219;
+	public static final int SHULKER_BOX_ORANGE = 220;
+	public static final int SHULKER_BOX_MAGENTA = 221;
+	public static final int SHULKER_BOX_LIGHT_BLUE = 222;
+	public static final int SHULKER_BOX_YELLOW = 223;
+	public static final int SHULKER_BOX_LIME = 224;
+	public static final int SHULKER_BOX_PINK = 225;
+	public static final int SHULKER_BOX_GRAY = 226;
+	public static final int SHULKER_BOX_SILVER = 227;
+	public static final int SHULKER_BOX_CYAN = 228;
+	public static final int SHULKER_BOX_PURPLE = 229;
+	public static final int SHULKER_BOX_BLUE = 230;
+	public static final int SHULKER_BOX_BROWN = 231;
+	public static final int SHULKER_BOX_GREEN = 232;
+	public static final int SHULKER_BOX_RED = 233;
+	public static final int SHULKER_BOX_BLACK = 234;
+	public static final int STRUCTURE_BLOCK = 255;
+	public static final int IRON_SHOVEL = 256;
+	public static final int IRON_PICKAXE = 257;
+	public static final int IRON_AXE = 258;
+	public static final int FLINT_AND_STEEL = 259;
+	public static final int APPLE = 260;
+	public static final int BOW = 261;
+	public static final int ARROW = 262;
+	public static final int COAL = 263;
+	public static final int DIAMOND = 264;
+	public static final int IRON_INGOT = 265;
+	public static final int GOLD_INGOT = 266;
+	public static final int IRON_SWORD = 267;
+	public static final int WOODEN_SWORD = 268;
+	public static final int WOODEN_SHOVEL = 269;
+	public static final int WOODEN_PICKAXE = 270;
+	public static final int WOODEN_AXE = 271;
+	public static final int STONE_SWORD = 272;
+	public static final int STONE_SHOVEL = 273;
+	public static final int STONE_PICKAXE = 274;
+	public static final int STONE_AXE = 275;
+	public static final int DIAMOND_SWORD = 276;
+	public static final int DIAMOND_SHOVEL = 277;
+	public static final int DIAMOND_PICKAXE = 278;
+	public static final int DIAMOND_AXE = 279;
+	public static final int STICK = 280;
+	public static final int BOWL = 281;
+	public static final int MUSHROOM_STEW = 282;
+	public static final int GOLDEN_SWORD = 283;
+	public static final int GOLDEN_SHOVEL = 284;
+	public static final int GOLDEN_PICKAXE = 285;
+	public static final int GOLDEN_AXE = 286;
+	public static final int STRING = 287;
+	public static final int FEATHER = 288;
+	public static final int GUNPOWDER = 289;
+	public static final int WOODEN_HOE = 290;
+	public static final int STONE_HOE = 291;
+	public static final int IRON_HOE = 292;
+	public static final int DIAMOND_HOE = 293;
+	public static final int GOLDEN_HOE = 294;
+	public static final int SEEDS = 295;
+	public static final int WHEAT = 296;
+	public static final int BREAD = 297;
+	public static final int LEATHER_CAP = 298;
+	public static final int LEATHER_TUNIC = 299;
+	public static final int LEATHER_PANTS = 300;
+	public static final int LEATHER_BOOTS = 301;
+	public static final int CHAIN_HELMET = 302;
+	public static final int CHAIN_CHESTPLATE = 303;
+	public static final int CHAIN_LEGGINGS = 304;
+	public static final int CHAIN_BOOTS = 305;
+	public static final int IRON_HELMET = 306;
+	public static final int IRON_CHESTPLATE = 307;
+	public static final int IRON_LEGGINGS = 308;
+	public static final int IRON_BOOTS = 309;
+	public static final int DIAMOND_HELMET = 310;
+	public static final int DIAMOND_CHESTPLATE = 311;
+	public static final int DIAMOND_LEGGINGS = 312;
+	public static final int DIAMOND_BOOTS = 313;
+	public static final int GOLDEN_HELMET = 314;
+	public static final int GOLDEN_CHESTPLATE = 315;
+	public static final int GOLDEN_LEGGINGS = 316;
+	public static final int GOLDEN_BOOTS = 317;
+	public static final int FLINT = 318;
+	public static final int RAW_PORKCHOP = 319;
+	public static final int COOKED_PORKCHOP = 320;
+	public static final int PAINTING = 321;
+	public static final int GOLDEN_APPLE = 322;
+	public static final int SIGN = 323;
+	public static final int OAK_DOOR = 324;
+	public static final int BUCKET = 325;
+	public static final int WATER_BUCKET = 326;
+	public static final int LAVA_BUCKET = 327;
+	public static final int MINECART = 328;
+	public static final int SADDLE = 329;
+	public static final int IRON_DOOR = 330;
+	public static final int REDSTONE = 331;
+	public static final int SNOWBALL = 332;
+	public static final int BOAT = 333;
+	public static final int LEATHER = 334;
+	public static final int MILK = 335;
+	public static final int BRICK = 336;
+	public static final int SUGAR_CANES = 338;
+	public static final int PAPER = 339;
+	public static final int BOOK = 340;
+	public static final int SLIMEBALL = 341;
+	public static final int MINECART_WITH_CHEST = 342;
+	public static final int MINECART_WITH_FURNACE = 343;
+	public static final int EGG = 344;
+	public static final int COMPASS = 345;
+	public static final int FISHING_ROD = 346;
+	public static final int CLOCK = 347;
+	public static final int GLOWSTONE_DUST = 348;
+	public static final int RAW_FISH = 349;
+	public static final int COOKED_FISH = 350;
+	public static final int INK_SAC = 351;
+	public static final int BONE = 352;
+	public static final int SUGAR = 353;
+	public static final int CAKE = 354;
+	public static final int BED = 355;
+	public static final int REDSTONE_REPEATER = 356;
+	public static final int COOKIE = 357;
+	public static final int MAP = 358;
+	public static final int SHEARS = 359;
+	public static final int PUMPKIN_SEEDS = 361;
+	public static final int MELON_SEEDS = 362;
+	public static final int RAW_BEEF = 363;
+	public static final int STEAK = 364;
+	public static final int RAW_CHICKEN = 365;
+	public static final int COOKED_CHICKEN = 366;
+	public static final int ROTTEN_FLESH = 367;
+	public static final int ENDER_PEARL = 368;
+	public static final int BLAZE_ROD = 369;
+	public static final int GHAST_TEAR = 370;
+	public static final int GOLD_NUGGET = 371;
+	public static final int NETHER_WART = 372;
+	public static final int WATER_BOTTLE = 373;
+	public static final int GLASS_BOTTLE = 374;
+	public static final int SPIDER_EYE = 375;
+	public static final int FERMENTED_SPIDER_EYE = 376;
+	public static final int BLAZE_POWDER = 377;
+	public static final int MAGMA_CREAM = 378;
+	public static final int BREWING_STAND = 379;
+	public static final int CAULDRON = 380;
+	public static final int EYE_OF_ENDER = 381;
+	public static final int GLISTERING_MELON = 382;
+	public static final int SPAWN = 383;
+	public static final int BOTTLE_O_ENCHANTING = 384;
+	public static final int FIRE_CHARGE = 385;
+	public static final int BOOK_AND_QUILL = 386;
+	public static final int WRITTEN_BOOK = 387;
+	public static final int EMERALD = 388;
+	public static final int ITEM_FRAME = 389;
+	public static final int FLOWER_POT = 390;
+	public static final int CARROT = 391;
+	public static final int POTATO = 392;
+	public static final int BAKED_POTATO = 393;
+	public static final int POISONOUS_POTATO = 394;
+	public static final int EMPTY_MAP = 395;
+	public static final int GOLDEN_CARROT = 396;
+	public static final int SKELETON_SKULL = 397;
+	public static final int CARROT_ON_A_STICK = 398;
+	public static final int NETHER_STAR = 399;
+	public static final int PUMPKIN_PIE = 400;
+	public static final int FIREWORK_ROCKET = 401;
+	public static final int FIREWORK_STAR = 402;
+	public static final int ENCHANTED_BOOK = 403;
+	public static final int REDSTONE_COMPARATOR = 404;
+	public static final int NETHER_QUARTZ = 406;
+	public static final int MINECART_WITH_TNT = 407;
+	public static final int MINECART_WITH_HOPPER = 408;
+	public static final int PRISMARINE_SHARD = 409;
+	public static final int PRISMARINE_CRYSTALS = 410;
+	public static final int RAW_RABBIT = 411;
+	public static final int COOKED_RABBIT = 412;
+	public static final int RABBIT_STEW = 413;
+	public static final int RABBITS_FOOT = 414;
+	public static final int RABBIT_HIDE = 415;
+	public static final int ARMOR_STAND = 416;
+	public static final int IRON_HORSE_ARMOR = 417;
+	public static final int GOLD_HORSE_ARMOR = 418;
+	public static final int DIAMOND_HORSE_ARMOR = 419;
+	public static final int LEAD = 420;
+	public static final int NAME_TAG = 421;
+	public static final int MINECART_WITH_COMMAND_BLOCK = 422;
+	public static final int RAW_MUTTON = 423;
+	public static final int COOKED_MUTTON = 424;
+	public static final int BLACK_BANNER = 425;
+	public static final int SPRUCE_DOOR = 427;
+	public static final int BIRCH_DOOR = 428;
+	public static final int JUNGLE_DOOR = 429;
+	public static final int ACACIA_DOOR = 430;
+	public static final int DARK_OAK_DOOR = 431;
+	public static final int CHORUS_FRUIT = 432;
+	public static final int CHORUS_FRUIT_POPPED = 433;
+	public static final int BEETROOT = 434;
+	public static final int BEETROOT_SEEDS = 435;
+	public static final int BEETROOT_SOUP = 436;
+	public static final int DRAGON_BREATH = 437;
+	public static final int SPLASH_POTION = 438;
+	public static final int SPECTRAL_ARROW = 439;
+	public static final int TIPPED_ARROW = 440;
+	public static final int LINGERING_POTION = 441;
+	public static final int SHIELD = 442;
+	public static final int ELYTRA = 443;
+	public static final int SPRUCE_BOAT = 444;
+	public static final int BIRCH_BOAT = 445;
+	public static final int JUNGLE_BOAT = 446;
+	public static final int ACACIA_BOAT = 447;
+	public static final int DARK_OAK_BOAT = 448;
+	public static final int TOTEM = 449;
+	public static final int SHULKER_SHELL = 450;
+	public static final int IRON_NUGGET = 452;
+	public static final int KNOWLEDGE_BOOK = 453;
+
+	public static final int RECORD_13 = 2256;
+	public static final int RECORD_CAT = 2257;
+	public static final int RECORD_BLOCKS = 2258;
+	public static final int RECORD_CHIRP = 2259;
+	public static final int RECORD_FAR = 2260;
+	public static final int RECORD_MALL = 2261;
+	public static final int RECORD_MELLOHI = 2262;
+	public static final int RECORD_STAL = 2263;
+	public static final int RECORD_STRAD = 2264;
+	public static final int RECORD_WARD = 2265;
+	public static final int RECORD_11 = 2266;
+	public static final int RECORD_WAIT = 2267;
+
+}
diff --git a/src/main/java/PluginReference/MC_LivingEntity.java b/src/main/java/PluginReference/MC_LivingEntity.java
new file mode 100644
index 0000000000000000000000000000000000000000..5743ac1eb79faf1133be2d5e1e74850cb5d69707
--- /dev/null
+++ b/src/main/java/PluginReference/MC_LivingEntity.java
@@ -0,0 +1,15 @@
+package PluginReference;
+
+/**
+ * Represents a living entity.
+ */
+public interface MC_LivingEntity extends MC_Entity {
+
+    /**
+     * Get a specific attribute.
+     *
+     * @param type type of the attribute
+     * @return the attribute
+     */
+    MC_Attribute getAttribute(MC_AttributeType type);
+}
diff --git a/src/main/java/PluginReference/MC_Location.java b/src/main/java/PluginReference/MC_Location.java
new file mode 100644
index 0000000000000000000000000000000000000000..42e2b743d37fa6effa0b1eadd047a2ae1e8b2740
--- /dev/null
+++ b/src/main/java/PluginReference/MC_Location.java
@@ -0,0 +1,154 @@
+package PluginReference;
+
+import java.io.Serializable;
+
+/** 
+ * Represents a Minecraft location.
+ */ 			
+public class MC_Location implements Serializable
+{
+	  public int dimension;
+	  public double x;
+	  public double y;
+	  public double z;
+	  public float yaw;
+	  public float pitch;
+
+	  public MC_Location(double x, double y, double z, int dimension, float yaw, float pitch)
+	  {
+	    this.dimension = dimension;
+	    this.x = x;
+	    this.y = y;
+	    this.z = z;
+	    this.pitch = pitch;
+	    this.yaw = yaw;
+	  }
+	  public MC_Location(double x, double y, double z, int dimension)
+	  {
+	    this.dimension = dimension;
+	    this.x = x;
+	    this.y = y;
+	    this.z = z;
+	    this.pitch = 0;
+	    this.yaw = 0;
+	  }
+	  
+	  public MC_Location(MC_Location locToCopy)
+	  {
+	    this.dimension = locToCopy.dimension;
+	    this.x = locToCopy.x;
+	    this.y = locToCopy.y;
+	    this.z = locToCopy.z;
+	    this.pitch = locToCopy.pitch;
+	    this.yaw = locToCopy.yaw;
+	  }
+	  
+	  public String toString()
+	  {
+		  String strBase = String.format("(%.1f, %.1f, %.1f)", x, y, z);
+		  if(dimension == 0) return strBase;
+		  String worldName = "Dimension_" + dimension;
+		  if(dimension == -1) worldName = "Nether";
+		  if(dimension == 1) worldName = "TheEnd";
+		  return worldName + strBase;
+	  }
+
+	  public MC_Location toBlockLocation()
+	  {
+		  return new MC_Location(getBlockX(), getBlockY(), getBlockZ(), dimension);
+	  }
+	  
+		 /** 
+	     * Converts Entity Location X-coordinate to Block Location
+	     * 
+	     * @return Block X-Coordinate
+	     */ 			
+	  public int getBlockX()
+	  {
+		  return (int)Math.floor(x);
+	  }
+		 /** 
+	     * Converts Entity Location Y-coordinate to Block Location
+	     * 
+	     * @return Block Y-Coordinate
+	     */ 			
+	  public int getBlockY()
+	  {
+		  return (int)Math.floor(y);
+	  }
+		 /** 
+	     * Converts Entity Location Z-coordinate to Block Location
+	     * 
+	     * @return Block Z-Coordinate
+	     */ 			
+	  public int getBlockZ()
+	  {
+		  return (int)Math.floor(z);
+	  }
+	  
+		 /** 
+	     * Check if location is equal (same x, y, z, dimension, yaw, pitch)
+	     * 
+	     * @param loc Location
+	     * @return True if same, False otherwise 
+	     */ 			
+	  public boolean equals(MC_Location loc) {
+		  if(loc == null) return false;
+		  if(x != loc.x) return false;
+		  if(z != loc.z) return false;
+		  if(y != loc.y) return false;
+		  if(dimension != loc.dimension) return false;
+		  if(Math.abs(yaw - loc.yaw) > 0.0001) return false;
+		  if(Math.abs(pitch - loc.pitch) > 0.0001) return false;
+		  return true;
+	  }
+	  
+	  public boolean isSameBlockLocationAs(MC_Location loc)
+	  {
+		  if(loc == null) return false;
+		  if(dimension != loc.dimension) return false;
+		  if(getBlockX() != loc.getBlockX()) return false;
+		  if(getBlockZ() != loc.getBlockZ()) return false;
+		  if(getBlockY() != loc.getBlockY()) return false;
+		  return true;
+	  }
+	  
+		 /** 
+	     * Compute distance from another location
+	     * 
+	     * @param loc Location to compute distance to
+	     * @return Euclidean Distance 
+	     */ 			
+	  public double distanceTo(MC_Location loc)
+	  {
+		  // If dimensions are different, instead of throwing an exception just treat different dimensions as 'very far away'
+		  if(loc.dimension != dimension) return Double.MAX_VALUE/2; // don't need full max value so reducing so no basic caller wrap-around.
+		  
+		  // Pythagoras...
+		  double dx = x - loc.x;
+		  double dy = y - loc.y;
+		  double dz = z - loc.z;
+		  return Math.sqrt(dx*dx + dy*dy + dz*dz);
+	  }
+	  
+		 /** 
+	     * Get Location at direction from this location
+	     * 
+	     * @param dir Direction
+	     * @return Location at specified Direction 
+	     */ 			
+	  public MC_Location getLocationAtDirection(MC_DirectionNESWUD dir)
+	  {
+		  MC_Location loc = new MC_Location(this);
+			
+			if(dir == MC_DirectionNESWUD.NORTH) loc.z--; 
+			if(dir == MC_DirectionNESWUD.SOUTH) loc.z++;
+			if(dir == MC_DirectionNESWUD.WEST) loc.x--;
+			if(dir == MC_DirectionNESWUD.EAST) loc.x++;
+			if(dir == MC_DirectionNESWUD.UP) loc.y++; 
+			if(dir == MC_DirectionNESWUD.DOWN) loc.y--;
+
+			return loc;
+		}
+	  
+}
diff --git a/src/main/java/PluginReference/MC_MiscGriefType.java b/src/main/java/PluginReference/MC_MiscGriefType.java
new file mode 100644
index 0000000000000000000000000000000000000000..da0703db90be959fc2f931d75584270685a42aa5
--- /dev/null
+++ b/src/main/java/PluginReference/MC_MiscGriefType.java
@@ -0,0 +1,15 @@
+package PluginReference;
+
+public enum MC_MiscGriefType
+{
+	ENDERDRAGON_BRUSH,
+	ENDERMAN_PICKUP_BLOCK,
+	ENDERMAN_PLACE_CARRIED_BLOCK,
+	SHEEP_GRAZING_GRASS,
+	SILVERFISH_BREAK_MONSTER_EGG_BLOCK,
+	RABBIT_EATS_CARROT,
+	VILLAGER_HARVEST,
+	VILLAGER_PLANT_SEEDS,
+	WITHER_BREAK,
+	ZOMBIE_DOOR_BREAK
+}
diff --git a/src/main/java/PluginReference/MC_MotionData.java b/src/main/java/PluginReference/MC_MotionData.java
new file mode 100644
index 0000000000000000000000000000000000000000..ba36067bb8fa9863b2df489e0cd5e3c69fd571af
--- /dev/null
+++ b/src/main/java/PluginReference/MC_MotionData.java
@@ -0,0 +1,20 @@
+package PluginReference;
+
+/** 
+ * Motion data for an Entity
+ */ 			
+public class MC_MotionData
+{
+	public double xMotion = 0;
+	public double yMotion = 0;
+	public double zMotion = 0;
+	public double fallDistance = 0;
+	public boolean onGround = true;
+	public boolean inWater = false;
+	
+	  public String toString()
+	  {
+		  return String.format("[motion=(%.2f, %.2f, %.2f), fallDist=%.2f, onGround=%s, inWater=%s]", xMotion, yMotion, zMotion, fallDistance, onGround+"", inWater+"");
+	  }
+	
+}
diff --git a/src/main/java/PluginReference/MC_NoteBlock.java b/src/main/java/PluginReference/MC_NoteBlock.java
new file mode 100644
index 0000000000000000000000000000000000000000..ae7d6e7cd430bf712436eb91333a67b83c613214
--- /dev/null
+++ b/src/main/java/PluginReference/MC_NoteBlock.java
@@ -0,0 +1,36 @@
+package PluginReference;
+
+/**
+ * A note block
+ */
+public interface MC_NoteBlock {
+
+    /**
+     * Gets the note.
+     *
+     * @return The note
+     * @see <a href="http://minecraft.gamepedia.com/Note_Block">http://minecraft.gamepedia.com/Note_Block</a>
+     */
+    int getNote();
+
+    /**
+     * Set the note
+     *
+     * @param note The note
+     * @see <a href="http://minecraft.gamepedia.com/Note_Block">http://minecraft.gamepedia.com/Note_Block</a>
+     */
+    void setNote(int note);
+
+    /**
+     * Plays the note.
+     */
+    void play();
+
+    /**
+     * Plays an arbitrary note with an arbitrary instrument
+     *
+     * @param instrument The instrument
+     * @param note      The note
+     */
+    void play(MC_Instrument instrument, int note);
+}
diff --git a/src/main/java/PluginReference/MC_Ocelot.java b/src/main/java/PluginReference/MC_Ocelot.java
new file mode 100644
index 0000000000000000000000000000000000000000..6091fb6f217adc419c6a70088c9211b495bb6034
--- /dev/null
+++ b/src/main/java/PluginReference/MC_Ocelot.java
@@ -0,0 +1,21 @@
+package PluginReference;
+
+/** 
+ * Ocelot Entity interface
+ */ 			
+public interface MC_Ocelot extends MC_AnimalTameable
+{
+	 /** 
+     * Get Cat Type
+     * 
+     * @return Cat Type 
+     */ 			
+	   public MC_OcelotType getCatType();
+		 /** 
+	     * Sets Cat Type (Wild, Black, Siamese, etc)
+	     * 
+	     * @param catType Cat Type
+	     */ 		
+	   public void setCatType(MC_OcelotType catType);
+}
+
diff --git a/src/main/java/PluginReference/MC_OcelotType.java b/src/main/java/PluginReference/MC_OcelotType.java
new file mode 100644
index 0000000000000000000000000000000000000000..3935f1974a2669af480d35a9bc96e00ebd5f2383
--- /dev/null
+++ b/src/main/java/PluginReference/MC_OcelotType.java
@@ -0,0 +1,14 @@
+package PluginReference;
+
+/** 
+ * Cat Type
+ */ 			
+public enum MC_OcelotType
+{
+	WILD,
+	BLACK,
+	RED,
+	SIAMESE,
+	UNKNOWN
+}
+
diff --git a/src/main/java/PluginReference/MC_Player.java b/src/main/java/PluginReference/MC_Player.java
new file mode 100644
index 0000000000000000000000000000000000000000..05f7106345b4d4fc04e2838c85b83bdcb3f4cb7b
--- /dev/null
+++ b/src/main/java/PluginReference/MC_Player.java
@@ -0,0 +1,544 @@
+package PluginReference;
+
+import net.md_5.bungee.api.chat.BaseComponent;
+
+import java.net.SocketAddress;
+import java.util.List;
+import java.util.UUID;
+
+/**
+ * Represents a Minecraft player.
+ *
+ * Note that this class is used to represent offline players too. If it represents an offline player some methods will
+ * throw an {@link UnsupportedOperationException}. Unless documented otherwise in the javadoc of the respective method
+ * you should assume all methods to be unsupported for offline players.
+ */
+@SuppressWarnings("ALL")
+public interface MC_Player extends MC_LivingEntity {
+
+    /**
+     * Gets name of this player.
+     *
+     * This method is supported for offline players.
+     *
+     * @return player name
+     */
+    @Override
+    String getName();
+
+    /**
+     * Check if this player has a custom name.
+     *
+     * The custom name of a player is identical to the name modified by the /namecolor command.
+     *
+     * This method is supported for offline players.
+     *
+     * @return True if has a custom name, False otherwise
+     */
+    @Override
+    boolean hasCustomName();
+
+    /**
+     * Sets custom name for this player.
+     *
+     * The custom name of a player is identical to the name modified by the /namecolor command.
+     *
+     * This method is supported for offline players.
+     *
+     * @param str Custom Name
+     */
+    @Override
+    void setCustomName(String str);
+
+    /**
+     * Gets the custom name of this player.
+     *
+     * The custom name of a player is identical to the name modified by the /namecolor command.
+     *
+     * This method is supported for offline players.
+     *
+     * @return Custom name
+     */
+    @Override
+    String getCustomName();
+
+
+    /**
+     * Gets the uuid of this player.
+     *
+     * This method is supported for offline players.
+     *
+     * @return uuid
+     */
+    @Override
+    UUID getUUID();
+
+    public String getIPAddress();
+
+    // Operations
+
+    /**
+     * Sends a a message to player
+     *
+     * @param msg Message
+     */
+    public void sendMessage(String msg);
+
+    /**
+     * Sends message to player
+     *
+     * @param msg Message
+     */
+    public void sendMessage(BaseComponent... msg);
+
+    /**
+     * Sends a message to player
+     *
+     * @param json Message using Minecrafts json massage format.
+     */
+    public void sendJsonMessage(String json);
+
+    /**
+     * Execute a command (as if user typed it)
+     *
+     * @param cmd Command to Execute
+     */
+    public void executeCommand(String cmd);
+
+    // Details
+
+    /**
+     * Check if op
+     *
+     * @return True if op, False otherwise
+     */
+    public boolean isOp();
+
+    /**
+     * Get Player GameMode
+     *
+     * @return Game Mode
+     */
+    public MC_GameMode getGameMode();
+
+    /**
+     * Sets player's GameMode
+     *
+     * @param gameMode Game Mode
+     */
+    public void setGameMode(MC_GameMode gameMode);
+
+
+    /**
+     * Get Player current health
+     *
+     * @return Health value
+     */
+    public float getHealth();
+
+    /**
+     * Sets Player Health
+     *
+     * @param argHealth Health value
+     */
+    public void setHealth(float argHealth);
+
+    /**
+     * Get Food Level
+     *
+     * @return Food Level
+     */
+    public int getFoodLevel();
+
+    /**
+     * Sets Player Food Level
+     *
+     * @param argFoodLevel Food Level
+     */
+    public void setFoodLevel(int argFoodLevel);
+
+    /**
+     * Get Economy balance (as managed by Rainbow).
+     *
+     * This method is supported for offline players.
+     *
+     * @return Economy balance
+     */
+    public double getEconomyBalance();
+
+    /**
+     * Sets Economy balance
+     *
+     * This method is supported for offline players.
+     *
+     * @param amt New Balance
+     */
+    public void setEconomyBalance(double amt);
+
+    /**
+     * Get Item in hand
+     *
+     * @return Item in hand
+     */
+    public MC_ItemStack getItemInHand();
+
+    /**
+     * Sets item in hand
+     *
+     * @param item Item
+     */
+    public void setItemInHand(MC_ItemStack item);
+
+    /**
+     * Get inventory of player
+     *
+     * @return List of items
+     */
+    public List<MC_ItemStack> getInventory();
+
+    /**
+     * Sets inventory
+     *
+     * @param items List of items
+     */
+    public void setInventory(List<MC_ItemStack> items);
+
+    /**
+     * Notify player inventory has changed
+     */
+    public void updateInventory();
+
+
+    // Miscellaneous
+
+    /**
+     * Check if invulnerable
+     *
+     * @return True if invulnerable, False otherwise
+     */
+    public boolean isInvulnerable();
+
+    /**
+     * Check if sleeping
+     *
+     * @return True if sleeping, False otherwise
+     */
+    public boolean isSleeping();
+
+    /**
+     * Check if allow flight
+     *
+     * @return True if allow flight, False otherwise
+     */
+    public boolean isAllowedFlight();
+
+    /**
+     * Check if flying
+     *
+     * @return True if flying, False otherwise
+     */
+    public boolean isFlying();
+
+    /**
+     * Get fly speed
+     *
+     * @return Fly speed
+     */
+    public float getFlySpeed();
+
+    /**
+     * Get walk speed
+     *
+     * @return Walk speed
+     */
+    public float getWalkSpeed();
+
+    /**
+     * Sets Fly Speed
+     *
+     * @param newVal Fly Speed
+     */
+    public void setFlySpeed(float newVal);
+
+    /**
+     * Sets Walk Speed
+     *
+     * @param newVal Walk Speed
+     */
+    public void setWalkSpeed(float newVal);
+
+    /**
+     * Sets Invulnerability
+     *
+     * @param flag True if invulnerable, False otherwise
+     */
+    public void setInvulnerable(boolean flag);
+
+    /**
+     * Sets Allow Flight
+     *
+     * @param flag True if allows flight, False otherwise
+     */
+    public void setAllowFlight(boolean flag);
+
+    /**
+     * Sets Flying mode
+     *
+     * @param flag True if flying, False otherwise
+     */
+    public void setFlying(boolean flag);
+
+    /**
+     * Give an amount of EXP
+     *
+     * @param exp Amount of EXP to give
+     */
+    public void giveExp(int exp);
+
+    /**
+     * Give an amount of EXP Levels
+     *
+     * @param levels Number of levels to give
+     */
+    public void giveExpLevels(int levels);
+
+    /**
+     * Get EXP value
+     *
+     * @return EXP Value
+     */
+    public float getExp();
+
+    /**
+     * Sets EXP value
+     *
+     * @param exp EXP value
+     */
+    public void setExp(float exp);
+
+    /**
+     * Get EXP Level
+     *
+     * @return EXP Level
+     */
+    public int getLevel();
+
+    /**
+     * Sets EXP Level
+     *
+     * @param level EXP level
+     */
+    public void setLevel(int level);
+
+    /**
+     * Get total EXP
+     *
+     * @return Total Experience
+     */
+    public int getTotalExperience();
+
+    /**
+     * Sets Total EXP
+     *
+     * @param exp Total EXP
+     */
+    public void setTotalExperience(int exp);
+
+    /**
+     * Get Server object (convenience function)
+     *
+     * @return Server object
+     */
+    public MC_Server getServer();
+
+    /**
+     * Check if player has a certani permission
+     *
+     * @param perm Permission to check
+     * @return True if yes, False if no.
+     */
+    public boolean hasPermission(String perm);
+
+    /**
+     * Sets Compass Target of player
+     *
+     * @param loc Location of compass target
+     */
+    public void setCompassTarget(MC_Location loc);
+
+    /**
+     * Get the Compass Target for this player
+     *
+     * @return Location of compass target
+     */
+    public MC_Location getCompassTarget();
+
+    /**
+     * Gets the respawn/bed location for this player
+     *
+     * @return Location of respawn
+     */
+    public MC_Location getBedRespawnLocation();
+
+    /**
+     * Sets the respawn/bed location for this player
+     * Only Dimension 0 (OverWorld) supported at this time.
+     *
+     * @param loc                       Respawn location
+     * @param requireBedBlockAtLocation If true, require a bed at location. Otherwise user taken to world spawn
+     */
+    public void setBedRespawnLocation(MC_Location loc, boolean requireBedBlockAtLocation);
+
+
+    /**
+     * Play a sound to a player
+     *
+     * @param soundName Sound Name, e.g. random.click
+     * @param volume    Volume
+     * @param pitch     Pitch
+     */
+    public void playSound(String soundName, float volume, float pitch);
+
+
+    /**
+     * Gets health added when not hungry. Default 1.0
+     *
+     * @return Location of respawn
+     */
+    public float getFoodRegenAmount();
+
+    /**
+     * Sets health added when not hungry. Default 1.0
+     *
+     * @param val Health amount restored
+     */
+    public void setFoodRegenAmount(float val);
+
+    /**
+     * Kick player from the server
+     *
+     * @param msg Disconnect message
+     */
+    public void kick(String msg);
+
+    /**
+     * Gets Socket address
+     *
+     * @return Gets socket address of player
+     */
+    public SocketAddress getSocketAddress();
+
+    /**
+     * Retrieve the entity this player is spectating
+     *
+     * @return Entity being spectated
+     */
+    public MC_Entity getEntitySpectated();
+
+    /**
+     * Sets entity spectated
+     *
+     * @param ent Entity to spectate
+     */
+    public void spectateEntity(MC_Entity ent);
+
+    // 1.9 stuff...
+
+    /**
+     * Get Item in off-hand
+     *
+     * @return Item in off-hand
+     */
+    public MC_ItemStack getItemInOffHand();
+
+    /**
+     * Sets item in off-hand
+     *
+     * @param item Item
+     */
+    public void setItemInOffHand(MC_ItemStack item);
+
+    /**
+     * Set the header and footer of the player list (tab overlay). The header and footer arguments are provided as
+     * plain text and may contain legacy color codes.
+     *
+     * @param header the header
+     * @param footer the footer
+     */
+    void setPlayerListHeaderFooter(String header, String footer);
+
+    /**
+     * Display an inventory gui to the player.
+     *
+     * @param gui the gui
+     */
+    void displayInventoryGUI(MC_InventoryGUI gui);
+
+    /**
+     * Closes any open inventory.
+     */
+    void closeInventory();
+
+    /**
+     * Tests whether the player has been playing on the server before.
+     *
+     * This method is supported for offline players.
+     *
+     * @return true if the player has been playing on the server before
+     */
+    boolean hasPlayedBefore();
+
+    /**
+     * Get the amount of time the player has spent playing on this server.
+     *
+     * This method is supported for offline players.
+     *
+     * @return total online time of the player in milliseconds
+     */
+    long getOnlineTime();
+
+    /**
+     * Get the player's home (as managed by the built-in /home and /sethome commands).
+     *
+     * This method is supported for offline players.
+     *
+     * @return the player's home
+     */
+    MC_Location getHome();
+
+    /**
+     * Set the player's home (as managed by the built-in /home and /sethome commands).
+     *
+     * This method is supported for offline players.
+     *
+     * @param location the new home
+     */
+    void setHome(MC_Location location);
+
+    /**
+     * Get the player's second home (as managed by the built-in /home2 and /sethome2 commands).
+     *
+     * This method is supported for offline players.
+     *
+     * @return the player's home
+     */
+    MC_Location getHome2();
+
+    /**
+     * Set the player's second home (as managed by the built-in /home2 and /sethome2 commands).
+     *
+     * This method is supported for offline players.
+     *
+     * @param location the new home
+     */
+    void setHome2(MC_Location location);
+
+    /**
+     * Send a plugin message to the player.
+     *
+     * @param channel the channel to use
+     * @param data    the data to send
+     */
+    void sendPluginMessage(String channel, byte[] data);
+}
+
diff --git a/src/main/java/PluginReference/MC_PlayerPacketListener.java b/src/main/java/PluginReference/MC_PlayerPacketListener.java
new file mode 100644
index 0000000000000000000000000000000000000000..4c5672b84603f85afd769e7d9c4f7f4a5b880a17
--- /dev/null
+++ b/src/main/java/PluginReference/MC_PlayerPacketListener.java
@@ -0,0 +1,20 @@
+package PluginReference;
+
+/** 
+ * Interface for handling raw network packets outgoing to players.
+ */ 			
+public interface MC_PlayerPacketListener
+{
+	 /** 
+     * Method for handling raw packet data
+     * 
+     * @param plr Player object
+     * @param packetID Minecraft Packet ID
+     * @param data Raw byte data
+     * @param internalPacketClassName internal Packet name
+     * @param ei Event Info w/option to cancel
+     * @return Packet data 
+     */ 			
+	public byte[] handleRawPacket(MC_Player plr, int packetID, byte[] data, String internalPacketClassName, MC_EventInfo ei);
+}
+
diff --git a/src/main/java/PluginReference/MC_PotionEffect.java b/src/main/java/PluginReference/MC_PotionEffect.java
new file mode 100644
index 0000000000000000000000000000000000000000..e78e380d44989e95581a61ffaf012746bf142c85
--- /dev/null
+++ b/src/main/java/PluginReference/MC_PotionEffect.java
@@ -0,0 +1,27 @@
+package PluginReference;
+
+/** 
+ * Potion Effect
+ */ 			
+public class MC_PotionEffect
+{
+	public MC_PotionEffectType type = MC_PotionEffectType.UNSPECIFIED;
+	public int duration = 0;
+	public int amplifier = 0;
+	public boolean ambient = true;
+	public boolean showsParticles = true;
+	
+	/**
+	 * Sets number of arrows sticking out. Up to 127.
+	 *
+     * @param argType Potion Type
+     * @param argDuration Duration in Ticks (1/20th of a second)
+     * @param argAmplifier Amplifier (zero-based so Haste with 2 amplifier is 'Haste III') 
+	 */
+	public MC_PotionEffect(MC_PotionEffectType argType, int argDuration, int argAmplifier)
+	{
+		type = argType;
+		duration = argDuration;
+		amplifier = argAmplifier;
+	}
+}
diff --git a/src/main/java/PluginReference/MC_PotionEffectType.java b/src/main/java/PluginReference/MC_PotionEffectType.java
new file mode 100644
index 0000000000000000000000000000000000000000..db70b6122fa291776e9af7feed90c0dd0c764845
--- /dev/null
+++ b/src/main/java/PluginReference/MC_PotionEffectType.java
@@ -0,0 +1,37 @@
+package PluginReference;
+
+/** 
+ * Type of potion effect
+ */ 			
+public enum MC_PotionEffectType
+{
+	UNSPECIFIED,
+	SPEED,
+	SLOWNESS,
+	HASTE,
+	MINING_FATIGUE,
+	STRENGTH,
+	INSTANT_HEALTH,
+	INSTANT_DAMAGE,
+	JUMP_BOOST,
+	NAUSEA,
+	REGENERATION,
+	RESISTANCE,
+	FIRE_RESISTANCE,
+	WATER_BREATHING,
+	INVISIBILITY,
+	BLINDNESS,
+	NIGHT_VISION,
+	HUNGER,
+	WEAKNESS,
+	POISON,
+	WITHER,
+	HEALTH_BOOST,
+	ABSORPTION,
+	SATURATION,
+	GLOWING,
+	LEVITATION,
+	LUCK,
+	UNLUCK
+	
+}
diff --git a/src/main/java/PluginReference/MC_PrimedTNT.java b/src/main/java/PluginReference/MC_PrimedTNT.java
new file mode 100644
index 0000000000000000000000000000000000000000..302a5e10d5e78c85b274eb32dc35b11674308716
--- /dev/null
+++ b/src/main/java/PluginReference/MC_PrimedTNT.java
@@ -0,0 +1,17 @@
+package PluginReference;
+
+/**
+ * Primed TNT entity.
+ */
+public interface MC_PrimedTNT extends MC_Entity {
+
+    /**
+     * Get the entity that initiated the explosion.
+     *
+     * e.g. if a player causes the explosion by shooting an ignited arrow, this
+     * return the player.
+     *
+     * @return the entity that initiated the explosion
+     */
+    MC_Entity getEntityWhichCausedExplosion();
+}
diff --git a/src/main/java/PluginReference/MC_Projectile.java b/src/main/java/PluginReference/MC_Projectile.java
new file mode 100644
index 0000000000000000000000000000000000000000..5418b60313dfde30779b0b67935efa25bd79b77c
--- /dev/null
+++ b/src/main/java/PluginReference/MC_Projectile.java
@@ -0,0 +1,15 @@
+package PluginReference;
+
+/**
+ * An entity that is a projectile. These are snowballs, enderpearls, expbottles,
+ * eggs, potions as well as all kinds of arrows.
+ *
+ */
+public interface MC_Projectile extends MC_Entity {
+
+    /**
+     * Get the entity that threw/ shot the projectile.
+     * @return entity
+     */
+    MC_Entity getProjectileSource();
+}
diff --git a/src/main/java/PluginReference/MC_Server.java b/src/main/java/PluginReference/MC_Server.java
new file mode 100644
index 0000000000000000000000000000000000000000..c154d8e6665aab19decfad990ff422af492b4ef7
--- /dev/null
+++ b/src/main/java/PluginReference/MC_Server.java
@@ -0,0 +1,472 @@
+package PluginReference;
+
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+
+/**
+ * Represents the Minecraft Server
+ */
+public interface MC_Server {
+
+    /**
+     * Get list of online players
+     *
+     * @return List of player objects
+     */
+    List<MC_Player> getPlayers();
+
+    /**
+     * Get list of offline players.
+     *
+     * @return List of offline player objects
+     */
+    List<MC_Player> getOfflinePlayers();
+
+    /**
+     * Get list of info about loaded plugins
+     *
+     * @return List of PluginInfo objects
+     */
+    List<PluginInfo> getPlugins();
+
+    /**
+     * Get plugin info for a specific plugin
+     *
+     * @param name the plugins name
+     * @return plugin info
+     */
+    PluginInfo getPluginInfo(String name);
+
+    /**
+     * Get a player object of an online player by name
+     *
+     * @param pName Player Name
+     * @return Player object
+     */
+    MC_Player getOnlinePlayerByName(String pName);
+
+    /**
+     * Get a player object of an online player by uuid
+     *
+     * @param uuid player unique id
+     * @return Player object
+     */
+    MC_Player getOnlinePlayerByUUID(UUID uuid);
+
+    /**
+     * Get list of player names matching substring. Useful for implementing Tab feature of commands.
+     *
+     * @param subString Substring for search
+     * @return List of player names
+     */
+    List<String> getMatchingOnlinePlayerNames(String subString);
+
+    /**
+     * Send a message to all players.
+     *
+     * @param msg Message to send
+     */
+    void broadcastMessage(String msg);
+
+    /**
+     * Execute a command as Console
+     *
+     * @param cmd Command to Execute
+     */
+    void executeCommand(String cmd);
+
+    /**
+     * Get list of permissions for a given key
+     *
+     * @param plrKey Permission Key (i.e. player name or UUID)
+     * @return List of permissions
+     */
+    List<String> getPermissions(String plrKey);
+
+    /**
+     * Give a permission to a key
+     *
+     * @param plrKey Key such as player name or UUID
+     * @param perm   Permission string
+     */
+    void givePermission(String plrKey, String perm);
+
+    /**
+     * Take a permission away from a key
+     *
+     * @param plrKey Key such as player name or UUID
+     * @param perm   Permission string
+     */
+    void takePermission(String plrKey, String perm);
+
+    /**
+     * Check if key has permission
+     *
+     * @param plrKey Player key (i.e. name or UUID)
+     * @param perm   Permission
+     * @return True if has permission, False otherwise
+     */
+    boolean hasPermission(String plrKey, String perm);
+
+    /**
+     * Clear all permission data
+     */
+    void clearAllPermissions();
+
+    /**
+     * Get the server spawn protection radius (in number of blocks)
+     *
+     * @return Radius in number of blocks
+     */
+    int getSpawnProtectionRadius(); // range of spawn protection
+
+    /**
+     * Get Server Port, i.e. 25565
+     *
+     * @return Server port number
+     */
+    int getServerPort(); // i.e. 25565
+
+    /**
+     * Get maximum build height (i.e. 255)
+     *
+     * @return Maximum build height
+     */
+    int getMaxBuildHeight();
+    
+    /**
+     * Get maximum players allowed to join.
+     * 
+     * @return Maximum players.
+     */
+    int getMaxPlayerCount();
+
+    /**
+     * Get number of seconds players must wait before reconnecting
+     *
+     * @return Number of Seconds
+     */
+    int getReconnectDelaySeconds();    // how long players have to wait before being able to reconnect
+
+    /**
+     * Set the delay required before a player can reconnect
+     *
+     * @param val Reconnect Delay in seconds
+     */
+    void setReconnectDelaySeconds(int val);
+
+    /**
+     * Sets custom message players see if server closes gracefully
+     *
+     * @param msg Message e.g. "We'll be right back"
+     */
+    void setCustomShutdownMessage(String msg); // Custom shutdown message, like "We'll be right back"
+
+
+    /**
+     * Returns player's exact name given a case-insensitive one. Only works for players who have logged in before.
+     *
+     * @param pName Player name
+     * @return Exact case of player name or NULL if not found.
+     */
+    String getPlayerExactName(String pName); // Only works for players who have logged in before
+
+    /**
+     * Get UUID of player by name
+     *
+     * @param pName player name
+     * @return UUID of player
+     */
+    String getPlayerUUIDFromName(String pName); // ...
+
+    /**
+     * Get list of player names associated with a given UUID.  Should be only one entry until name changing is supported.
+     *
+     * @param uid UUID to inspect
+     * @return List of player names seen with that UUID
+     */
+    List<String> getPlayerNamesFromUUID(String uid); // ...
+
+    /**
+     * Gets the last known player name associated with a UUID
+     *
+     * @param uid UUID of player
+     * @return Last known player name
+     */
+    String getLastKnownPlayerNameFromUUID(String uid);  // ...
+
+    /**
+     * Get World object from dimension number
+     *
+     * @param idxDimension Dimension Number
+     * @return MC_World object
+     */
+    MC_World getWorld(int idxDimension);
+
+    /**
+     * Create an MC_ItemStack given id, count
+     *
+     * @param id    Item ID
+     * @param count Stack Count
+     * @return MC_ItemStack object
+     */
+    MC_ItemStack createItemStack(String id, int count);
+
+    /**
+     * Create an MC_ItemStack given id, count, and dmg/subtype value
+     *
+     * @param id    Item ID
+     * @param count Stack Count
+     * @param dmg   Damage or Subtype
+     * @return MC_ItemStack object
+     */
+    @Deprecated
+    MC_ItemStack createItemStack(int id, int count, int dmg);
+
+    /**
+     * Construct an MC_ItemStack given raw byte data
+     *
+     * @param rawItemData Raw data from calling .serialize() on MC_ItemStack
+     * @return MC_ItemStack object
+     */
+    MC_ItemStack createItemStack(byte[] rawItemData); // raw data from calling .serialize() on MC_ItemStack
+
+    /**
+     * Register a custom plugin command
+     *
+     * @param cmd Object implementing MC_Command
+     */
+    void registerCommand(MC_Command cmd);
+
+    /**
+     * Get a mutable map of all currently registered commands.
+     *
+     * @return the command map
+     */
+    Map<String, MC_Command> getCommandMap();
+
+    /**
+     * Check if online mode
+     *
+     * @return True if online mode, False otherwise
+     */
+    boolean getOnlineMode();
+
+    /**
+     * Gets Rainbow version number
+     *
+     * @return Version number
+     */
+    double getRainbowVersion();
+    
+    /**
+     * Gets Minecraft version number.
+     * 
+     * @return Minecraft version (as String)
+     */
+    String getMinecraftVersion();
+
+    /**
+     * Get current filename of server icon
+     *
+     * @return Server icon filename
+     */
+    String getServerIconFilename();
+
+    /**
+     * Sets server icon players see before joining
+     *
+     * @param arg Server Icon
+     */
+    void setServerIconFilename(String arg);
+
+    /**
+     * Get current server MOTD (Message of the Day)
+     *
+     * @return Message of the Day
+     */
+    String getServerMOTD();
+
+    /**
+     * Sets server MOTD players see before joining
+     *
+     * @param arg Message of the Day
+     */
+    void setServerMOTD(String arg);
+
+    /**
+     * Register a handler to intercept outgoing network packets to player
+     *
+     * @param myListener Object implementing MC_PlayerPacketListener
+     */
+    @Deprecated
+    void registerPlayerPacketListener(MC_PlayerPacketListener myListener);
+
+    /**
+     * Register a handler to intercept incoming network packets to server
+     *
+     * @param myListener Object implementing MC_ServerPacketListener
+     */
+    @Deprecated
+    void registerServerPacketListener(MC_ServerPacketListener myListener);
+
+    /**
+     * Gets info about the currently executing command (or the last command if called from a non-command event).
+     *
+     * @return Command Sender Info
+     */
+    MC_CommandSenderInfo getExecutingCommandInfo();
+
+    /**
+     * Get an MC_Block from a block name
+     *
+     * @param name Block name
+     * @return MC_Block object
+     */
+    MC_Block getBlockFromName(String name);
+
+    /**
+     * Get an MC_Block from a block id
+     *
+     * @param id Block id
+     * @return MC_Block object
+     */
+    @Deprecated
+    MC_Block getBlock(int id);
+
+    /**
+     * Get an MC_Block from a block id and subtype
+     *
+     * @param id      Block id
+     * @param subtype Block subtype
+     * @return MC_Block object
+     */
+    @Deprecated
+    MC_Block getBlock(int id, int subtype);
+
+    /**
+     * Logs a message both to console and server logs
+     *
+     * @param msg Message
+     */
+    void log(String msg);
+
+    /**
+     * Register a world name. If already exists, returns existing identifier.
+     *
+     * @param worldName World Name
+     * @param settings misc configuration
+     * @return Dimension (Integer identifier) for this world
+     */
+    @Deprecated
+    int registerWorld(String worldName, MC_WorldSettings settings);
+
+    /**
+     * Unregister a world
+     *
+     * @param worldName World Name
+     * @return True if unregistered, False if unrecognized
+     */
+    @Deprecated
+    boolean unregisterWorld(String worldName);
+
+
+    /**
+     * Get list of world objects
+     *
+     * @return List of MC_World objects
+     */
+    List<MC_World> getWorlds();
+
+    /**
+     * Add a shaped recipe
+     * <p>
+     * e.g the following code sample adds a recipe for crafting a stone pickaxe
+     * using clean stone.
+     * <pre>
+     * {@code
+     * MC_Server server = RainbowUtils.getServer();
+     * server.addRecipe(server.createItemStack(MC_ID.ITEM_STONE_PICKAXE, 1, 0),
+     *                  "XXX", " I ", " I ",
+     *                  'X', server.createItemStack(MC_ID.BLOCK_STONE, 1, 0),
+     *                  'I', server.createItemStack(MC_ID.ITEM_STICK, 1, 0));
+     * }
+     * </pre>
+     *
+     * @param result      craft result
+     * @param ingredients recipe
+     */
+    void addRecipe(MC_ItemStack result, Object... ingredients);
+
+    /**
+     * Add a shapeless recipe.
+     * <p>
+     * e.g the following code sample adds a recipe that turns rotten flesh into
+     * leather.
+     * <pre>
+     * {@code
+     * MC_Server server = RainbowUtils.getServer();
+     * server.addShapelessRecipe(server.createItemStack(MC_ID.ITEM_LEATHER, 1, 0),
+     *                           server.createItemStack(MC_ID.ITEM_ROTTEN_FLESH, 1, 0));
+     * }
+     * </pre>
+     *
+     * @param result resulting item
+     * @param ingredients required ingredients
+     */
+    void addShapelessRecipe(MC_ItemStack result, MC_ItemStack... ingredients);
+
+    /**
+     * Factory method to create an attribute modifier with a random unique uuid.
+     *
+     * @param name     the name of the attribute modifier
+     * @param operator the operator to use
+     * @param value    the value of the modifier
+     * @return the created attribute modifier
+     */
+    MC_AttributeModifier createAttributeModifier(String name, MC_AttributeModifier.Operator operator, double value);
+
+    /**
+     * Factory method to create an attribute modifier using a given uuid.
+     *
+     * @param uuid     the uuid to use
+     * @param name     the name of the attribute modifier
+     * @param operator the operator to use
+     * @param value    the value of the modifier
+     * @return the created attribute modifier
+     */
+    MC_AttributeModifier createAttributeModifier(UUID uuid, String name, MC_AttributeModifier.Operator operator, double value);
+
+    /**
+     * Create an inventory for use as GUI.
+     *
+     * @param size  the size of the inventory, must be a multiple of 9
+     * @param title the title of the inventory
+     * @return the {@link MC_InventoryGUI} instance
+     */
+    MC_InventoryGUI createInventoryGUI(int size, String title);
+
+    /**
+     * Get an offline player by the name. If the player is online this method returns the same object as
+     * {@link #getOnlinePlayerByName(String)}.
+     *
+     * Also look at the javadoc of {@link MC_Player} to find out which methods are implemented for offline players.
+     *
+     * @param name the name of the player
+     * @return the (offline) player if present
+     */
+    MC_Player getOfflinePlayerByName(String name);
+
+    /**
+     * Get an offline player by the uuid. If the player is online this method returns the same object as
+     * {@link #getOnlinePlayerByUUID(UUID)}.
+     *
+     * Also look at the javadoc of {@link MC_Player} to find out which methods are implemented for offline players.
+     *
+     * @param uuid the uuid of the player
+     * @return the (offline) player if present
+     */
+    MC_Player getOfflinePlayerByUUID(UUID uuid);
+}
+
diff --git a/src/main/java/PluginReference/MC_ServerPacketListener.java b/src/main/java/PluginReference/MC_ServerPacketListener.java
new file mode 100644
index 0000000000000000000000000000000000000000..6c0bd94b50ea4b4ac7c116522f2ff5100adc4c2e
--- /dev/null
+++ b/src/main/java/PluginReference/MC_ServerPacketListener.java
@@ -0,0 +1,22 @@
+package PluginReference;
+
+import java.net.SocketAddress;
+
+/** 
+ * Interface for handling raw network packets incoming to server.
+ */ 			
+public interface MC_ServerPacketListener
+{
+	 /** 
+     * Method for handling raw packet data
+     * 
+     * @param addr Source network address
+     * @param packetID Minecraft Packet ID
+     * @param data Raw byte data
+     * @param internalPacketClassName Internal Packet name
+     * @param ei Event Info w/option to cancel
+     * @return Packet data 
+     */ 			
+	public byte[] handleRawPacket(SocketAddress addr, int packetID, byte[] data, String internalPacketClassName, MC_EventInfo ei);
+}
+
diff --git a/src/main/java/PluginReference/MC_Sign.java b/src/main/java/PluginReference/MC_Sign.java
new file mode 100644
index 0000000000000000000000000000000000000000..592b129841067f81219891fda59a32d278d6fb60
--- /dev/null
+++ b/src/main/java/PluginReference/MC_Sign.java
@@ -0,0 +1,23 @@
+package PluginReference;
+
+import java.util.List;
+
+/** 
+ * A sign
+ */ 			
+public interface MC_Sign
+{
+	 /** 
+     * Get sign text
+     * 
+     * @return List of strings 
+     */ 			
+	public List<String> getLines();
+
+	 /** 
+     * Set sign text
+     * 
+     * @param lines List of strings
+     */ 			
+	public void setLines(List<String> lines);
+}
diff --git a/src/main/java/PluginReference/MC_Skeleton.java b/src/main/java/PluginReference/MC_Skeleton.java
new file mode 100644
index 0000000000000000000000000000000000000000..f8f7c2eea8f04e35d50289d96937919be9ecd483
--- /dev/null
+++ b/src/main/java/PluginReference/MC_Skeleton.java
@@ -0,0 +1,23 @@
+package PluginReference;
+
+/**
+ * A Skeleton
+ */
+public interface MC_Skeleton extends MC_LivingEntity {
+    /**
+     * Get type of skeleton (regular / wither)
+     *
+     * @return Skeleton type enum
+     */
+    @Deprecated
+    MC_SkeletonType getSkeletonType();
+
+    /**
+     * Set type of skeleton (regular, wither)
+     *
+     * @param skellyType Skeleton type
+     */
+    @Deprecated
+    void setSkeletonType(MC_SkeletonType skellyType);
+}
+
diff --git a/src/main/java/PluginReference/MC_SkeletonType.java b/src/main/java/PluginReference/MC_SkeletonType.java
new file mode 100644
index 0000000000000000000000000000000000000000..9d400bec30d839d305165281f3f2f92347de61a7
--- /dev/null
+++ b/src/main/java/PluginReference/MC_SkeletonType.java
@@ -0,0 +1,12 @@
+package PluginReference;
+
+/** 
+ * Skeleton Type
+ */
+@Deprecated
+public enum MC_SkeletonType {
+	UNSPECIFIED,
+	SKELETON,
+	WITHER_SKELETON,
+	STRAY
+}
diff --git a/src/main/java/PluginReference/MC_Wolf.java b/src/main/java/PluginReference/MC_Wolf.java
new file mode 100644
index 0000000000000000000000000000000000000000..56cae881fdacc1d574c731a90f54d9e7afd082a2
--- /dev/null
+++ b/src/main/java/PluginReference/MC_Wolf.java
@@ -0,0 +1,19 @@
+package PluginReference;
+
+/** 
+ * Wolf Entity interface
+ */ 			
+public interface MC_Wolf extends MC_AnimalTameable
+{
+	 /** 
+     * Check if angry
+     * @return True if angry, False otherwise
+     */ 		
+	public boolean getAngry();
+	 /** 
+     * Set angry flag
+     * 
+     * @param flag True if angry, false otherwise
+     */ 			
+	public void setAngry(boolean flag);
+}
diff --git a/src/main/java/PluginReference/MC_World.java b/src/main/java/PluginReference/MC_World.java
new file mode 100644
index 0000000000000000000000000000000000000000..a79d4216ac90f7d833bda7e1197215eba9670f16
--- /dev/null
+++ b/src/main/java/PluginReference/MC_World.java
@@ -0,0 +1,303 @@
+package PluginReference;
+
+import java.util.List;
+
+/** 
+ * Represents a World (or dimension) and allows operations to be performed.
+ */ 			
+public interface MC_World
+{
+	 /** 
+     * Get an MC_Block from a block name
+     * 
+     * @param name Block name
+     * @return MC_Block object
+	 * @deprecated use MC_Server#getBlockFromName instead
+     */ 		
+	@Deprecated
+	public MC_Block getBlockFromName(String name);
+
+	 /** 
+     * Get an MC_Block object at location
+     * 
+     * @param x X-Coordinate
+     * @param y Y-Coordinate
+     * @param z Z-Coordinate
+     * @return MC_Block object 
+     */ 			
+	public MC_Block getBlockAt(int x, int y, int z); 
+
+	 /** 
+     * Get direction a block is facing (or null if doesn't support)
+     * 
+     * @param x X-Coordinate
+     * @param y Y-Coordinate
+     * @param z Z-Coordinate
+     * @return Direction block is facing (or null if doesn't support) 
+     */ 			
+	public MC_DirectionNESWUD getBlockFacing(int x, int y, int z); 
+
+	 /** 
+     * Set block rotation (signs, banners, etc)
+     * 
+     * @param x X-Coordinate
+     * @param y Y-Coordinate
+     * @param z Z-Coordinate
+     * @param rotationValue rotation value (0-15) 
+     */ 			
+	public void setBlockRotation(int x, int y, int z, int rotationValue); 
+
+	
+	 /** 
+     * Set direction a block is facing (or null if doesn't support)
+     * 
+     * @param x X-Coordinate
+     * @param y Y-Coordinate
+     * @param z Z-Coordinate
+     * @param dir Direction block is facing 
+     */ 			
+	public void setBlockFacing(int x, int y, int z, MC_DirectionNESWUD dir); 
+
+	 /** 
+     * Get block rotation (signs, banners, etc)
+     * 
+     * @param x X-Coordinate
+     * @param y Y-Coordinate
+     * @param z Z-Coordinate
+     * @return Gets rotation value for signs and banners 
+     */ 			
+	public int getBlockRotation(int x, int y, int z); 
+	
+	
+	 /** 
+     * Get an MC_Block object at location
+     * 
+     * @param loc Location
+     * @return MC_Block object 
+     */ 			
+	public MC_Block getBlockAt(MC_Location loc);
+
+
+	/**
+	 * Set block at location
+	 *
+	 * @param x X-Coordinate
+	 * @param y Y-Coordinate
+	 * @param z Z-Coordinate
+	 * @param blk MC_Block object
+	 */
+	public void setBlockAt(int x, int y, int z, MC_Block blk);
+
+	/**
+	 * Set block at location
+	 *
+	 * @param loc Location
+	 * @param blk MC_Block object
+	 */
+	public void setBlockAt(MC_Location loc, MC_Block blk);
+	
+	 /** 
+     * Set block at location
+     * 
+     * @param x X-Coordinate
+     * @param y Y-Coordinate
+     * @param z Z-Coordinate
+     * @param blk MC_Block object
+     * @param subType block Subtype
+     */
+	 @Deprecated
+	public void setBlockAt(int x, int y, int z, MC_Block blk, int subType);
+
+	 /** 
+     * Set block at location
+     * 
+     * @param loc Location
+     * @param blk MC_Block object
+     * @param subType block Subtype
+     */
+	 @Deprecated
+	public void setBlockAt(MC_Location loc, MC_Block blk, int subType);
+	
+	 /** 
+     * Break block at location and trigger item drop
+     * 
+     * @param x X-Coordinate
+     * @param y Y-Coordinate
+     * @param z Z-Coordinate
+     * @return True if success, False otherwise 
+     */ 			
+	public boolean breakNaturallyAt(int x, int y, int z);
+	 /** 
+     * Break block at location as if given tool was used
+     * 
+     * @param x X-Coordinate
+     * @param y Y-Coordinate
+     * @param z Z-Coordinate
+     * @param tool Item object
+     * @return True if success, False otherwise 
+     */ 			
+	public boolean breakNaturallyAt(int x, int y, int z, MC_ItemStack tool);
+	
+	// World Info
+	 /** 
+     * Get location of spawn for this world.
+     * 
+     * @return Spawn location 
+     */ 			
+	public MC_Location getSpawnLocation();
+	 /** 
+     * Get name for this world.
+     * 
+     * @return World Name 
+     */ 			
+	public String getName();
+	 /** 
+     * Get list of entities in this world.
+     * 
+     * @return List of entities 
+     */ 			
+	public List<MC_Entity> getEntities();
+	
+	 /** 
+     * Get GameRule setting
+     * 
+     * @param ruleType Boolean Game Rule interested in
+     * @return Game Rule setting 
+     */ 			
+	public boolean getGameRuleBool(MC_GameRuleType ruleType);
+	 /** 
+     * Set a Game Rule
+     * 
+     * @param ruleType GameRule type
+     * @param newVal New Setting
+     */ 			
+	public void setGameRule(MC_GameRuleType ruleType, boolean newVal);
+	
+	 /** 
+     * Get Sign object at location
+     * 
+     * @param loc Location
+     * @return Sign object 
+     */ 			
+	public MC_Sign getSignAt(MC_Location loc);
+	 /** 
+     * Get Chest object at location
+     * 
+     * @param loc Location
+     * @return Chest object 
+     */ 			
+	public MC_Chest getChestAt(MC_Location loc);
+
+    
+	 /** 
+     * Spawn an entity at location
+     * 
+     * @param entType Entity Type
+     * @param loc Location
+     * @param optionalCustomName Custom Entity Name
+     * @return Entity object 
+     */ 			
+	public MC_Entity spawnEntity(MC_EntityType entType, MC_Location loc, String optionalCustomName);
+
+	 /** 
+     * Spawn an Item entity at location
+     * 
+     * @param is ItemStack
+     * @param loc Location
+     * @param throwerName Name of thrower (null if not used)
+     * @return Item Entity object 
+     */ 			
+	public MC_Entity dropItem(MC_ItemStack is, MC_Location loc, String throwerName);
+
+	 /** 
+     * Gets the dimension identifier for this world.
+     * 
+     * @return Integer uniquely identifying this world. 
+     */ 			
+	public int getDimension();
+	
+	 /** 
+     * Gets the Minecraft day/night time value in ticks. Matches '/time query daytime'. Each Minecraft day is 24000 ticks.
+     * 
+     * @return Long type representing day time
+     */ 			
+	public int getDayTime();
+
+	/** 
+     * Gets the world time in ticks. Matches '/time query gametime'. Incremented by one every world tick. Each Minecraft day is 24000 ticks.
+     *  
+     * @return Long type representing game time
+     */ 			
+	public int getGameTime();
+
+	 /** 
+     * Get generic Container object at location
+     * 
+     * @param loc Location
+     * @return MC_Container object 
+     */ 			
+	public MC_Container getContainerAt(MC_Location loc);
+
+	 /** 
+     * Get biome type at location
+     * 
+     * @param x X coordinate
+     * @param z Z coordinate
+     * @return MC_WorldBiomeType value 
+     */ 			
+	public MC_WorldBiomeType getBiomeTypeAt(int x, int z);
+	
+	 /** 
+     * Set biome type at location
+     * 
+     * @param x X coordinate
+     * @param z Z coordinate
+     * @param biomeType Biome 
+     */ 			
+	public void setBiomeTypeAt(int x, int z, MC_WorldBiomeType biomeType);
+	
+	 /** 
+     * Loads chunk at specified coordinate
+     * 
+     * @param cx Chunk X coordinate (i.e. x &gt;&gt; 4)
+     * @param cz Chunk Z coordinate (i.e. z &gt;&gt; 4)
+     * @return True if chunk loaded. False otherwise 
+     */ 			
+	public boolean loadChunk(int cx, int cz);
+
+	 /** 
+     * Check if particular chunk is loaded
+     * 
+     * @param cx Chunk X coordinate (i.e. x &gt;&gt; 4)
+     * @param cz Chunk Z coordinate (i.e. z &gt;&gt; 4)
+     * @return True if chunk loaded. False otherwise 
+     */ 			
+	public boolean isChunkLoaded(int cx, int cz);
+
+	 /** 
+     * Get list of loaded chunks
+     * 
+     * @return List of MC_Chunk objects 
+     */ 			
+	public List<MC_Chunk> getLoadedChunks();
+
+	/**
+	 * Gets the note block at the location.
+	 *
+	 * @param location The location
+	 * @return The note block or null if there is none
+     */
+	MC_NoteBlock getNoteBlockAt(MC_Location location);
+
+    /**
+     * Create an entity given raw byte data
+     *
+     * @param loc Location at which the entity should be spawned.
+     * @param rawEntityData Raw data from calling .serialize() on MC_Entity
+     * @return MC_Entity object
+     */
+    MC_Entity spawnEntity(MC_Location loc, byte[] rawEntityData);
+	
+}
+
+
diff --git a/src/main/java/PluginReference/MC_WorldBiomeType.java b/src/main/java/PluginReference/MC_WorldBiomeType.java
new file mode 100644
index 0000000000000000000000000000000000000000..145674c238e6a09223b54966bf664a87456305a2
--- /dev/null
+++ b/src/main/java/PluginReference/MC_WorldBiomeType.java
@@ -0,0 +1,82 @@
+package PluginReference;
+
+
+public enum MC_WorldBiomeType
+{
+	UNSPECIFIED,
+	
+	OCEAN,
+	PLAINS,
+	DESERT,
+	EXTREME_HILLS,
+	FOREST,
+	TAIGA,
+	SWAMPLAND,
+	RIVER,
+	HELL,
+	THE_END,
+	FROZEN_OCEAN,
+	FROZEN_RIVER,
+	ICE_PLAINS,
+	ICE_MOUNTAINS,
+	MUSHROOM_ISLAND,
+	MUSHROOM_ISLAND_SHORE,
+	BEACH,
+	DESERT_HILLS,
+	FOREST_HILLS,
+	TAIGA_HILLS,
+	EXTREME_HILLS_EDGE,
+	JUNGLE,
+	JUNGLE_HILLS,
+	JUNGLE_EDGE,
+	DEEP_OCEAN,
+	STONE_BEACH,
+	COLD_BEACH,
+	BIRCH_FOREST,
+	BIRCH_FOREST_HILLS,
+	ROOFED_FOREST,
+	COLD_TAIGA,
+	COLD_TAIGA_HILLS,
+	MEGA_TAIGA,
+	MEGA_TAIGA_HILLS,
+	EXTREME_HILLS_PLUS,
+	SAVANNA,
+	SAVANNA_PLATEAU,
+	MESA,
+	MESA_PLATEAU,
+	MESA_PLATEAU_F,
+	VOID,
+	SUNFLOWER_PLAINS,
+	DESERT_M,
+	EXTREME_HILLS_M,
+	FLOWER_FOREST,
+	TAIGA_M,
+	SWAMPLAND_M,
+	ICE_PLAINS_SPIKES,
+	JUNGLE_M,
+	JUNGLE_EDGE_M,
+    BIRCH_FOREST_M,
+	BIRCH_FOREST_HILLS_M,
+	ROOFED_FOREST_M,
+	COLD_TAIGA_M,
+	MEGA_SPRUCE_TAIGA,
+	REDWOOD_TAIGA_HILLS_M,
+	EXTREME_HILLS_PLUS_M,
+	SAVANNA_M,
+	SAVANNA_PLATEAU_M,
+	MESA_M,
+	MESA_PLATEAU_F_M,
+	MESA_PLATEAU_M,
+
+	END_SMALL_ISLANDS,
+	END_MIDLANDS,
+	END_HIGHLANDS,
+	END_BARRENS,
+	WARM_OCEAN,
+	LUKEWARM_OCEAN,
+	COLD_OCEAN,
+	DEEP_WARM_OCEAN,
+	DEEP_LUKEWARM_OCEAN,
+	DEEP_COLD_OCEAN,
+	DEEP_FROZEN_OCEAN,
+}
diff --git a/src/main/java/PluginReference/MC_WorldLevelType.java b/src/main/java/PluginReference/MC_WorldLevelType.java
new file mode 100644
index 0000000000000000000000000000000000000000..1d0263891977851f3af2619fc2b0b3e9825d0305
--- /dev/null
+++ b/src/main/java/PluginReference/MC_WorldLevelType.java
@@ -0,0 +1,11 @@
+package PluginReference;
+
+
+public enum MC_WorldLevelType
+{
+	UNSPECIFIED,
+	DEFAULT,
+	FLAT,
+	LARGE_BIOMES,
+	AMPLIFIED
+}
diff --git a/src/main/java/PluginReference/MC_WorldSettings.java b/src/main/java/PluginReference/MC_WorldSettings.java
new file mode 100644
index 0000000000000000000000000000000000000000..df8eeaf6013778b7e0a29348145d0446180c88dd
--- /dev/null
+++ b/src/main/java/PluginReference/MC_WorldSettings.java
@@ -0,0 +1,11 @@
+package PluginReference;
+
+import java.io.Serializable;
+
+public class MC_WorldSettings implements Serializable
+{
+	public long seed = 0L;
+	public MC_WorldBiomeType biomeType = MC_WorldBiomeType.FOREST;
+	public MC_WorldLevelType levelType = MC_WorldLevelType.DEFAULT;
+	public boolean generateStructures = false;
+}
diff --git a/src/main/java/PluginReference/MC_Zombie.java b/src/main/java/PluginReference/MC_Zombie.java
new file mode 100644
index 0000000000000000000000000000000000000000..bb307815cb2797cc3ca968b3cbf73aa87f937385
--- /dev/null
+++ b/src/main/java/PluginReference/MC_Zombie.java
@@ -0,0 +1,14 @@
+package PluginReference;
+
+/**
+ * Represents a Minecraft Zombie
+ */
+public interface MC_Zombie extends MC_LivingEntity {
+    /**
+     * Check if a Villager zombie
+     *
+     * @return True if a villager, False otherwise
+     */
+    @Deprecated
+    boolean isVillager();
+}
diff --git a/src/main/java/PluginReference/PluginBase.java b/src/main/java/PluginReference/PluginBase.java
new file mode 100644
index 0000000000000000000000000000000000000000..f61f8455de92b98429200ed168ece6e0f57f9f0b
--- /dev/null
+++ b/src/main/java/PluginReference/PluginBase.java
@@ -0,0 +1,751 @@
+package PluginReference;
+
+import com.google.common.base.Preconditions;
+import com.google.common.io.ByteStreams;
+import com.google.common.io.Files;
+import net.md_5.bungee.config.Configuration;
+import net.md_5.bungee.config.ConfigurationProvider;
+import net.md_5.bungee.config.YamlConfiguration;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.InetAddress;
+import java.util.List;
+import java.util.UUID;
+
+/**
+ * Base class for all Rainbow plugins.
+ */
+
+public abstract class PluginBase
+{
+    private boolean initialized = false;
+
+    private File dataFolder;
+
+    private Configuration configuration = null;
+
+    /**
+     * Internal method. Called by the plugin manager after creating an instance of the plugin.
+	 * @param dataFolder folder where the plugin can store its persistent data
+     */
+    public final void init(File dataFolder) {
+        Preconditions.checkState(!initialized, "Plugin instance already initialized.");
+        this.initialized = true;
+        this.dataFolder = dataFolder;
+    }
+
+    /**
+     * Get the configuration file of the plugin. Does not save the default config.
+     * <p>
+     * The file is only read from disk the first time this method is called.
+     *
+     * @return the configuration file
+     */
+    public final Configuration getConfig() {
+        return getConfig(false);
+    }
+
+    /**
+     * Get the configuration files of the plugin.
+     * <p>
+     * The file is only read from disk the first time this method is called.
+     *
+     * @param saveDefaultConfig whether to save the default config, if no config file exists
+     * @return the configuration file
+     */
+    public final Configuration getConfig(boolean saveDefaultConfig) {
+        if (configuration != null) {
+            return configuration;
+        }
+        return reloadConfig(saveDefaultConfig);
+    }
+
+    /**
+     * Reloads the config file from disk.
+     *
+     * @return the configuration file
+     */
+    public final Configuration reloadConfig() {
+        return reloadConfig(false);
+    }
+
+    /**
+     * Reloads the config file from disk.
+     *
+     * @param saveDefaultConfig whether to save the default config, if no config file exists
+     * @return the configuration file
+     */
+    public final Configuration reloadConfig(boolean saveDefaultConfig) {
+        Preconditions.checkState(initialized, "Plugin instance not initialized yet.");
+
+        File configFile = new File(dataFolder, "config.yml");
+
+        if (!configFile.exists() && saveDefaultConfig) {
+            try {
+                Files.createParentDirs(configFile);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+            InputStream defaultConfigStream = getClass().getClassLoader().getResourceAsStream("config.yml");
+            if (defaultConfigStream != null) {
+                try {
+                    ByteStreams.copy(defaultConfigStream, new FileOutputStream(configFile));
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                System.err.println("saveDefaultConfig enabled but no default config provided.");
+            }
+        }
+
+        Configuration defaultConfig = null;
+        InputStream defaultConfigStream = getClass().getClassLoader().getResourceAsStream("config.yml");
+
+        if (defaultConfigStream != null) {
+            defaultConfig = ConfigurationProvider.getProvider(YamlConfiguration.class).load(defaultConfigStream);
+        }
+
+        if (configFile.exists()) {
+            try {
+                return configuration = ConfigurationProvider.getProvider(YamlConfiguration.class).load(configFile, defaultConfig);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+
+        return configuration = defaultConfig;
+    }
+
+    /**
+     * Saves the config file to disk.
+     */
+    public final void saveConfig() {
+        Preconditions.checkState(initialized, "Plugin instance not initialized yet.");
+
+        File configFile = new File(dataFolder, "config.yml");
+        if (!configFile.exists()) {
+            try {
+                Files.createParentDirs(configFile);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+
+        try {
+            ConfigurationProvider.getProvider(YamlConfiguration.class).save(configuration, configFile);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+	// Core events
+	 /**
+     * Called when a plugin is loaded. Save a reference to passed in MC_Server object.
+     *
+     * @param argServer Reference to Rainbow server object.
+     */
+	public void onStartup(MC_Server argServer) {}
+	 /**
+     * Called when server is shutting down
+     */
+	public void onShutdown()  {}
+	 /**
+     * Called every tick (1/20th of a second). If implementing, make sure this returns fast.
+     *
+     * @param tickNumber Tick Number
+     */
+	public void onTick(int tickNumber)  {}
+
+	// Login/Logout...
+	/**
+     * Called when a player logs in. Note use onPlayerJoin if you need to interact with the player such as send messages.
+     *
+     * @param playerName Player Name
+     * @param uuid Player UUID
+     * @param ip Player IP Address
+     */
+	@Deprecated
+	public void onPlayerLogin(String playerName, UUID uuid, String ip)  {}
+
+	/**
+	 * Called when a player logs in. Note use onPlayerJoin if you need to interact with the player such as send messages.
+	 *
+	 * If the player will be kicked because he is banned, a whitelist is active or the server is full,
+	 * then ei.isCancelled is true and ei.tag holds the reason why the player will be disconnected.
+	 *
+	 * Setting ei.isCancelled to true will disconnect the player. If you do that set ei.tag to the disconnect reason
+	 * displayed to the client.
+	 *
+	 * Setting ei.isCancelled to false will allow the player to connect, even if he is banned or the server is full.
+	 *
+	 * @param playerName Player Name
+	 * @param uuid Player UUID
+	 * @param address Remote player address
+	 * @param ei ei.isCancelled can be used to disallow the player to connect to the server. In that case ei.tag will be the disconnect reason.
+	 */
+	public void onPlayerLogin(String playerName, UUID uuid, InetAddress address, MC_EventInfo ei)  {}
+
+	 /**
+     * Called when a player logs out
+     *
+     * @param playerName Player Name
+     * @param uuid Player UUID
+     */
+	public void onPlayerLogout(String playerName, UUID uuid)  {}
+
+	 /**
+     * Called after an Interact (right-click) on something happened.
+     *
+     * @param plr Player Object
+     * @param loc Location Interacted
+     * @param isHandItem Item in Player's Hand
+     */
+	public void onInteracted(MC_Player plr, MC_Location loc, MC_ItemStack isHandItem)  {}
+
+	 /**
+     * Called after an item is placed.
+     *
+     * @param plr Player that placed object.
+     * @param loc Location placed
+     * @param isHandItem Item in Player's Hand
+     * @param locPlacedAgainst Location item was placed against
+     * @param dir Direction in which the item was placed
+     */
+	public void onItemPlaced(MC_Player plr, MC_Location loc, MC_ItemStack isHandItem, MC_Location locPlacedAgainst, MC_DirectionNESWUD dir)  {}
+
+	 /**
+     * [OLD VERSION] Called after a block was broken.
+     *
+     * @param plr Player that broke block.
+     * @param loc Location of broken block
+     * @param blockKey Minecraft integer representation of the block (See BlockHelper.getBlockID_FromKey)
+     */
+	@Deprecated
+	public void onBlockBroke(MC_Player plr, MC_Location loc, int blockKey)  {}
+
+	 /**
+     * Called after a block was broken.
+     *
+     * @param plr Player that broke block.
+     * @param loc Location of broken block
+     * @param blk Block that was broken
+     */
+	public void onBlockBroke(MC_Player plr, MC_Location loc, MC_Block blk)  {}
+
+	 /**
+     * Called after a player death
+     *
+     * @param plrVictim Victim
+     * @param plrKiller Killer (if there is one)
+     * @param dmgType Damage Type
+     * @param deathMsg Death Message
+     */
+	public void onPlayerDeath(MC_Player plrVictim, MC_Player plrKiller, MC_DamageType dmgType, String deathMsg)  {}
+
+	/**
+     * Called when a player respawns after death
+     *
+     * @param plr Player object
+     */
+	public void onPlayerRespawn(MC_Player plr)  {}
+
+	// Cancellable events...
+	 /**
+     * Called for all player input. Useful if need to inspect input outside of registered commands.
+     * Note: Use MC_Server.registerCommand for most plugin command interaction.
+     *
+     * @param plr Player object
+     * @param msg Incoming Player Input
+     * @param ei Event Info w/cancel option
+     */
+	public void onPlayerInput(MC_Player plr, String msg, MC_EventInfo ei)  {}
+	 /**
+     * Called for all console input.
+     *
+     * @param cmd Console Input
+     * @param ei Event Info w/cancel option
+     */
+	public void onConsoleInput(String cmd, MC_EventInfo ei) {}
+
+	 /**
+     * Called when a player attempts a block break.
+     *
+     * @param plr Player Object
+     * @param loc Location of Block
+     * @param ei Event Info w/cancel option
+     */
+	public void onAttemptBlockBreak(MC_Player plr, MC_Location loc, MC_EventInfo ei)  {}
+	 /**
+     * Called when a player attempts to either place or interact with a block
+     *
+     * @param plr Player Object
+     * @param loc Location of Block
+     * @param ei Event Info w/cancel option
+     * @param dir Direction of the interaction
+	 * @deprecated this is only called for main hand interactions
+     */
+	@Deprecated
+	public void onAttemptPlaceOrInteract(MC_Player plr, MC_Location loc, MC_EventInfo ei, MC_DirectionNESWUD dir)  {}
+	/**
+	 * Called when a player attempts to either place or interact with a block
+	 *
+	 * @param plr Player Object
+	 * @param loc Location of Block
+	 * @param dir Direction of the interaction
+	 * @param hand Which hand the player uses
+	 * @param ei Event Info w/cancel option
+	 */
+	public void onAttemptPlaceOrInteract(MC_Player plr, MC_Location loc, MC_DirectionNESWUD dir, MC_Hand hand, MC_EventInfo ei)  {}
+	 /**
+     * Called when an explosion occurs but not for individual blocks.
+     *
+     * @param loc Location of Block
+     * @param ei Event Info w/cancel option
+     */
+	public void onAttemptExplosion(MC_Location loc, MC_EventInfo ei)  {}
+
+	 /**
+     * Called when an explosion occurs but you can selectively cancel individual blocks.
+     * To prevent a block location from exploding, remove from the list.
+     *
+     * @param ent Entity involved in the explosion
+     * @param locs List of block locations
+	 * @return whether there are changes to the event.
+     */
+	public boolean onAttemptExplodeSpecific(MC_Entity ent, List<MC_Location> locs) {return false;}
+
+	 /**
+     * Called when a player attempts to damage a Painting or Item Frame
+     *
+     * @param plr Player Object
+     * @param loc Location of Block
+     * @param entType Type of hanging entity
+     * @param ei Event Info w/cancel option
+     */
+	public void onAttemptDamageHangingEntity(MC_Player plr, MC_Location loc, MC_HangingEntityType entType, MC_EventInfo ei)  {}
+	 /**
+     * Called when a player attempts to interact with an Item Frame
+     *
+     * @param plr Player Object
+     * @param loc Location of Block
+     * @param actionType Action Type
+     * @param ei Event Info w/cancel option
+     */
+	public void onAttemptItemFrameInteract(MC_Player plr, MC_Location loc, MC_ItemFrameActionType actionType , MC_EventInfo ei)  {}
+	 /**
+     * Called when a player is receiving a potion effect (from potion or beacon etc).
+     *
+     * @param plr Player Object
+     * @param potionType Type of Effect
+     * @param ei Event Info w/cancel option
+     */
+	public void onAttemptPotionEffect(MC_Player plr, MC_PotionEffectType potionType, MC_EventInfo ei)  {}
+	 /**
+     * Called when a player teleport is occurring.
+     *
+     * @param plr Player Object
+     * @param loc Location of Block
+     * @param ei Event Info w/cancel option
+     */
+	public void onAttemptPlayerTeleport(MC_Player plr, MC_Location loc, MC_EventInfo ei)  {}
+	 /**
+     * Called when a player changes dimension (Nether, TheEnd, etc)
+     *
+     * @param plr Player Object
+     * @param newDimension Dimension IDX (0=world, 1=TheEnd, -1=Nether)
+     * @param ei Event Info w/cancel option
+     */
+	public void onAttemptPlayerChangeDimension(MC_Player plr, int newDimension, MC_EventInfo ei)  {}
+	 /**
+     * Called when a player attempts to drop an item
+     *
+     * @param plr Player Object
+     * @param is Item being dropped.
+     * @param ei Event Info w/cancel option
+     */
+	public void onAttemptItemDrop(MC_Player plr, MC_ItemStack is, MC_EventInfo ei)  {}
+	 /**
+     * Called when a player attempts to attack an entity
+     *
+     * @param plr Player Object
+     * @param ent Entity being attacked
+     * @param ei Event Info w/cancel option
+     */
+	public void onAttemptAttackEntity(MC_Player plr, MC_Entity ent, MC_EventInfo ei)  {}
+	 /**
+     * Called when an entity is about to take damage.
+     *
+     * @param ent Entity Object
+     * @param dmgType Damage Type
+     * @param amt Amount of Damage
+     * @param ei Event Info w/cancel option
+     */
+	public void onAttemptEntityDamage(MC_Entity ent, MC_DamageType dmgType, double amt, MC_EventInfo ei)  {} // replaced onAttemptPlayerTakeDamage
+
+	 /**
+     * Called when a new column of terrain needs generating in default world.
+     *
+     * @param x X-Coordinate of column
+     * @param z Z-Coordinate of column
+     * @param data Generated Column data
+     */
+	public void onGenerateWorldColumn(int x, int z, MC_GeneratedColumn data) {}
+
+	 /**
+     * Called when a piston fires
+     *
+     * @param loc Location of Piston
+     * @param dir Direction of action
+     * @param ei Event Info w/cancel option
+     */
+	public void onAttemptPistonAction(MC_Location loc, MC_DirectionNESWUD dir, MC_EventInfo ei)  {}
+	 /**
+     * Called when a block flows (i.e. water, lava)
+     *
+     * @param loc Location of Flow
+     * @param blk Block being flowed
+     * @param ei Event Info w/cancel option
+     */
+	public void onAttemptBlockFlow(MC_Location loc, MC_Block blk, MC_EventInfo ei)  {}
+
+	 /**
+     * Called when most containers is opened.
+     * This event is not currently called for Crafting Table, Enchanting Table, Player Inventory, and Villager trades.
+     *
+     * @param plr Player object
+     * @param items Items in container
+     * @param internalClassName Internal Value for future use
+     */
+	public void onContainerOpen(MC_Player plr, List<MC_ItemStack> items, String internalClassName) {}
+
+	 /**
+     * Called when a player moves.  This is called frequently so plugins need to return quickly.
+     *
+     * @param plr Player object
+     * @param locFrom Location moving from
+     * @param locTo Location moving to
+     * @param ei Event Info w/cancel option
+     */
+	public void onAttemptPlayerMove(MC_Player plr, MC_Location locFrom, MC_Location locTo, MC_EventInfo ei)  {}
+
+	 /**
+     * Called when a player is about to receive a sound effect from server.
+     *
+     * @param plr Player object
+     * @param soundName Sound name
+     * @param loc Location of sound
+     * @param ei Event Info w/cancel option
+     */
+	public void onPacketSoundEffect(MC_Player plr, String soundName, MC_Location loc, MC_EventInfo ei)  {}
+
+	 /**
+     * Called after a player is joined and is able to interact and receive messages
+     *
+     * @param plr Player object
+     */
+	public void onPlayerJoin(MC_Player plr) {}
+
+	 /**
+     * Called when a sign is changing. Plugins can change lines
+     *
+     * @param plr Player object
+     * @param sign MC_Sign object
+     * @param loc Location of sign
+     * @param newLines Sign text lines (can be modified)
+     * @param ei Event Info w/cancel option
+     */
+	public void onSignChanging(MC_Player plr, MC_Sign sign, MC_Location loc, List<String> newLines, MC_EventInfo ei) {}
+	 /**
+     * Called after a sign update occurs
+     *
+     * @param plr Player object
+     * @param sign MC_Sign object
+     * @param loc Location of sign
+     */
+	public void onSignChanged(MC_Player plr, MC_Sign sign, MC_Location loc) {}
+
+	 /**
+     * Called by Rainbow to get details about your plugin.
+     *
+     * @return PluginInfo object
+     */
+	public PluginInfo getPluginInfo() { return null; }
+
+	 /**
+     * Called when an entity is about to spawn.
+     *
+     * @param ent Entity
+     * @param ei Event Info w/cancel option
+     */
+	public void onAttemptEntitySpawn(MC_Entity ent, MC_EventInfo ei) {}
+
+	 /**
+     * Called when server has finished loading.
+     * For example, after "Done." is shown in console.
+     */
+	public void onServerFullyLoaded() {}
+
+	 /**
+     * Called when a hopper is about to receive an item.
+     *
+     * @param loc Location of hopper
+     * @param is Item involved
+     * @param isMinecartHopper True if a Minecart Hopper, False otherwise
+     * @param ei Event Info w/cancel option
+     */
+	public void onAttemptHopperReceivingItem(MC_Location loc, MC_ItemStack is, boolean isMinecartHopper, MC_EventInfo ei)  {}
+
+	 /**
+     * Called when a book is about to change.
+     *
+     * @param plr Player object
+     * @param bookContent Array of book data. Index 0 is author, 1 is title, 2+ are page data. If not signed, author/title are null.
+     * @param ei Event Info w/cancel option
+     */
+	public void onAttemptBookChange(MC_Player plr, List<String> bookContent, MC_EventInfo ei) {} // bookContent index: 0=author, 1=title, 2=page1, 3=page2, etc...  If not signed, author/title are null.
+
+	 /**
+     * Called when a farmland is about to get trampled
+     *
+     * @param ent Entity trampling
+     * @param loc Location of farmland block (about to turn to DIRT)
+     * @param ei Event Info w/cancel option
+     */
+	public void onAttemptCropTrample(MC_Entity ent, MC_Location loc, MC_EventInfo ei) {}
+	 /**
+     * Called when a player lands from a fall or jump.
+     *
+     * @param ent Entity trampling
+     * @param fallDistance fall distance in blocks
+     * @param loc Location of impact
+     * @param isWaterLanding True if landed in water, false otherwise
+     */
+	public void onFallComplete(MC_Entity ent, float fallDistance, MC_Location loc, boolean isWaterLanding) {}
+	 /**
+     * Called when a player interacts with an Armor Stand
+     *
+     * @param plr Player interacting
+     * @param entStand Armor Stand Entity
+     * @param actionType Type of interaction
+     * @param ei Event Info w/cancel option
+     */
+	public void onAttemptArmorStandInteract(MC_Player plr, MC_Entity entStand, MC_ArmorStandActionType actionType, MC_EventInfo ei)  {}
+
+	 /**
+     * Called when a non-player entity dies
+     *
+     * @param entVictim Victim that died
+     * @param entKiller Killer (if exists)
+     * @param dmgType Damage Type
+     */
+	public void onNonPlayerEntityDeath(MC_Entity entVictim, MC_Entity entKiller, MC_DamageType dmgType) {}
+
+	 /**
+     * Called when a player attempts to use an item, even into the air or not a valid item use.
+     * One use is catching thrown objects before they're thrown or for inventing new uses for custom items.
+     *
+     * @param plr Player using item
+     * @param is Item being used
+     * @param ei Event Info w/cancel option
+     */
+	public void onAttemptItemUse(MC_Player plr, MC_ItemStack is, MC_EventInfo ei)  {}
+
+	 /**
+     * Called whenever a permission check occurs.  Override if you manage permissions.
+     *
+     * @param playerKey Permission Key (e.g. player name or UUID)
+     * @param permission Permission String
+     * @return True if allowed, False if not, Null means 'let Rainbow decide'
+     */
+	public Boolean onRequestPermission(String playerKey, String permission) { return null; }
+
+	 /**
+     * Called when any container closes, even player inventory
+     *
+     * @param plr Player closing container
+     * @param containerType Type of container
+     */
+	public void onContainerClosed(MC_Player plr, MC_ContainerType containerType) {}
+	 /**
+     * Called when a player attempts to pickup an item
+     *
+     * @param plr Player making pick up
+     * @param is Item being picked up (NULL for XP Orb pickups)
+     * @param isXpOrb True if XP Orb, False otherwise
+     * @param ei Event Info w/cancel option
+     */
+	public void onAttemptItemPickup(MC_Player plr, MC_ItemStack is, boolean isXpOrb, MC_EventInfo ei) {}
+
+	 /**
+     * Called when a player interacts with an entity
+     *
+     * @param plr Player interacting
+     * @param ent Entity being interacted with
+     * @param ei Event Info w/cancel option
+     */
+	public void onAttemptEntityInteract(MC_Player plr, MC_Entity ent, MC_EventInfo ei) {}
+
+	 /**
+     * Called after a player finished crafting something.
+     *
+     * @param plr Player object
+     * @param isCraftedItem Item Crafted
+     */
+	public void onItemCrafted(MC_Player plr, MC_ItemStack isCraftedItem) {}
+
+
+	 /**
+     * Called when a player starts sleeping
+     *
+     * @param plr Player object
+     * @param blk Bed Block
+     */
+	//public void onPlayerBedEnter(MC_Player plr, MC_Block blk) {}
+
+	 /**
+     * Called when a player starts sleeping
+     *
+     * @param plr Player object
+     * @param blkBed Bed Block
+     * @param locBed Location of Bed Block
+     */
+	public void onPlayerBedEnter(MC_Player plr, MC_Block blkBed, MC_Location locBed) {}
+
+	 /**
+     * Called when a player stops sleeping
+     *
+     * @param plr Player object
+     * @param blkBed Bed Block
+     * @param locBed Location of Bed Block
+     */
+	public void onPlayerBedLeave(MC_Player plr, MC_Block blkBed, MC_Location locBed) {}
+
+
+	 /**
+     * Called before a block is placed.
+     *
+     * @param plr Player that placed object.
+     * @param loc Location placed
+     * @param blk Potential Block
+     * @param isHandItem Item in Player's Hand
+     * @param locPlacedAgainst Location item was placed against
+     * @param dir Direction in which the item was placed
+     * @param ei Event Info w/cancel option
+     */
+	public void onAttemptBlockPlace(MC_Player plr, MC_Location loc, MC_Block blk, MC_ItemStack isHandItem, MC_Location locPlacedAgainst, MC_DirectionNESWUD dir, MC_EventInfo ei)  {}
+
+	 /**
+     * Called before a living entity dies
+     *
+     * @param entVictim Victim
+     * @param entKiller Killer (if there is one)
+     * @param dmgType Damage Type
+     * @param dmgAmount Damage Amount
+     */
+	public void onAttemptDeath(MC_Entity entVictim, MC_Entity entKiller, MC_DamageType dmgType, float dmgAmount)  {}
+
+	 /**
+     * Called when fishing rod is reeled in but before action taken.
+     *
+     * @param plr Player fishing
+     * @param isCatch If catching item, the item. Otherwise null.
+     * @param entCatch If reeling an entity, the entity. Otherwise null.
+     * @param groundCatch True if cork was stuck in ground when reeled in.
+     * @param ei Event Info w/cancel option. A cancel will avoid item award or entity pull back
+     */
+	public void onAttemptFishingReel(MC_Player plr, MC_ItemStack isCatch, MC_Entity entCatch, boolean groundCatch, MC_EventInfo ei)  {}
+
+
+	 /**
+     * Called when there is a 'miscellaneous' entity grief not specifically handled elsewhere.
+     *
+     * @param ent Entity griefing
+     * @param loc Location of grief
+     * @param griefType Type of grief
+     * @param ei Event Info w/cancel option.
+     */
+	public void onAttemptEntityMiscGrief(MC_Entity ent, MC_Location loc, MC_MiscGriefType griefType, MC_EventInfo ei) {}
+
+	 /**
+     * Called when a spectator attempts to spectate an entity (or cancel spectating)
+     *
+     * @param plr Player attempting spectate
+     * @param ent Entity target (if null, cancelling spectate)
+     * @param ei Event Info w/cancel option
+     */
+	public void onAttemptSpectateEntity(MC_Player plr, MC_Entity ent, MC_EventInfo ei) {}
+
+	 /**
+     * Called when an item is about to be eject from a dispenser or dropper.
+     * If index is negative, it's an 'empty fire'.
+     *
+     * @param loc Location of dispenser
+     * @param idxItem Index of item to be dispensed
+     * @param container Container interface for get/set items inside dispenser
+     * @param ei Event Info w/cancel option
+     */
+	public void onAttemptDispense(MC_Location loc, int idxItem, MC_Container container, MC_EventInfo ei) {}
+
+	/**
+	 * Called when an entity is pushed by another entity.
+	 *
+	 * @param entity entity
+	 * @param pushedEntity pushed entity
+	 * @param velocity velocity applied to the pushed entity, can be changed
+     * @param ei event info, can be cancelled
+     */
+	public void onEntityPushed(MC_Entity entity, MC_Entity pushedEntity, MC_FloatTriplet velocity, MC_EventInfo ei) {}
+
+	/**
+	 * Called when a projectile is about to hit an entity.
+	 *
+	 * Canceling the event will cause the projectile to fly through the entity rather than hit it. It will however not
+	 * remove the projectile from the world. Use {@link MC_Entity#removeEntity()} to remove the projectile from the world.
+	 *  @param projectile the projectile
+	 * @param entity the entity which is hit
+	 * @param hitLocation the location where the entity was hit
+	 * @param ei event info, can be cancelled
+	 */
+    public void onAttemptProjectileHitEntity(MC_Projectile projectile, MC_Entity entity, MC_Location hitLocation, MC_EventInfo ei) {
+    }
+
+    /**
+     * Called when a projectile is about to hit a block.
+     * <p>
+     * Canceling the event will cause the projectile to fly through the block rather than hit it. It will however not
+     * remove the projectile from the world. Use {@link MC_Entity#removeEntity()} to remove the projectile from the world.
+     *  @param projectile    the projectile
+     * @param blockLocation the location of the block which is hit
+	 * @param blockFaceHit  black face that has been hit
+	 * @param hitLocation   the location where the block was hit
+	 * @param ei            event info, can be cancelled
+	 */
+    public void onAttemptProjectileHitBlock(MC_Projectile projectile, MC_Location blockLocation, MC_DirectionNESWUD blockFaceHit, MC_Location hitLocation, MC_EventInfo ei) {
+    }
+
+    /**
+     * Called when a player is about to be kicked. The event can be cancelled in which case the player won't be kicked.
+     * The event is also called if a player is being kicked by a plugin.
+     *
+     * @param player the player
+     * @param reason the reason why the player is kicked
+     * @param ei     event info, can be cancelled
+     */
+    public void onPlayerKick(MC_Player player, String reason, MC_EventInfo ei) {
+    }
+
+    /**
+     * Called when the player receives a plugin message.
+     *
+     * @param channel the channel through which the message was sent
+     * @param data    the data
+     * @param player  the player who sent the message
+     */
+    public void onPluginMessage(String channel, byte[] data, MC_Player player) {
+
+    }
+}
+
diff --git a/src/main/java/PluginReference/PluginInfo.java b/src/main/java/PluginReference/PluginInfo.java
new file mode 100644
index 0000000000000000000000000000000000000000..096f01ca0aaaffde1b02091beb38375ea4e10f93
--- /dev/null
+++ b/src/main/java/PluginReference/PluginInfo.java
@@ -0,0 +1,50 @@
+package PluginReference;
+
+import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
+
+/** 
+ * Information about a plugin
+ */ 			
+public class PluginInfo
+{
+	 /** 
+     * Plugin Description
+     */ 			
+	public String description = null;
+	 /** 
+     * Plugin Version (optional)
+     */ 			
+	public String version = null;
+	 /** 
+     * Event order/priority. Use negative value to get called earlier than default, otherwise higher. Use extreme values if you want to force yourself to begin or end of plugin order
+     */ 			
+	public double eventSortOrder = 0.0f; 
+
+	/** 
+     * If require events *before* another plugin, add those plugin names here
+     */ 			
+	public List<String> pluginNamesINeedToGetEventsBefore = null; 
+	/** 
+     * // If require events *after* another plugin, add those plugin names here
+     */ 			
+	public List<String> pluginNamesINeedToGetEventsAfter = null; 
+	/** 
+     * Optional data (can be used for inter-plugin communication)
+     */ 			
+	public ConcurrentHashMap<String, String> optionalData = new ConcurrentHashMap<String, String>(); 
+
+	// The below will be set by Rainbow, you can use if needed after retrieving with server.getPlugins()
+	/** 
+     * Plugin name (set by Rainbow after getPluginInfo call)
+     */ 			
+	public String name = null;
+	/** 
+     * Plugin path (set by Rainbow after getPluginInfo call)
+     */ 			
+	public String path = null;
+	/** 
+     * Reference to 'MyPlugin' object (set by Rainbow after getPluginInfo call)
+     */ 			
+	public PluginBase ref = null;	
+}
diff --git a/src/main/java/PluginReference/RainbowUtils.java b/src/main/java/PluginReference/RainbowUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..795107a811478adc7b45ed3fa7f7fe70802e036f
--- /dev/null
+++ b/src/main/java/PluginReference/RainbowUtils.java
@@ -0,0 +1,347 @@
+package PluginReference;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+/** 
+ * Collection of utility functions available to Rainbow plugins
+ */ 			
+public class RainbowUtils
+{
+	private static MC_Server server;
+
+	/**
+	 * Set the server instance. For internal use only. Should not be used by
+	 * plugins.
+	 * @param server the server instance
+     */
+	public static void setServer(MC_Server server) {
+		RainbowUtils.server = server;
+	}
+
+	/**
+	 * Get an instance of the MC_Server object.
+	 * @return the server
+     */
+	public static MC_Server getServer() {
+		return server;
+	}
+	 /** 
+     * Get a short description of a number of milliseconds.
+     * 
+     * @param ms Milliseconds
+     * @return String representation like 01m 23s if under 60 minutes, otherwise like 01h 23m
+     */ 			
+	public static String TimeDeltaString_JustMinutesSecs(long ms) 
+	{
+		long totalSecs = ms / 1000;
+		long totalMins = ms / 1000 / 60;
+		if(totalMins >= 60)
+		{
+			// If 60m+, go with hour+minute display
+			long totalHours = totalMins / 60;
+
+			return String.format("%02dh %02dm", totalHours, totalMins%60);
+		}
+		
+		return String.format("%02dm %02ds", totalMins, totalSecs%60);
+	}
+	
+	 /** 
+     * Get a comma separated list (sorted) from a collection of strings.
+     * 
+     * @param arr Array of Strings
+     * @return Comma separated list
+     */ 			
+	public static String GetCommaList(Collection<String> arr)
+	{
+		if((arr == null) || (arr.size() <= 0)) return "";
+		return GetCommaList(arr, true);
+	}
+
+	 /** 
+     * Get a comma separated list from a collection of strings.
+     * 
+     * @param arr Array of Strings
+     * @param doSort option to sort
+     * @return Comma separated list
+     */ 			
+	public static String GetCommaList(Collection<String> arr, boolean doSort)
+	{
+		ArrayList<String> list = new ArrayList<String>(arr);
+		
+		StringBuffer buf = new StringBuffer();
+		Collections.sort(list);
+		for(String str : list)
+		{
+			if(buf.length() > 0) buf.append(", ");
+			buf.append(str);
+		}
+		return buf.toString();
+	}
+	 /** 
+     * Get a comma separated list from an array of strings.
+     * 
+     * @param args Array of Strings
+     * @return Comma separated list
+     */ 			
+	public static String GetCommaList(String[] args)
+	{
+		if(args == null) return "";
+		return GetCommaList(Arrays.asList(args));
+	}
+	
+	// -------------------------------------------------------------------
+
+
+	 /** 
+     * Concatenate a string array with spaces.
+     * For example if 2 strings "hello" and "world" passed in, result is "hello world".
+     * 
+     * @param args Array of Strings
+     * @param startIdx Starting Index
+     * @return Concatenated list with spaces
+     */ 			
+	public static String ConcatArgs(String[] args, int startIdx) {
+		StringBuilder sb = new StringBuilder();
+		for (int i = startIdx; i < args.length; i++) {
+			if (sb.length() > 0) {
+				sb.append(" ");
+			}
+			sb.append(args[i]);
+		}
+		return sb.toString();
+	}
+	
+	
+	
+	 /** 
+     * Extracts an Integer 'argument' from a string with a space in between.
+     * For example, use on "/mycommand 123" to get "123".
+     * 
+     * @param msg String to parse
+     * @param defaultValue Default value if error obtaining
+     * @return Resulting Integer
+     */ 			
+	public static Integer GetIntegerArgument(String msg, Integer defaultValue)
+	{
+		int idxSpace = msg.indexOf(" ");
+		if(idxSpace >= 0)
+		{
+			try
+			{
+				return Integer.parseInt(msg.substring(idxSpace+1));
+			}
+			catch(Exception exc)
+			{
+			}
+		}
+		return defaultValue;
+	}
+	// -------------------------------------------------------------------
+
+	
+	// Create a colorful rainbow string.  I.e.  RainbowString("Hello World")
+	// -------------------------------------------------------------------
+	 /** 
+     * Creates a rainbow colored string.
+     * 
+     * @param str String to convert to rainbow format
+     * @return Rainbow colored string
+     */ 			
+	public static String RainbowString(String str) {
+		return RainbowString(str, "");
+	}
+
+	 /** 
+     * Creates a rainbow colored string (with options).
+     * 
+     * @param str String to convert to rainbow format
+     * @param ctl "b" for bold, "i" for italic, "u" for underline, or combination.
+     * @return Rainbow colored string
+     */ 			
+	public static String RainbowString(String str, String ctl) {
+		if (ctl.equalsIgnoreCase("x")) return str;
+
+		StringBuilder sb = new StringBuilder();
+		int idx = 0;
+		boolean useBold = ctl.indexOf('b') >= 0;
+		boolean useItalics = ctl.indexOf('i') >= 0;
+		boolean useUnderline = ctl.indexOf('u') >= 0;
+
+		for (int i = 0; i < str.length(); i++) {
+			if (idx % 6 == 0) sb.append(ChatColor.RED);
+			else if (idx % 6 == 1) sb.append(ChatColor.GOLD);
+			else if (idx % 6 == 2) sb.append(ChatColor.YELLOW);
+			else if (idx % 6 == 3) sb.append(ChatColor.GREEN);
+			else if (idx % 6 == 4) sb.append(ChatColor.AQUA);
+			else if (idx % 6 == 5) sb.append(ChatColor.LIGHT_PURPLE);
+
+			if (useBold) sb.append(ChatColor.BOLD);
+			if (useItalics) sb.append(ChatColor.ITALIC);
+			if (useUnderline) sb.append(ChatColor.UNDERLINE);
+
+			sb.append(str.charAt(i));
+
+			if (str.charAt(i) != ' ') idx++;
+
+		}
+		return sb.toString();
+	}
+	// -------------------------------------------------------------------
+
+	// Break input string into 'tokens' (individual strings)
+	 /** 
+     * Convert a space-separated string into an array of strings.
+     * 
+     * @param msg String separated by spaces
+     * @return String array of tokens in string.
+     */ 			
+	public static String[] GetTokens(String msg)
+	{
+    	return msg.split("\\s+");
+	}
+
+	
+	 /** 
+     * Get a padded string such that when displayed by Minecraft's default font will align to a specified length.
+     * Useful for sending column output.
+     * 
+     * @param str String to align.
+     * @param padLen Length to pad
+     * @return Padded string
+     */ 			
+	public static String TextLabel(String str, int padLen) {
+		return str + ChatColor.DARK_GRAY + TextAlignTrailerPerfect(str, padLen);
+	}
+
+	 /** 
+     * Constructs padded trailer used by TextLabel() for aligning text.
+     * 
+     * @param str String to align.
+     * @param padLen Length to pad
+     * @return Padded string
+     */ 			
+	public static String TextAlignTrailerPerfect(String str, int padLen) {
+		StringBuffer tgt = new StringBuffer();
+
+		int pixelsTaken = 0;
+		for (int i = 0; i < str.length(); i++) {
+			char ch = str.charAt(i);
+
+			if (ch == 'f') pixelsTaken += 5;
+			else if (ch == 'i') pixelsTaken += 2;
+			else if (ch == ',') pixelsTaken += 2;
+			else if (ch == 'k') pixelsTaken += 5;
+			else if (ch == 'l') pixelsTaken += 3;
+			else if (ch == '\'') pixelsTaken += 3;
+			else if (ch == 't') pixelsTaken += 4;
+			else if (ch == 'I') pixelsTaken += 4;
+			else if (ch == '[') pixelsTaken += 4;
+			else if (ch == ']') pixelsTaken += 4;
+			else if (ch == ' ') pixelsTaken += 4;
+			else if (ch == '\u262E') pixelsTaken += 4;
+			else if (ch == '\u2694') pixelsTaken += 7;
+
+			else
+				pixelsTaken += 6; // default
+			
+		}
+
+		// space is 4 pixels
+		int spacesPixels = (padLen * 6 - pixelsTaken);
+		int left = spacesPixels % 4;
+
+		for (int i = 0; i < left; i++)
+			tgt.append("\u205A");
+		for (int i = 0; i < spacesPixels / 4; i++)
+			tgt.append(" ");
+
+		return tgt.toString();
+	}
+	
+
+	 /** 
+     * Calculate yaw angle needed for source location to face a target location.
+     * 
+     * @param src Source Location
+     * @param dest Destination Location
+     * @return Yaw angle for Source to Face Destination
+     */ 			
+	public static float YawToFaceLocation(MC_Location src, MC_Location dest)
+	{
+		double dz = -(dest.x - src.x);
+		double dx = (dest.z - src.z);
+		// Zero handler
+		if(Math.abs(dx) < 0.0001) dx = 0.0001;
+		
+		double yawSrcToTarget = 360*Math.atan(dz / dx)/(2*3.1415926535);
+		if(dx < 0) yawSrcToTarget += 180.0;
+		if(yawSrcToTarget < 0) yawSrcToTarget += 360.0;
+		return (float)yawSrcToTarget;
+	}
+
+	 /** 
+     * Calculate pitch angle needed for source location to face a target location.
+     * 
+     * @param src Source Location
+     * @param dest Destination Location
+     * @return Pitch angle for Source to Face Destination
+     */ 			
+	public static float PitchToFaceLocation(MC_Location src, MC_Location dest)
+	{
+		double dz = -(dest.x - src.x);
+		double dx = (dest.z - src.z);
+		double dy = -(dest.y - src.y);
+		double d = Math.sqrt(dz*dz + dx*dx);
+		// Zero handler
+		if(Math.abs(d) < 0.0001) d = 0.0001;
+		
+		double pitchToTarget = 360*Math.atan(dy / d)/(2*3.1415926535);
+		return (float)pitchToTarget;
+	}
+
+	 /** 
+     * Create a rainbow colored, comma separated list from an array of strings.
+     * 
+     * @param strings String array
+     * @return Rainbow colored, comma separated list.
+     */ 			
+	  public static String RainbowStringList(String[] strings)
+	  {
+		  return RainbowStringList(new ArrayList(Arrays.asList(strings)));
+	  }
+
+    /** 
+     * Create a rainbow colored, comma separated list from an list of strings.
+     * 
+     * @param strings String array
+     * @return Rainbow colored, comma separated list.
+     */ 			
+	  public static String RainbowStringList(List<String> strings)
+	  {
+		  String res = ChatColor.RED + "None";
+		  if(strings.size() > 0) 
+		  {
+			  String nextColor = ChatColor.YELLOW;
+			  StringBuilder sb = new StringBuilder();
+			  for (String iterator : strings) {
+				  if(sb.length() > 0) sb.append(ChatColor.WHITE + ", ");
+				  sb.append(nextColor + iterator);
+				  if(nextColor == ChatColor.GOLD) nextColor = ChatColor.YELLOW;
+				  else if(nextColor == ChatColor.YELLOW) nextColor = ChatColor.GREEN;
+				  else if(nextColor == ChatColor.GREEN) nextColor = ChatColor.AQUA;
+				  else if(nextColor == ChatColor.AQUA) nextColor = ChatColor.LIGHT_PURPLE;
+				  else if(nextColor == ChatColor.LIGHT_PURPLE) nextColor = ChatColor.RED;
+				  else if(nextColor == ChatColor.RED) nextColor = ChatColor.GOLD;
+			  }
+			  res = sb.toString(); 
+		  }
+		  return res;
+	  }
+	
+	
+}

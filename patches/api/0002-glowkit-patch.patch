From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Outfit7TSB <sunnybunnies09@naver.com>
Date: Mon, 20 Jan 2025 23:09:48 +0900
Subject: [PATCH] glowkit patch


diff --git a/src/main/java/org/bukkit/command/SimpleCommandMap.java b/src/main/java/org/bukkit/command/SimpleCommandMap.java
index 5df19bd701c67506689fc7f49d91f99ebfbc83f0..b60c0f1169b5c939357bf2c4676d87f7a0aa5708 100644
--- a/src/main/java/org/bukkit/command/SimpleCommandMap.java
+++ b/src/main/java/org/bukkit/command/SimpleCommandMap.java
@@ -16,6 +16,7 @@ import org.bukkit.command.defaults.BukkitCommand;
 import org.bukkit.command.defaults.HelpCommand;
 import org.bukkit.command.defaults.PluginsCommand;
 import org.bukkit.command.defaults.ReloadCommand;
+import org.bukkit.command.defaults.VanillaCommand;
 import org.bukkit.command.defaults.VersionCommand;
 import org.bukkit.entity.Player;
 import org.bukkit.util.StringUtil;
@@ -109,7 +110,7 @@ public class SimpleCommandMap implements CommandMap {
         knownCommands.put(fallbackPrefix + ":" + label, command);
         // Paper start
         Command known = knownCommands.get(label);
-        if ((command instanceof BukkitCommand || isAlias) && (known != null && !known.canBeOverriden())) {
+        if ((command instanceof BukkitCommand || command instanceof VanillaCommand || isAlias) && (known != null && !known.canBeOverriden())) {
         // Paper end
             // Request is for an alias/fallback command and it conflicts with
             // a existing command or previous alias ignore it
diff --git a/src/main/java/org/bukkit/command/defaults/VanillaCommand.java b/src/main/java/org/bukkit/command/defaults/VanillaCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..c141bfdea2af5f6b404de7a9cc0c54c97c47ca74
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/VanillaCommand.java
@@ -0,0 +1,111 @@
+package org.bukkit.command.defaults;
+
+import java.util.List;
+
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+
+@Deprecated
+public abstract class VanillaCommand extends Command {
+    static final int MAX_COORD = 30000000;
+    static final int MIN_COORD_MINUS_ONE = -30000001;
+    static final int MIN_COORD = -30000000;
+
+    protected VanillaCommand(String name) {
+        super(name);
+    }
+
+    protected VanillaCommand(String name, String description, String usageMessage, List<String> aliases) {
+        super(name, description, usageMessage, aliases);
+    }
+
+    public boolean matches(String input) {
+        return input.equalsIgnoreCase(this.getName());
+    }
+
+    protected int getInteger(CommandSender sender, String value, int min) {
+        return getInteger(sender, value, min, Integer.MAX_VALUE);
+    }
+
+    int getInteger(CommandSender sender, String value, int min, int max) {
+        return getInteger(sender, value, min, max, false);
+    }
+
+    int getInteger(CommandSender sender, String value, int min, int max, boolean Throws) {
+        int i = min;
+
+        try {
+            i = Integer.valueOf(value);
+        } catch (NumberFormatException ex) {
+            if (Throws) {
+                throw new NumberFormatException(String.format("%s is not a valid number", value));
+            }
+        }
+
+        if (i < min) {
+            i = min;
+        } else if (i > max) {
+            i = max;
+        }
+
+        return i;
+    }
+
+    Integer getInteger(String value) {
+        try {
+            return Integer.valueOf(value);
+        } catch (NumberFormatException ex) {
+            return null;
+        }
+    }
+
+    public static double getRelativeDouble(double original, CommandSender sender, String input) {
+        if (input.startsWith("~")) {
+            double value = getDouble(sender, input.substring(1));
+            if (value == MIN_COORD_MINUS_ONE) {
+                return MIN_COORD_MINUS_ONE;
+            }
+            return original  value;
+        } else {
+            return getDouble(sender, input);
+        }
+    }
+
+    public static double getDouble(CommandSender sender, String input) {
+        try {
+            return Double.parseDouble(input);
+        } catch (NumberFormatException ex) {
+            return MIN_COORD_MINUS_ONE;
+        }
+    }
+
+    public static double getDouble(CommandSender sender, String input, double min, double max) {
+        double result = getDouble(sender, input);
+
+        // TODO: This should throw an exception instead.
+        if (result < min) {
+            result = min;
+        } else if (result > max) {
+            result = max;
+        }
+
+        return result;
+    }
+
+    String createString(String[] args, int start) {
+        return createString(args, start, " ");
+    }
+
+    String createString(String[] args, int start, String glue) {
+        StringBuilder string = new StringBuilder();
+
+        for (int x = start; x < args.length; x) {
+            string.append(args[x]);
+            if (x != args.length - 1) {
+                string.append(glue);
+            }
+        }
+
+        return string.toString();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
index b412aaf08901d169ac9fc89b36f9d6ccb95c53d3..710221b2983b1d8438355dca34bf325880a2e219 100644
--- a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
@@ -50,7 +50,7 @@ import org.yaml.snakeyaml.error.YAMLException;
  * Represents a Java plugin loader, allowing plugins in the form of .jar
  */
 @Deprecated(forRemoval = true) // Paper - The PluginLoader system will not function in the near future. This implementation will be moved.
-public final class JavaPluginLoader implements PluginLoader {
+public class JavaPluginLoader implements PluginLoader {
     final Server server;
     private final Pattern[] fileFilters = new Pattern[]{Pattern.compile("\\.jar$")};
     private final List<PluginClassLoader> loaders = new CopyOnWriteArrayList<PluginClassLoader>();
@@ -143,7 +143,7 @@ public final class JavaPluginLoader implements PluginLoader {
 
         final PluginClassLoader loader;
         try {
-            loader = new PluginClassLoader(getClass().getClassLoader(), description, dataFolder, file, (libraryLoader != null) ? libraryLoader.createLoader(description) : null, null, null); // Paper
+            loader = new PluginLoader(getClass().getClassLoader(), description, dataFolder, file, (libraryLoader != null) ? libraryLoader.createLoader(description) : null, null, null); // Paper
         } catch (InvalidPluginException ex) {
             throw ex;
         } catch (Throwable ex) {
@@ -154,6 +154,11 @@ public final class JavaPluginLoader implements PluginLoader {
 
         return loader.plugin;
     }
+	
+    protected PluginClassLoader newPluginLoader(JavaPluginLoader loader, ClassLoader parent, PluginDescriptionFile description, File dataFolder, File file, ClassLoader libraryLoader) throws Exception {        
+	               return new PluginClassLoader(loader, parent, description, dataFolder, file, libraryLoader);
+    }
+	
 
     @Override
     @NotNull
@@ -202,7 +207,7 @@ public final class JavaPluginLoader implements PluginLoader {
     }
 
     @Nullable
-    Class<?> getClassByName(final String name, boolean resolve, PluginDescriptionFile description) {
+    protected Class<?> getClassByName(final String name, boolean resolve, PluginDescriptionFile description) {
         for (PluginClassLoader loader : loaders) {
             try {
                 return loader.loadClass0(name, resolve, false, ((SimplePluginManager) server.getPluginManager()).isTransitiveDepend(description, loader.plugin.getDescription()));
diff --git a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
index 7e4f7cb2afbc145e532285c793573ad107bc3033..572cd1c2db95e06b8105392c7ef7693e0fcde5d4 100644
--- a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
@@ -32,7 +32,7 @@ import org.jetbrains.annotations.Nullable;
  * A ClassLoader for plugins, to allow shared classes across multiple plugins
  */
 @org.jetbrains.annotations.ApiStatus.Internal // Paper
-public final class PluginClassLoader extends URLClassLoader implements io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader { // Paper
+public class PluginClassLoader extends URLClassLoader implements io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader { // Paper
     private final JavaPluginLoader loader;
     private final Map<String, Class<?>> classes = new ConcurrentHashMap<String, Class<?>>();
     private final PluginDescriptionFile description;
@@ -199,9 +199,6 @@ public final class PluginClassLoader extends URLClassLoader implements io.paperm
 
     @Override
     protected Class<?> findClass(String name) throws ClassNotFoundException {
-        if (name.startsWith("org.bukkit.") || name.startsWith("net.minecraft.")) {
-            throw new ClassNotFoundException(name);
-        }
         Class<?> result = classes.get(name);
 
         if (result == null) {
@@ -240,6 +237,7 @@ public final class PluginClassLoader extends URLClassLoader implements io.paperm
                 CodeSigner[] signers = entry.getCodeSigners();
                 CodeSource source = new CodeSource(url, signers);
 
+                classBytes = transformBytecode(classBytes);
                 result = defineClass(name, classBytes, 0, classBytes.length, source);
             }
 

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Outfit7TSB <sunnybunnies09@naver.com>
Date: Sat, 25 Jan 2025 00:04:13 +0900
Subject: [PATCH] not again


diff --git "a/NogyangSpigotCraftBukkit - \353\260\224\353\241\234 \352\260\200\352\270\260.lnk" "b/NogyangSpigotCraftBukkit - \353\260\224\353\241\234 \352\260\200\352\270\260.lnk"
new file mode 100644
index 0000000000000000000000000000000000000000..2ecf5f970f29825e1140202007a46caefb86a214
GIT binary patch
literal 967
zcmeZaU|?VrVFHp23<tm@gIhNP2ZI2Ry?eqOU*EjjjAB3DJ@P}M!ID6EMu>Vi$<HXl
zARq9+|AN9Rt4x7KH#iuy4GiW=GU&Tl#lRII7-0;CV2(wUWu^dwUw(RJVqQ9f0|O@m
z3&Z<;W>FuKK{9$kHJdj11IbK;RxoSp^!W^a4EYS{43!Lt40%ABfkBL+3vQ}UINa3W
zg3R>%66d1Cv=XP%?Ci`E28JZ4Jr+@qLM@_v!a?@Te-sEL(Y^JmzZuP*V1@#qYtn&s
zmoPXp6aj5d1G1bLN*S_&FcZjTV9)^KNFbJhnh2szfEWZKfLH>EnSr>b?~N5Wu)iwo
z+Oz#H12C+hK>?$&IG%|?4+s+=Ml1js2Lf4@x<&?umWD=#25H%8c??^wSga5dvGrfq
z^-j3MNxyDNy=JT9t@ncMF)TN~ZZIz)B)=RO5}XVS3tWL_8wLjizctu<%bB6meff_I
z!b^(Nlr(|jDIkmGftUw~QDZ}c!G*z!0i*~7Rsb=`5QC4Z+uyrO2`v4{l+ZKp^%{`j
zTp$G?LnMJ1)evHWnt?$SsE;3rfvE=wjwtzolC3O|$pYeoOlAXOp361I6&Su;4%rOR
z!3UCb0Ag4I2k}dR805}nS;-o<Q!fc_y~c3B|E9zRP+ZD^6o5=q0b-EnV$fWR&L__G
x3=Eb)^FWqv6w7s4+gsqV+`~a{iETv>$O{=j%-{jUU;5lPf!GYN{0HHHNdT>M(?|dS

literal 0
HcmV?d00001

diff --git a/src/main/java/ca/spottedleaf/moonrise/common/PlatformHooks.java b/src/main/java/ca/spottedleaf/moonrise/common/PlatformHooks.java
index 6c98d420ea84c10ef4f15d4deb3f04e610ed8548..9b879cbc037a17ffeb9a963111fd3f303a935eef 100644
--- a/src/main/java/ca/spottedleaf/moonrise/common/PlatformHooks.java
+++ b/src/main/java/ca/spottedleaf/moonrise/common/PlatformHooks.java
@@ -1,5 +1,6 @@
 package ca.spottedleaf.moonrise.common;
 
+import ca.spottedleaf.moonrise.common.util.ChunkSystemHooks;
 import com.mojang.datafixers.DSL;
 import com.mojang.datafixers.DataFixer;
 import net.minecraft.core.BlockPos;
@@ -23,7 +24,7 @@ import java.util.List;
 import java.util.ServiceLoader;
 import java.util.function.Predicate;
 
-public interface PlatformHooks {
+public interface PlatformHooks extends ChunkSystemHooks {
     public static PlatformHooks get() {
         return Holder.INSTANCE;
     }
@@ -63,8 +64,6 @@ public interface PlatformHooks {
 
     public void entityMove(final Entity entity, final long oldSection, final long newSection);
 
-    public boolean screenEntity(final ServerLevel world, final Entity entity, final boolean fromDisk, final boolean event);
-
     public boolean configFixMC224294();
 
     public boolean configAutoConfigSendDistance();
diff --git a/src/main/java/ca/spottedleaf/moonrise/common/util/ChunkSystemHooks.java b/src/main/java/ca/spottedleaf/moonrise/common/util/ChunkSystemHooks.java
new file mode 100644
index 0000000000000000000000000000000000000000..427079ae47b6e0e1aa42013a8760fbefa76941f2
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/moonrise/common/util/ChunkSystemHooks.java
@@ -0,0 +1,77 @@
+package ca.spottedleaf.moonrise.common.util;
+
+import ca.spottedleaf.concurrentutil.util.Priority;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.FullChunkStatus;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.status.ChunkStatus;
+import java.util.List;
+import java.util.function.Consumer;
+
+public interface ChunkSystemHooks {
+
+    public void scheduleChunkTask(final ServerLevel level, final int chunkX, final int chunkZ, final Runnable run);
+
+    public void scheduleChunkTask(final ServerLevel level, final int chunkX, final int chunkZ, final Runnable run, final Priority priority);
+
+    public void scheduleChunkLoad(final ServerLevel level, final int chunkX, final int chunkZ, final boolean gen,
+                                  final ChunkStatus toStatus, final boolean addTicket, final Priority priority,
+                                  final Consumer<ChunkAccess> onComplete);
+
+    public void scheduleChunkLoad(final ServerLevel level, final int chunkX, final int chunkZ, final ChunkStatus toStatus,
+                                  final boolean addTicket, final Priority priority, final Consumer<ChunkAccess> onComplete);
+
+    public void scheduleTickingState(final ServerLevel level, final int chunkX, final int chunkZ,
+                                     final FullChunkStatus toStatus, final boolean addTicket,
+                                     final Priority priority, final Consumer<LevelChunk> onComplete);
+
+    public List<ChunkHolder> getVisibleChunkHolders(final ServerLevel level);
+
+    public List<ChunkHolder> getUpdatingChunkHolders(final ServerLevel level);
+
+    public int getVisibleChunkHolderCount(final ServerLevel level);
+
+    public int getUpdatingChunkHolderCount(final ServerLevel level);
+
+    public boolean hasAnyChunkHolders(final ServerLevel level);
+
+    public boolean screenEntity(final ServerLevel level, final Entity entity, final boolean fromDisk, final boolean event);
+
+    public void onChunkHolderCreate(final ServerLevel level, final ChunkHolder holder);
+
+    public void onChunkHolderDelete(final ServerLevel level, final ChunkHolder holder);
+
+    public void onChunkPreBorder(final LevelChunk chunk, final ChunkHolder holder);
+
+    public void onChunkBorder(final LevelChunk chunk, final ChunkHolder holder);
+
+    public void onChunkNotBorder(final LevelChunk chunk, final ChunkHolder holder);
+
+    public void onChunkPostNotBorder(final LevelChunk chunk, final ChunkHolder holder);
+
+    public void onChunkTicking(final LevelChunk chunk, final ChunkHolder holder);
+
+    public void onChunkNotTicking(final LevelChunk chunk, final ChunkHolder holder);
+
+    public void onChunkEntityTicking(final LevelChunk chunk, final ChunkHolder holder);
+
+    public void onChunkNotEntityTicking(final LevelChunk chunk, final ChunkHolder holder);
+
+    public ChunkHolder getUnloadingChunkHolder(final ServerLevel level, final int chunkX, final int chunkZ);
+
+    public int getSendViewDistance(final ServerPlayer player);
+
+    public int getViewDistance(final ServerPlayer player);
+
+    public int getTickViewDistance(final ServerPlayer player);
+
+    public void addPlayerToDistanceMaps(final ServerLevel world, final ServerPlayer player);
+
+    public void removePlayerFromDistanceMaps(final ServerLevel world, final ServerPlayer player);
+
+    public void updateMaps(final ServerLevel world, final ServerPlayer player);
+}
diff --git a/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java b/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java
index 217d1f908a36a5177ba3cbb80a33f73d4dab0fa0..157e5edb507d6d2a922833c70a1c27abc93c9c34 100644
--- a/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java
+++ b/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java
@@ -28,43 +28,64 @@ public class TickThread extends Thread {
 
     public static void ensureTickThread(final Level world, final BlockPos pos, final String reason) {
         if (!isTickThreadFor(world, pos)) {
-            LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            final String ex = "Thread " + Thread.currentThread().getName() + " failed main thread check: " +
+                               reason + ", world=" + WorldUtil.getWorldName(world) + ", block_pos=" + pos;
+            LOGGER.error(ex, new Throwable());
+            throw new IllegalStateException(ex);
+        }
+    }
+
+    public static void ensureTickThread(final Level world, final BlockPos pos, final int blockRadius, final String reason) {
+        if (!isTickThreadFor(world, pos, blockRadius)) {
+            final String ex = "Thread " + Thread.currentThread().getName() + " failed main thread check: " +
+                reason + ", world=" + WorldUtil.getWorldName(world) + ", block_pos=" + pos + ", block_radius=" + blockRadius;
+            LOGGER.error(ex, new Throwable());
+            throw new IllegalStateException(ex);
         }
     }
 
     public static void ensureTickThread(final Level world, final ChunkPos pos, final String reason) {
         if (!isTickThreadFor(world, pos)) {
-            LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            final String ex = "Thread " + Thread.currentThread().getName() + " failed main thread check: " +
+                reason + ", world=" + WorldUtil.getWorldName(world) + ", chunk_pos=" + pos;
+            LOGGER.error(ex, new Throwable());
+            throw new IllegalStateException(ex);
         }
     }
 
     public static void ensureTickThread(final Level world, final int chunkX, final int chunkZ, final String reason) {
         if (!isTickThreadFor(world, chunkX, chunkZ)) {
-            LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            final String ex = "Thread " + Thread.currentThread().getName() + " failed main thread check: " +
+                reason + ", world=" + WorldUtil.getWorldName(world) + ", chunk_pos=" + new ChunkPos(chunkX, chunkZ);
+            LOGGER.error(ex, new Throwable());
+            throw new IllegalStateException(ex);
         }
     }
 
     public static void ensureTickThread(final Entity entity, final String reason) {
         if (!isTickThreadFor(entity)) {
-            LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            final String ex = "Thread " + Thread.currentThread().getName() + " failed main thread check: " +
+                reason + ", entity=" + entity;
+            LOGGER.error(ex, new Throwable());
+            throw new IllegalStateException(ex);
         }
     }
 
     public static void ensureTickThread(final Level world, final AABB aabb, final String reason) {
         if (!isTickThreadFor(world, aabb)) {
-            LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            final String ex = "Thread " + Thread.currentThread().getName() + " failed main thread check: " +
+                reason + ", world=" + WorldUtil.getWorldName(world) + ", aabb=" + aabb;
+            LOGGER.error(ex, new Throwable());
+            throw new IllegalStateException(ex);
         }
     }
 
     public static void ensureTickThread(final Level world, final double blockX, final double blockZ, final String reason) {
         if (!isTickThreadFor(world, blockX, blockZ)) {
-            LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            final String ex = "Thread " + Thread.currentThread().getName() + " failed main thread check: " +
+                reason + ", world=" + WorldUtil.getWorldName(world) + ", block_pos=" + new Vec3(blockX, 0.0, blockZ);
+            LOGGER.error(ex, new Throwable());
+            throw new IllegalStateException(ex);
         }
     }
 
@@ -105,6 +126,10 @@ public class TickThread extends Thread {
         return isTickThread();
     }
 
+    public static boolean isTickThreadFor(final Level world, final BlockPos pos, final int blockRadius) {
+        return isTickThread();
+    }
+
     public static boolean isTickThreadFor(final Level world, final ChunkPos pos) {
         return isTickThread();
     }
diff --git a/src/main/java/com/destroystokyo/paper/entity/PaperPathfinder.java b/src/main/java/com/destroystokyo/paper/entity/PaperPathfinder.java
index 946cbc955683e81933e0f3c0db5f8cc4ec437a76..3e43beaaa2119736f04d678e0976d3821330d62b 100644
--- a/src/main/java/com/destroystokyo/paper/entity/PaperPathfinder.java
+++ b/src/main/java/com/destroystokyo/paper/entity/PaperPathfinder.java
@@ -135,7 +135,7 @@ public class PaperPathfinder implements com.destroystokyo.paper.entity.Pathfinde
         @Nullable
         @Override
         public Location getNextPoint() {
-            if (!path.hasNext()) {
+            if (path.isDone()) {
                 return null;
             }
             return toLoc(path.nodes.get(path.getNextNodeIndex()));
diff --git a/src/main/java/io/papermc/paper/PaperServerInternalAPIBridge.java b/src/main/java/io/papermc/paper/PaperServerInternalAPIBridge.java
new file mode 100644
index 0000000000000000000000000000000000000000..d3c216f449a6285694ef37be0ce4aff0feabeeda
--- /dev/null
+++ b/src/main/java/io/papermc/paper/PaperServerInternalAPIBridge.java
@@ -0,0 +1,15 @@
+package io.papermc.paper;
+
+import org.bukkit.craftbukkit.damage.CraftDamageEffect;
+import org.bukkit.damage.DamageEffect;
+import org.jspecify.annotations.NullMarked;
+
+@NullMarked
+public class PaperServerInternalAPIBridge implements InternalAPIBridge {
+    public static final PaperServerInternalAPIBridge INSTANCE = new PaperServerInternalAPIBridge();
+
+    @Override
+    public DamageEffect getDamageEffect(final String key) {
+        return CraftDamageEffect.getById(key);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/ServerBuildInfoImpl.java b/src/main/java/io/papermc/paper/ServerBuildInfoImpl.java
index 5b70e41111d37afb9ebaf57b22acef3ab9558936..790bad0494454ca12ee152e3de6da3da634d9b20 100644
--- a/src/main/java/io/papermc/paper/ServerBuildInfoImpl.java
+++ b/src/main/java/io/papermc/paper/ServerBuildInfoImpl.java
@@ -31,7 +31,6 @@ public record ServerBuildInfoImpl(
     private static final String ATTRIBUTE_GIT_COMMIT = "Git-Commit";
 
     private static final String BRAND_PAPER_NAME = "Paper";
-	private static final String BRAND_NOGYANGSPIGOT_NAME = "NogyangSpigotCraftBukkit"; 
 
     private static final String BUILD_DEV = "DEV";
 
@@ -45,7 +44,7 @@ public record ServerBuildInfoImpl(
                 .map(Key::key)
                 .orElse(BRAND_PAPER_ID),
             getManifestAttribute(manifest, ATTRIBUTE_BRAND_NAME)
-                .orElse(BRAND_NOGYANGSPIGOT_NAME),
+                .orElse(BRAND_PAPER_NAME),
             SharedConstants.getCurrentVersion().getId(),
             SharedConstants.getCurrentVersion().getName(),
             getManifestAttribute(manifest, ATTRIBUTE_BUILD_NUMBER)
@@ -62,7 +61,7 @@ public record ServerBuildInfoImpl(
 
     @Override
     public boolean isBrandCompatible(final @NotNull Key brandId) {
-        return brandId.equals(this.brandId) || brandId.equals(BRAND_PAPER_ID);
+        return brandId.equals(this.brandId);
     }
 
     @Override
diff --git a/src/main/java/io/papermc/paper/adventure/AdventureCodecs.java b/src/main/java/io/papermc/paper/adventure/AdventureCodecs.java
index 2c5702a42c4a3d8b37deeb26e1bd7fbdcca3554e..7a47f0fda0f89a8d17a1ba033737186381c2ea98 100644
--- a/src/main/java/io/papermc/paper/adventure/AdventureCodecs.java
+++ b/src/main/java/io/papermc/paper/adventure/AdventureCodecs.java
@@ -11,7 +11,6 @@ import com.mojang.serialization.DynamicOps;
 import com.mojang.serialization.JsonOps;
 import com.mojang.serialization.MapCodec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
-import java.io.IOException;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
@@ -37,6 +36,7 @@ import net.kyori.adventure.text.event.ClickEvent;
 import net.kyori.adventure.text.event.DataComponentValue;
 import net.kyori.adventure.text.event.HoverEvent;
 import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.format.ShadowColor;
 import net.kyori.adventure.text.format.Style;
 import net.kyori.adventure.text.format.TextColor;
 import net.kyori.adventure.text.format.TextDecoration;
@@ -79,6 +79,8 @@ public final class AdventureCodecs {
     public static final Codec<Component> COMPONENT_CODEC = recursive("adventure Component",  AdventureCodecs::createCodec);
     public static final StreamCodec<RegistryFriendlyByteBuf, Component> STREAM_COMPONENT_CODEC = ByteBufCodecs.fromCodecWithRegistriesTrusted(COMPONENT_CODEC);
 
+    static final Codec<ShadowColor> SHADOW_COLOR_CODEC = ExtraCodecs.ARGB_COLOR_CODEC.xmap(ShadowColor::shadowColor, ShadowColor::value);
+
     static final Codec<TextColor> TEXT_COLOR_CODEC = Codec.STRING.comapFlatMap(s -> {
         if (s.startsWith("#")) {
             @Nullable TextColor value = TextColor.fromHexString(s);
@@ -220,6 +222,7 @@ public final class AdventureCodecs {
     public static final MapCodec<Style> STYLE_MAP_CODEC = mapCodec((instance) -> {
         return instance.group(
             TEXT_COLOR_CODEC.optionalFieldOf("color").forGetter(nullableGetter(Style::color)),
+            SHADOW_COLOR_CODEC.optionalFieldOf("shadow_color").forGetter(nullableGetter(Style::shadowColor)),
             Codec.BOOL.optionalFieldOf("bold").forGetter(decorationGetter(TextDecoration.BOLD)),
             Codec.BOOL.optionalFieldOf("italic").forGetter(decorationGetter(TextDecoration.ITALIC)),
             Codec.BOOL.optionalFieldOf("underlined").forGetter(decorationGetter(TextDecoration.UNDERLINED)),
@@ -229,9 +232,10 @@ public final class AdventureCodecs {
             HOVER_EVENT_CODEC.optionalFieldOf("hoverEvent").forGetter(nullableGetter(Style::hoverEvent)),
             Codec.STRING.optionalFieldOf("insertion").forGetter(nullableGetter(Style::insertion)),
             KEY_CODEC.optionalFieldOf("font").forGetter(nullableGetter(Style::font))
-        ).apply(instance, (textColor, bold, italic, underlined, strikethrough, obfuscated, clickEvent, hoverEvent, insertion, font) -> {
+        ).apply(instance, (textColor, shadowColor, bold, italic, underlined, strikethrough, obfuscated, clickEvent, hoverEvent, insertion, font) -> {
             return Style.style(builder -> {
                 textColor.ifPresent(builder::color);
+                shadowColor.ifPresent(builder::shadowColor);
                 bold.ifPresent(styleBooleanConsumer(builder, TextDecoration.BOLD));
                 italic.ifPresent(styleBooleanConsumer(builder, TextDecoration.ITALIC));
                 underlined.ifPresent(styleBooleanConsumer(builder, TextDecoration.UNDERLINED));
diff --git a/src/main/java/io/papermc/paper/adventure/providers/DataComponentValueConverterProviderImpl.java b/src/main/java/io/papermc/paper/adventure/providers/DataComponentValueConverterProviderImpl.java
index ee2076fd098ae2164596f39b88f56b3700ed3687..cfd146de421337e5d8ddd27cf9c368017b738ce9 100644
--- a/src/main/java/io/papermc/paper/adventure/providers/DataComponentValueConverterProviderImpl.java
+++ b/src/main/java/io/papermc/paper/adventure/providers/DataComponentValueConverterProviderImpl.java
@@ -76,6 +76,20 @@ public class DataComponentValueConverterProviderImpl implements DataComponentVal
                         throw new IllegalArgumentException(e);
                     }
                 }
+            ),
+            DataComponentValueConverterRegistry.Conversion.convert(
+                DataComponentValue.TagSerializable.class,
+                GsonDataComponentValue.class,
+                (key, tagSerializable) -> {
+                    Tag decodedSnbt;
+                    try {
+                        decodedSnbt = tagSerializable.asBinaryTag().get(PaperAdventure.NBT_CODEC);
+                    } catch (final CommandSyntaxException e) {
+                        throw new IllegalArgumentException("Unable to parse SNBT value", e);
+                    }
+
+                    return GsonDataComponentValue.gsonDataComponentValue(NbtOps.INSTANCE.convertTo(JsonOps.INSTANCE, decodedSnbt));
+                }
             )
         );
     }
diff --git a/src/main/java/io/papermc/paper/antixray/BitStorageReader.java b/src/main/java/io/papermc/paper/antixray/BitStorageReader.java
new file mode 100644
index 0000000000000000000000000000000000000000..c27703775c845a8b0bd1b0cb8f05eb736d8a813c
--- /dev/null
+++ b/src/main/java/io/papermc/paper/antixray/BitStorageReader.java
@@ -0,0 +1,51 @@
+package io.papermc.paper.antixray;
+
+public final class BitStorageReader {
+
+    private byte[] buffer;
+    private int bits;
+    private int mask;
+    private int longInBufferIndex;
+    private int bitInLongIndex;
+    private long current;
+
+    public void setBuffer(byte[] buffer) {
+        this.buffer = buffer;
+    }
+
+    public void setBits(int bits) {
+        this.bits = bits;
+        mask = (1 << bits) - 1;
+    }
+
+    public void setIndex(int index) {
+        longInBufferIndex = index;
+        bitInLongIndex = 0;
+        init();
+    }
+
+    private void init() {
+        if (buffer.length > longInBufferIndex + 7) {
+            current = ((((long) buffer[longInBufferIndex]) << 56)
+                | (((long) buffer[longInBufferIndex + 1] & 0xff) << 48)
+                | (((long) buffer[longInBufferIndex + 2] & 0xff) << 40)
+                | (((long) buffer[longInBufferIndex + 3] & 0xff) << 32)
+                | (((long) buffer[longInBufferIndex + 4] & 0xff) << 24)
+                | (((long) buffer[longInBufferIndex + 5] & 0xff) << 16)
+                | (((long) buffer[longInBufferIndex + 6] & 0xff) << 8)
+                | (((long) buffer[longInBufferIndex + 7] & 0xff)));
+        }
+    }
+
+    public int read() {
+        if (bitInLongIndex + bits > 64) {
+            bitInLongIndex = 0;
+            longInBufferIndex += 8;
+            init();
+        }
+
+        int value = (int) (current >>> bitInLongIndex) & mask;
+        bitInLongIndex += bits;
+        return value;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/antixray/BitStorageWriter.java b/src/main/java/io/papermc/paper/antixray/BitStorageWriter.java
new file mode 100644
index 0000000000000000000000000000000000000000..83412e0ddaade11eb7ac7b41bb8ae5b085802775
--- /dev/null
+++ b/src/main/java/io/papermc/paper/antixray/BitStorageWriter.java
@@ -0,0 +1,79 @@
+package io.papermc.paper.antixray;
+
+public final class BitStorageWriter {
+
+    private byte[] buffer;
+    private int bits;
+    private long mask;
+    private int longInBufferIndex;
+    private int bitInLongIndex;
+    private long current;
+    private boolean dirty;
+
+    public void setBuffer(byte[] buffer) {
+        this.buffer = buffer;
+    }
+
+    public void setBits(int bits) {
+        this.bits = bits;
+        mask = (1L << bits) - 1;
+    }
+
+    public void setIndex(int index) {
+        longInBufferIndex = index;
+        bitInLongIndex = 0;
+        init();
+    }
+
+    private void init() {
+        if (buffer.length > longInBufferIndex + 7) {
+            current = ((((long) buffer[longInBufferIndex]) << 56)
+                | (((long) buffer[longInBufferIndex + 1] & 0xff) << 48)
+                | (((long) buffer[longInBufferIndex + 2] & 0xff) << 40)
+                | (((long) buffer[longInBufferIndex + 3] & 0xff) << 32)
+                | (((long) buffer[longInBufferIndex + 4] & 0xff) << 24)
+                | (((long) buffer[longInBufferIndex + 5] & 0xff) << 16)
+                | (((long) buffer[longInBufferIndex + 6] & 0xff) << 8)
+                | (((long) buffer[longInBufferIndex + 7] & 0xff)));
+        }
+
+        dirty = false;
+    }
+
+    public void flush() {
+        if (dirty && buffer.length > longInBufferIndex + 7) {
+            buffer[longInBufferIndex] = (byte) (current >> 56 & 0xff);
+            buffer[longInBufferIndex + 1] = (byte) (current >> 48 & 0xff);
+            buffer[longInBufferIndex + 2] = (byte) (current >> 40 & 0xff);
+            buffer[longInBufferIndex + 3] = (byte) (current >> 32 & 0xff);
+            buffer[longInBufferIndex + 4] = (byte) (current >> 24 & 0xff);
+            buffer[longInBufferIndex + 5] = (byte) (current >> 16 & 0xff);
+            buffer[longInBufferIndex + 6] = (byte) (current >> 8 & 0xff);
+            buffer[longInBufferIndex + 7] = (byte) (current & 0xff);
+        }
+    }
+
+    public void write(int value) {
+        if (bitInLongIndex + bits > 64) {
+            flush();
+            bitInLongIndex = 0;
+            longInBufferIndex += 8;
+            init();
+        }
+
+        current = current & ~(mask << bitInLongIndex) | (value & mask) << bitInLongIndex;
+        dirty = true;
+        bitInLongIndex += bits;
+    }
+
+    public void skip() {
+        bitInLongIndex += bits;
+
+        if (bitInLongIndex > 64) {
+            flush();
+            bitInLongIndex = bits;
+            longInBufferIndex += 8;
+            init();
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/antixray/ChunkPacketBlockController.java b/src/main/java/io/papermc/paper/antixray/ChunkPacketBlockController.java
new file mode 100644
index 0000000000000000000000000000000000000000..69b553747b33511231e6c45121a91dce4d1ba30b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/antixray/ChunkPacketBlockController.java
@@ -0,0 +1,45 @@
+package io.papermc.paper.antixray;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
+import net.minecraft.network.protocol.game.ServerboundPlayerActionPacket;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.level.ServerPlayerGameMode;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.LevelChunk;
+
+public class ChunkPacketBlockController {
+
+    public static final ChunkPacketBlockController NO_OPERATION_INSTANCE = new ChunkPacketBlockController();
+
+    protected ChunkPacketBlockController() {
+
+    }
+
+    public BlockState[] getPresetBlockStates(Level level, ChunkPos chunkPos, int chunkSectionY) {
+        return null;
+    }
+
+    public boolean shouldModify(ServerPlayer player, LevelChunk chunk) {
+        return false;
+    }
+
+    public ChunkPacketInfo<BlockState> getChunkPacketInfo(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk) {
+        return null;
+    }
+
+    public void modifyBlocks(ClientboundLevelChunkWithLightPacket chunkPacket, ChunkPacketInfo<BlockState> chunkPacketInfo) {
+        chunkPacket.setReady(true);
+    }
+
+    public void onBlockChange(Level level, BlockPos blockPos, BlockState newBlockState, BlockState oldBlockState, int flags, int maxUpdateDepth) {
+
+    }
+
+    public void onPlayerLeftClickBlock(ServerPlayerGameMode serverPlayerGameMode, BlockPos blockPos, ServerboundPlayerActionPacket.Action action, Direction direction, int worldHeight, int sequence) {
+
+    }
+}
diff --git a/src/main/java/io/papermc/paper/antixray/ChunkPacketBlockControllerAntiXray.java b/src/main/java/io/papermc/paper/antixray/ChunkPacketBlockControllerAntiXray.java
new file mode 100644
index 0000000000000000000000000000000000000000..ee2d3a54d760f9c26542eab03c51651a30e279a0
--- /dev/null
+++ b/src/main/java/io/papermc/paper/antixray/ChunkPacketBlockControllerAntiXray.java
@@ -0,0 +1,676 @@
+package io.papermc.paper.antixray;
+
+import io.papermc.paper.configuration.WorldConfiguration;
+import io.papermc.paper.configuration.type.EngineMode;
+import java.util.ArrayList;
+import java.util.LinkedHashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ThreadLocalRandom;
+import java.util.function.IntSupplier;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
+import net.minecraft.network.protocol.game.ServerboundPlayerActionPacket;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.level.ServerPlayerGameMode;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.biome.Biomes;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.EntityBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.EmptyLevelChunk;
+import net.minecraft.world.level.chunk.GlobalPalette;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.LevelChunkSection;
+import net.minecraft.world.level.chunk.MissingPaletteEntryException;
+import net.minecraft.world.level.chunk.Palette;
+import org.bukkit.Bukkit;
+
+public final class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockController {
+
+    private static final Palette<BlockState> GLOBAL_BLOCKSTATE_PALETTE = new GlobalPalette<>(Block.BLOCK_STATE_REGISTRY);
+    private static final LevelChunkSection EMPTY_SECTION = null;
+    private final Executor executor;
+    private final EngineMode engineMode;
+    private final int maxBlockHeight;
+    private final int updateRadius;
+    private final boolean usePermission;
+    private final BlockState[] presetBlockStates;
+    private final BlockState[] presetBlockStatesFull;
+    private final BlockState[] presetBlockStatesStone;
+    private final BlockState[] presetBlockStatesDeepslate;
+    private final BlockState[] presetBlockStatesNetherrack;
+    private final BlockState[] presetBlockStatesEndStone;
+    private final int[] presetBlockStateBitsGlobal;
+    private final int[] presetBlockStateBitsStoneGlobal;
+    private final int[] presetBlockStateBitsDeepslateGlobal;
+    private final int[] presetBlockStateBitsNetherrackGlobal;
+    private final int[] presetBlockStateBitsEndStoneGlobal;
+    private final boolean[] solidGlobal = new boolean[Block.BLOCK_STATE_REGISTRY.size()];
+    private final boolean[] obfuscateGlobal = new boolean[Block.BLOCK_STATE_REGISTRY.size()];
+    private final LevelChunkSection[] emptyNearbyChunkSections = {EMPTY_SECTION, EMPTY_SECTION, EMPTY_SECTION, EMPTY_SECTION};
+    private final int maxBlockHeightUpdatePosition;
+
+    public ChunkPacketBlockControllerAntiXray(Level level, Executor executor) {
+        this.executor = executor;
+        WorldConfiguration.Anticheat.AntiXray paperWorldConfig = level.paperConfig().anticheat.antiXray;
+        engineMode = paperWorldConfig.engineMode;
+        maxBlockHeight = paperWorldConfig.maxBlockHeight >> 4 << 4;
+        updateRadius = paperWorldConfig.updateRadius;
+        usePermission = paperWorldConfig.usePermission;
+        List<Block> toObfuscate;
+
+        if (engineMode == EngineMode.HIDE) {
+            toObfuscate = paperWorldConfig.hiddenBlocks;
+            presetBlockStates = null;
+            presetBlockStatesFull = null;
+            presetBlockStatesStone = new BlockState[]{Blocks.STONE.defaultBlockState()};
+            presetBlockStatesDeepslate = new BlockState[]{Blocks.DEEPSLATE.defaultBlockState()};
+            presetBlockStatesNetherrack = new BlockState[]{Blocks.NETHERRACK.defaultBlockState()};
+            presetBlockStatesEndStone = new BlockState[]{Blocks.END_STONE.defaultBlockState()};
+            presetBlockStateBitsGlobal = null;
+            presetBlockStateBitsStoneGlobal = new int[]{GLOBAL_BLOCKSTATE_PALETTE.idFor(Blocks.STONE.defaultBlockState())};
+            presetBlockStateBitsDeepslateGlobal = new int[]{GLOBAL_BLOCKSTATE_PALETTE.idFor(Blocks.DEEPSLATE.defaultBlockState())};
+            presetBlockStateBitsNetherrackGlobal = new int[]{GLOBAL_BLOCKSTATE_PALETTE.idFor(Blocks.NETHERRACK.defaultBlockState())};
+            presetBlockStateBitsEndStoneGlobal = new int[]{GLOBAL_BLOCKSTATE_PALETTE.idFor(Blocks.END_STONE.defaultBlockState())};
+        } else {
+            toObfuscate = new ArrayList<>(paperWorldConfig.replacementBlocks);
+            List<BlockState> presetBlockStateList = new LinkedList<>();
+
+            for (Block block : paperWorldConfig.hiddenBlocks) {
+
+                if (!(block instanceof EntityBlock)) {
+                    toObfuscate.add(block);
+                    presetBlockStateList.add(block.defaultBlockState());
+                }
+            }
+
+            // The doc of the LinkedHashSet(Collection<? extends E>) constructor doesn't specify that the insertion order is the predictable iteration order of the specified Collection, although it is in the implementation
+            Set<BlockState> presetBlockStateSet = new LinkedHashSet<>();
+            // Therefore addAll(Collection<? extends E>) is used, which guarantees this order in the doc
+            presetBlockStateSet.addAll(presetBlockStateList);
+            presetBlockStates = presetBlockStateSet.isEmpty() ? new BlockState[]{Blocks.DIAMOND_ORE.defaultBlockState()} : presetBlockStateSet.toArray(new BlockState[0]);
+            presetBlockStatesFull = presetBlockStateSet.isEmpty() ? new BlockState[]{Blocks.DIAMOND_ORE.defaultBlockState()} : presetBlockStateList.toArray(new BlockState[0]);
+            presetBlockStatesStone = null;
+            presetBlockStatesDeepslate = null;
+            presetBlockStatesNetherrack = null;
+            presetBlockStatesEndStone = null;
+            presetBlockStateBitsGlobal = new int[presetBlockStatesFull.length];
+
+            for (int i = 0; i < presetBlockStatesFull.length; i++) {
+                presetBlockStateBitsGlobal[i] = GLOBAL_BLOCKSTATE_PALETTE.idFor(presetBlockStatesFull[i]);
+            }
+
+            presetBlockStateBitsStoneGlobal = null;
+            presetBlockStateBitsDeepslateGlobal = null;
+            presetBlockStateBitsNetherrackGlobal = null;
+            presetBlockStateBitsEndStoneGlobal = null;
+        }
+
+        for (Block block : toObfuscate) {
+
+            // Don't obfuscate air because air causes unnecessary block updates and causes block updates to fail in the void
+            if (block != null && !block.defaultBlockState().isAir()) {
+                // Replace all block states of a specified block
+                for (BlockState blockState : block.getStateDefinition().getPossibleStates()) {
+                    obfuscateGlobal[GLOBAL_BLOCKSTATE_PALETTE.idFor(blockState)] = true;
+                }
+            }
+        }
+
+        EmptyLevelChunk emptyChunk = new EmptyLevelChunk(level, new ChunkPos(0, 0), MinecraftServer.getServer().registryAccess().lookupOrThrow(Registries.BIOME).getOrThrow(Biomes.PLAINS));
+        BlockPos zeroPos = new BlockPos(0, 0, 0);
+
+        for (int i = 0; i < solidGlobal.length; i++) {
+            BlockState blockState = GLOBAL_BLOCKSTATE_PALETTE.valueFor(i);
+
+            if (blockState != null) {
+                solidGlobal[i] = blockState.isRedstoneConductor(emptyChunk, zeroPos)
+                    && blockState.getBlock() != Blocks.SPAWNER && blockState.getBlock() != Blocks.BARRIER && blockState.getBlock() != Blocks.SHULKER_BOX && blockState.getBlock() != Blocks.SLIME_BLOCK && blockState.getBlock() != Blocks.MANGROVE_ROOTS || paperWorldConfig.lavaObscures && blockState == Blocks.LAVA.defaultBlockState();
+                // Comparing blockState == Blocks.LAVA.defaultBlockState() instead of blockState.getBlock() == Blocks.LAVA ensures that only "stationary lava" is used
+                // shulker box checks TE.
+            }
+        }
+
+        maxBlockHeightUpdatePosition = maxBlockHeight + updateRadius - 1;
+    }
+
+    private int getPresetBlockStatesFullLength() {
+        return engineMode == EngineMode.HIDE ? 1 : presetBlockStatesFull.length;
+    }
+
+    @Override
+    public BlockState[] getPresetBlockStates(Level level, ChunkPos chunkPos, int chunkSectionY) {
+        // Return the block states to be added to the paletted containers so that they can be used for obfuscation
+        int bottomBlockY = chunkSectionY << 4;
+
+        if (bottomBlockY < maxBlockHeight) {
+            if (engineMode == EngineMode.HIDE) {
+                return switch (level.getWorld().getEnvironment()) {
+                    case NETHER -> presetBlockStatesNetherrack;
+                    case THE_END -> presetBlockStatesEndStone;
+                    default -> bottomBlockY < 0 ? presetBlockStatesDeepslate : presetBlockStatesStone;
+                };
+            }
+
+            return presetBlockStates;
+        }
+
+        return null;
+    }
+
+    @Override
+    public boolean shouldModify(ServerPlayer player, LevelChunk chunk) {
+        return !usePermission || !player.getBukkitEntity().hasPermission("paper.antixray.bypass");
+    }
+
+    @Override
+    public ChunkPacketInfoAntiXray getChunkPacketInfo(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk) {
+        // Return a new instance to collect data and objects in the right state while creating the chunk packet for thread safe access later
+        return new ChunkPacketInfoAntiXray(chunkPacket, chunk, this);
+    }
+
+    @Override
+    public void modifyBlocks(ClientboundLevelChunkWithLightPacket chunkPacket, ChunkPacketInfo<BlockState> chunkPacketInfo) {
+        if (!(chunkPacketInfo instanceof ChunkPacketInfoAntiXray)) {
+            chunkPacket.setReady(true);
+            return;
+        }
+
+        if (!Bukkit.isPrimaryThread()) {
+            // Plugins?
+            MinecraftServer.getServer().scheduleOnMain(() -> modifyBlocks(chunkPacket, chunkPacketInfo));
+            return;
+        }
+
+        LevelChunk chunk = chunkPacketInfo.getChunk();
+        int x = chunk.getPos().x;
+        int z = chunk.getPos().z;
+        Level level = chunk.getLevel();
+        ((ChunkPacketInfoAntiXray) chunkPacketInfo).setNearbyChunks(level.getChunkIfLoaded(x - 1, z), level.getChunkIfLoaded(x + 1, z), level.getChunkIfLoaded(x, z - 1), level.getChunkIfLoaded(x, z + 1));
+        executor.execute((Runnable) chunkPacketInfo);
+    }
+
+    // Actually these fields should be variables inside the obfuscate method but in sync mode or with SingleThreadExecutor in async mode it's okay (even without ThreadLocal)
+    // If an ExecutorService with multiple threads is used, ThreadLocal must be used here
+    private final ThreadLocal<int[]> presetBlockStateBits = ThreadLocal.withInitial(() -> new int[getPresetBlockStatesFullLength()]);
+    private static final ThreadLocal<boolean[]> SOLID = ThreadLocal.withInitial(() -> new boolean[Block.BLOCK_STATE_REGISTRY.size()]);
+    private static final ThreadLocal<boolean[]> OBFUSCATE = ThreadLocal.withInitial(() -> new boolean[Block.BLOCK_STATE_REGISTRY.size()]);
+    // These boolean arrays represent chunk layers, true means don't obfuscate, false means obfuscate
+    private static final ThreadLocal<boolean[][]> CURRENT = ThreadLocal.withInitial(() -> new boolean[16][16]);
+    private static final ThreadLocal<boolean[][]> NEXT = ThreadLocal.withInitial(() -> new boolean[16][16]);
+    private static final ThreadLocal<boolean[][]> NEXT_NEXT = ThreadLocal.withInitial(() -> new boolean[16][16]);
+
+    public void obfuscate(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+        int[] presetBlockStateBits = this.presetBlockStateBits.get();
+        boolean[] solid = SOLID.get();
+        boolean[] obfuscate = OBFUSCATE.get();
+        boolean[][] current = CURRENT.get();
+        boolean[][] next = NEXT.get();
+        boolean[][] nextNext = NEXT_NEXT.get();
+        // bitStorageReader, bitStorageWriter and nearbyChunkSections could also be reused (with ThreadLocal if necessary) but it's not worth it
+        BitStorageReader bitStorageReader = new BitStorageReader();
+        BitStorageWriter bitStorageWriter = new BitStorageWriter();
+        LevelChunkSection[] nearbyChunkSections = new LevelChunkSection[4];
+        LevelChunk chunk = chunkPacketInfoAntiXray.getChunk();
+        Level level = chunk.getLevel();
+        int maxChunkSectionIndex = Math.min((maxBlockHeight >> 4) - chunk.getMinSectionY(), chunk.getSectionsCount()) - 1;
+        boolean[] solidTemp = null;
+        boolean[] obfuscateTemp = null;
+        bitStorageReader.setBuffer(chunkPacketInfoAntiXray.getBuffer());
+        bitStorageWriter.setBuffer(chunkPacketInfoAntiXray.getBuffer());
+        int numberOfBlocks = presetBlockStateBits.length;
+        // Keep the lambda expressions as simple as possible. They are used very frequently.
+        LayeredIntSupplier random = numberOfBlocks == 1 ? (() -> 0) : engineMode == EngineMode.OBFUSCATE_LAYER ? new LayeredIntSupplier() {
+            // engine-mode: 3
+            private int state;
+            private int next;
+
+            {
+                while ((state = ThreadLocalRandom.current().nextInt()) == 0) ;
+            }
+
+            @Override
+            public void nextLayer() {
+                // https://en.wikipedia.org/wiki/Xorshift
+                state ^= state << 13;
+                state ^= state >>> 17;
+                state ^= state << 5;
+                // https://www.pcg-random.org/posts/bounded-rands.html
+                next = (int) ((Integer.toUnsignedLong(state) * numberOfBlocks) >>> 32);
+            }
+
+            @Override
+            public int getAsInt() {
+                return next;
+            }
+        } : new LayeredIntSupplier() {
+            // engine-mode: 2
+            private int state;
+
+            {
+                while ((state = ThreadLocalRandom.current().nextInt()) == 0) ;
+            }
+
+            @Override
+            public int getAsInt() {
+                // https://en.wikipedia.org/wiki/Xorshift
+                state ^= state << 13;
+                state ^= state >>> 17;
+                state ^= state << 5;
+                // https://www.pcg-random.org/posts/bounded-rands.html
+                return (int) ((Integer.toUnsignedLong(state) * numberOfBlocks) >>> 32);
+            }
+        };
+
+        for (int chunkSectionIndex = 0; chunkSectionIndex <= maxChunkSectionIndex; chunkSectionIndex++) {
+            if (chunkPacketInfoAntiXray.isWritten(chunkSectionIndex) && chunkPacketInfoAntiXray.getPresetValues(chunkSectionIndex) != null) {
+                int[] presetBlockStateBitsTemp;
+
+                if (chunkPacketInfoAntiXray.getPalette(chunkSectionIndex) instanceof GlobalPalette) {
+                    if (engineMode == EngineMode.HIDE) {
+                        presetBlockStateBitsTemp = switch (level.getWorld().getEnvironment()) {
+                            case NETHER -> presetBlockStateBitsNetherrackGlobal;
+                            case THE_END -> presetBlockStateBitsEndStoneGlobal;
+                            default -> chunkSectionIndex + chunk.getMinSectionY() < 0 ? presetBlockStateBitsDeepslateGlobal : presetBlockStateBitsStoneGlobal;
+                        };
+                    } else {
+                        presetBlockStateBitsTemp = presetBlockStateBitsGlobal;
+                    }
+                } else {
+                    // If it's presetBlockStates, use this.presetBlockStatesFull instead
+                    BlockState[] presetBlockStatesFull = chunkPacketInfoAntiXray.getPresetValues(chunkSectionIndex) == presetBlockStates ? this.presetBlockStatesFull : chunkPacketInfoAntiXray.getPresetValues(chunkSectionIndex);
+                    presetBlockStateBitsTemp = presetBlockStateBits;
+
+                    for (int i = 0; i < presetBlockStateBitsTemp.length; i++) {
+                        // This is thread safe because we only request IDs that are guaranteed to be in the palette and are visible
+                        // For more details see the comments in the readPalette method
+                        presetBlockStateBitsTemp[i] = chunkPacketInfoAntiXray.getPalette(chunkSectionIndex).idFor(presetBlockStatesFull[i]);
+                    }
+                }
+
+                bitStorageWriter.setIndex(chunkPacketInfoAntiXray.getIndex(chunkSectionIndex));
+
+                // Check if the chunk section below was not obfuscated
+                if (chunkSectionIndex == 0 || !chunkPacketInfoAntiXray.isWritten(chunkSectionIndex - 1) || chunkPacketInfoAntiXray.getPresetValues(chunkSectionIndex - 1) == null) {
+                    // If so, initialize some stuff
+                    bitStorageReader.setBits(chunkPacketInfoAntiXray.getBits(chunkSectionIndex));
+                    bitStorageReader.setIndex(chunkPacketInfoAntiXray.getIndex(chunkSectionIndex));
+                    solidTemp = readPalette(chunkPacketInfoAntiXray.getPalette(chunkSectionIndex), solid, solidGlobal);
+                    obfuscateTemp = readPalette(chunkPacketInfoAntiXray.getPalette(chunkSectionIndex), obfuscate, obfuscateGlobal);
+                    // Read the blocks of the upper layer of the chunk section below if it exists
+                    LevelChunkSection belowChunkSection = null;
+                    boolean skipFirstLayer = chunkSectionIndex == 0 || (belowChunkSection = chunk.getSections()[chunkSectionIndex - 1]) == EMPTY_SECTION;
+
+                    for (int z = 0; z < 16; z++) {
+                        for (int x = 0; x < 16; x++) {
+                            current[z][x] = true;
+                            next[z][x] = skipFirstLayer || isTransparent(belowChunkSection, x, 15, z);
+                        }
+                    }
+
+                    // Abuse the obfuscateLayer method to read the blocks of the first layer of the current chunk section
+                    bitStorageWriter.setBits(0);
+                    obfuscateLayer(-1, bitStorageReader, bitStorageWriter, solidTemp, obfuscateTemp, presetBlockStateBitsTemp, current, next, nextNext, emptyNearbyChunkSections, random);
+                }
+
+                bitStorageWriter.setBits(chunkPacketInfoAntiXray.getBits(chunkSectionIndex));
+                nearbyChunkSections[0] = chunkPacketInfoAntiXray.getNearbyChunks()[0] == null ? EMPTY_SECTION : chunkPacketInfoAntiXray.getNearbyChunks()[0].getSections()[chunkSectionIndex];
+                nearbyChunkSections[1] = chunkPacketInfoAntiXray.getNearbyChunks()[1] == null ? EMPTY_SECTION : chunkPacketInfoAntiXray.getNearbyChunks()[1].getSections()[chunkSectionIndex];
+                nearbyChunkSections[2] = chunkPacketInfoAntiXray.getNearbyChunks()[2] == null ? EMPTY_SECTION : chunkPacketInfoAntiXray.getNearbyChunks()[2].getSections()[chunkSectionIndex];
+                nearbyChunkSections[3] = chunkPacketInfoAntiXray.getNearbyChunks()[3] == null ? EMPTY_SECTION : chunkPacketInfoAntiXray.getNearbyChunks()[3].getSections()[chunkSectionIndex];
+
+                // Obfuscate all layers of the current chunk section except the upper one
+                for (int y = 0; y < 15; y++) {
+                    boolean[][] temp = current;
+                    current = next;
+                    next = nextNext;
+                    nextNext = temp;
+                    random.nextLayer();
+                    obfuscateLayer(y, bitStorageReader, bitStorageWriter, solidTemp, obfuscateTemp, presetBlockStateBitsTemp, current, next, nextNext, nearbyChunkSections, random);
+                }
+
+                // Check if the chunk section above doesn't need obfuscation
+                if (chunkSectionIndex == maxChunkSectionIndex || !chunkPacketInfoAntiXray.isWritten(chunkSectionIndex + 1) || chunkPacketInfoAntiXray.getPresetValues(chunkSectionIndex + 1) == null) {
+                    // If so, obfuscate the upper layer of the current chunk section by reading blocks of the first layer from the chunk section above if it exists
+                    LevelChunkSection aboveChunkSection;
+
+                    if (chunkSectionIndex != chunk.getSectionsCount() - 1 && (aboveChunkSection = chunk.getSections()[chunkSectionIndex + 1]) != EMPTY_SECTION) {
+                        boolean[][] temp = current;
+                        current = next;
+                        next = nextNext;
+                        nextNext = temp;
+
+                        for (int z = 0; z < 16; z++) {
+                            for (int x = 0; x < 16; x++) {
+                                if (isTransparent(aboveChunkSection, x, 0, z)) {
+                                    current[z][x] = true;
+                                }
+                            }
+                        }
+
+                        // There is nothing to read anymore
+                        bitStorageReader.setBits(0);
+                        solid[0] = true;
+                        random.nextLayer();
+                        obfuscateLayer(15, bitStorageReader, bitStorageWriter, solid, obfuscateTemp, presetBlockStateBitsTemp, current, next, nextNext, nearbyChunkSections, random);
+                    }
+                } else {
+                    // If not, initialize the reader and other stuff for the chunk section above to obfuscate the upper layer of the current chunk section
+                    bitStorageReader.setBits(chunkPacketInfoAntiXray.getBits(chunkSectionIndex + 1));
+                    bitStorageReader.setIndex(chunkPacketInfoAntiXray.getIndex(chunkSectionIndex + 1));
+                    solidTemp = readPalette(chunkPacketInfoAntiXray.getPalette(chunkSectionIndex + 1), solid, solidGlobal);
+                    obfuscateTemp = readPalette(chunkPacketInfoAntiXray.getPalette(chunkSectionIndex + 1), obfuscate, obfuscateGlobal);
+                    boolean[][] temp = current;
+                    current = next;
+                    next = nextNext;
+                    nextNext = temp;
+                    random.nextLayer();
+                    obfuscateLayer(15, bitStorageReader, bitStorageWriter, solidTemp, obfuscateTemp, presetBlockStateBitsTemp, current, next, nextNext, nearbyChunkSections, random);
+                }
+
+                bitStorageWriter.flush();
+            }
+        }
+
+        chunkPacketInfoAntiXray.getChunkPacket().setReady(true);
+    }
+
+    private void obfuscateLayer(int y, BitStorageReader bitStorageReader, BitStorageWriter bitStorageWriter, boolean[] solid, boolean[] obfuscate, int[] presetBlockStateBits, boolean[][] current, boolean[][] next, boolean[][] nextNext, LevelChunkSection[] nearbyChunkSections, IntSupplier random) {
+        // First block of first line
+        int bits = bitStorageReader.read();
+
+        if (nextNext[0][0] = !solid[bits]) {
+            bitStorageWriter.skip();
+            next[0][1] = true;
+            next[1][0] = true;
+        } else {
+            if (current[0][0] || isTransparent(nearbyChunkSections[2], 0, y, 15) || isTransparent(nearbyChunkSections[0], 15, y, 0)) {
+                bitStorageWriter.skip();
+            } else {
+                bitStorageWriter.write(presetBlockStateBits[random.getAsInt()]);
+            }
+        }
+
+        if (!obfuscate[bits]) {
+            next[0][0] = true;
+        }
+
+        // First line
+        for (int x = 1; x < 15; x++) {
+            bits = bitStorageReader.read();
+
+            if (nextNext[0][x] = !solid[bits]) {
+                bitStorageWriter.skip();
+                next[0][x - 1] = true;
+                next[0][x + 1] = true;
+                next[1][x] = true;
+            } else {
+                if (current[0][x] || isTransparent(nearbyChunkSections[2], x, y, 15)) {
+                    bitStorageWriter.skip();
+                } else {
+                    bitStorageWriter.write(presetBlockStateBits[random.getAsInt()]);
+                }
+            }
+
+            if (!obfuscate[bits]) {
+                next[0][x] = true;
+            }
+        }
+
+        // Last block of first line
+        bits = bitStorageReader.read();
+
+        if (nextNext[0][15] = !solid[bits]) {
+            bitStorageWriter.skip();
+            next[0][14] = true;
+            next[1][15] = true;
+        } else {
+            if (current[0][15] || isTransparent(nearbyChunkSections[2], 15, y, 15) || isTransparent(nearbyChunkSections[1], 0, y, 0)) {
+                bitStorageWriter.skip();
+            } else {
+                bitStorageWriter.write(presetBlockStateBits[random.getAsInt()]);
+            }
+        }
+
+        if (!obfuscate[bits]) {
+            next[0][15] = true;
+        }
+
+        // All inner lines
+        for (int z = 1; z < 15; z++) {
+            // First block
+            bits = bitStorageReader.read();
+
+            if (nextNext[z][0] = !solid[bits]) {
+                bitStorageWriter.skip();
+                next[z][1] = true;
+                next[z - 1][0] = true;
+                next[z + 1][0] = true;
+            } else {
+                if (current[z][0] || isTransparent(nearbyChunkSections[0], 15, y, z)) {
+                    bitStorageWriter.skip();
+                } else {
+                    bitStorageWriter.write(presetBlockStateBits[random.getAsInt()]);
+                }
+            }
+
+            if (!obfuscate[bits]) {
+                next[z][0] = true;
+            }
+
+            // All inner blocks
+            for (int x = 1; x < 15; x++) {
+                bits = bitStorageReader.read();
+
+                if (nextNext[z][x] = !solid[bits]) {
+                    bitStorageWriter.skip();
+                    next[z][x - 1] = true;
+                    next[z][x + 1] = true;
+                    next[z - 1][x] = true;
+                    next[z + 1][x] = true;
+                } else {
+                    if (current[z][x]) {
+                        bitStorageWriter.skip();
+                    } else {
+                        bitStorageWriter.write(presetBlockStateBits[random.getAsInt()]);
+                    }
+                }
+
+                if (!obfuscate[bits]) {
+                    next[z][x] = true;
+                }
+            }
+
+            // Last block
+            bits = bitStorageReader.read();
+
+            if (nextNext[z][15] = !solid[bits]) {
+                bitStorageWriter.skip();
+                next[z][14] = true;
+                next[z - 1][15] = true;
+                next[z + 1][15] = true;
+            } else {
+                if (current[z][15] || isTransparent(nearbyChunkSections[1], 0, y, z)) {
+                    bitStorageWriter.skip();
+                } else {
+                    bitStorageWriter.write(presetBlockStateBits[random.getAsInt()]);
+                }
+            }
+
+            if (!obfuscate[bits]) {
+                next[z][15] = true;
+            }
+        }
+
+        // First block of last line
+        bits = bitStorageReader.read();
+
+        if (nextNext[15][0] = !solid[bits]) {
+            bitStorageWriter.skip();
+            next[15][1] = true;
+            next[14][0] = true;
+        } else {
+            if (current[15][0] || isTransparent(nearbyChunkSections[3], 0, y, 0) || isTransparent(nearbyChunkSections[0], 15, y, 15)) {
+                bitStorageWriter.skip();
+            } else {
+                bitStorageWriter.write(presetBlockStateBits[random.getAsInt()]);
+            }
+        }
+
+        if (!obfuscate[bits]) {
+            next[15][0] = true;
+        }
+
+        // Last line
+        for (int x = 1; x < 15; x++) {
+            bits = bitStorageReader.read();
+
+            if (nextNext[15][x] = !solid[bits]) {
+                bitStorageWriter.skip();
+                next[15][x - 1] = true;
+                next[15][x + 1] = true;
+                next[14][x] = true;
+            } else {
+                if (current[15][x] || isTransparent(nearbyChunkSections[3], x, y, 0)) {
+                    bitStorageWriter.skip();
+                } else {
+                    bitStorageWriter.write(presetBlockStateBits[random.getAsInt()]);
+                }
+            }
+
+            if (!obfuscate[bits]) {
+                next[15][x] = true;
+            }
+        }
+
+        // Last block of last line
+        bits = bitStorageReader.read();
+
+        if (nextNext[15][15] = !solid[bits]) {
+            bitStorageWriter.skip();
+            next[15][14] = true;
+            next[14][15] = true;
+        } else {
+            if (current[15][15] || isTransparent(nearbyChunkSections[3], 15, y, 0) || isTransparent(nearbyChunkSections[1], 0, y, 15)) {
+                bitStorageWriter.skip();
+            } else {
+                bitStorageWriter.write(presetBlockStateBits[random.getAsInt()]);
+            }
+        }
+
+        if (!obfuscate[bits]) {
+            next[15][15] = true;
+        }
+    }
+
+    private boolean isTransparent(LevelChunkSection chunkSection, int x, int y, int z) {
+        if (chunkSection == EMPTY_SECTION) {
+            return true;
+        }
+
+        try {
+            return !solidGlobal[GLOBAL_BLOCKSTATE_PALETTE.idFor(chunkSection.getBlockState(x, y, z))];
+        } catch (MissingPaletteEntryException e) {
+            // Race condition / visibility issue / no happens-before relationship
+            // We don't care and treat the block as transparent
+            // Internal implementation details of PalettedContainer, LinearPalette, HashMapPalette, CrudeIncrementalIntIdentityHashBiMap, ... guarantee us that no (other) exceptions will occur
+            return true;
+        }
+    }
+
+    private boolean[] readPalette(Palette<BlockState> palette, boolean[] temp, boolean[] global) {
+        if (palette instanceof GlobalPalette) {
+            return global;
+        }
+
+        try {
+            for (int i = 0; i < palette.getSize(); i++) {
+                temp[i] = global[GLOBAL_BLOCKSTATE_PALETTE.idFor(palette.valueFor(i))];
+            }
+        } catch (MissingPaletteEntryException e) {
+            // Race condition / visibility issue / no happens-before relationship
+            // We don't care because we at least see the state as it was when the chunk packet was created
+            // Internal implementation details of PalettedContainer, LinearPalette, HashMapPalette, CrudeIncrementalIntIdentityHashBiMap, ... guarantee us that no (other) exceptions will occur until we have all the data that we need here
+            // Since all palettes have a fixed initial maximum size and there is no internal restructuring and no values are removed from palettes, we are also guaranteed to see the data
+        }
+
+        return temp;
+    }
+
+    @Override
+    public void onBlockChange(Level level, BlockPos blockPos, BlockState newBlockState, BlockState oldBlockState, int flags, int maxUpdateDepth) {
+        if (oldBlockState != null && solidGlobal[GLOBAL_BLOCKSTATE_PALETTE.idFor(oldBlockState)] && !solidGlobal[GLOBAL_BLOCKSTATE_PALETTE.idFor(newBlockState)] && blockPos.getY() <= maxBlockHeightUpdatePosition) {
+            updateNearbyBlocks(level, blockPos);
+        }
+    }
+
+    @Override
+    public void onPlayerLeftClickBlock(ServerPlayerGameMode serverPlayerGameMode, BlockPos blockPos, ServerboundPlayerActionPacket.Action action, Direction direction, int worldHeight, int sequence) {
+        if (blockPos.getY() <= maxBlockHeightUpdatePosition) {
+            updateNearbyBlocks(serverPlayerGameMode.level, blockPos);
+        }
+    }
+
+    private void updateNearbyBlocks(Level level, BlockPos blockPos) {
+        if (updateRadius >= 2) {
+            BlockPos temp = blockPos.west();
+            updateBlock(level, temp);
+            updateBlock(level, temp.west());
+            updateBlock(level, temp.below());
+            updateBlock(level, temp.above());
+            updateBlock(level, temp.north());
+            updateBlock(level, temp.south());
+            updateBlock(level, temp = blockPos.east());
+            updateBlock(level, temp.east());
+            updateBlock(level, temp.below());
+            updateBlock(level, temp.above());
+            updateBlock(level, temp.north());
+            updateBlock(level, temp.south());
+            updateBlock(level, temp = blockPos.below());
+            updateBlock(level, temp.below());
+            updateBlock(level, temp.north());
+            updateBlock(level, temp.south());
+            updateBlock(level, temp = blockPos.above());
+            updateBlock(level, temp.above());
+            updateBlock(level, temp.north());
+            updateBlock(level, temp.south());
+            updateBlock(level, temp = blockPos.north());
+            updateBlock(level, temp.north());
+            updateBlock(level, temp = blockPos.south());
+            updateBlock(level, temp.south());
+        } else if (updateRadius == 1) {
+            updateBlock(level, blockPos.west());
+            updateBlock(level, blockPos.east());
+            updateBlock(level, blockPos.below());
+            updateBlock(level, blockPos.above());
+            updateBlock(level, blockPos.north());
+            updateBlock(level, blockPos.south());
+        } else {
+            // Do nothing if updateRadius <= 0 (test mode)
+        }
+    }
+
+    private void updateBlock(Level level, BlockPos blockPos) {
+        BlockState blockState = level.getBlockStateIfLoaded(blockPos);
+
+        if (blockState != null && obfuscateGlobal[GLOBAL_BLOCKSTATE_PALETTE.idFor(blockState)]) {
+            ((ServerLevel) level).getChunkSource().blockChanged(blockPos);
+        }
+    }
+
+    @FunctionalInterface
+    private interface LayeredIntSupplier extends IntSupplier {
+        default void nextLayer() {
+
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/antixray/ChunkPacketInfo.java b/src/main/java/io/papermc/paper/antixray/ChunkPacketInfo.java
new file mode 100644
index 0000000000000000000000000000000000000000..a33a4d45d478ededff27244fcb910d3f369f2151
--- /dev/null
+++ b/src/main/java/io/papermc/paper/antixray/ChunkPacketInfo.java
@@ -0,0 +1,80 @@
+package io.papermc.paper.antixray;
+
+import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.Palette;
+
+public class ChunkPacketInfo<T> {
+
+    private final ClientboundLevelChunkWithLightPacket chunkPacket;
+    private final LevelChunk chunk;
+    private final int[] bits;
+    private final Object[] palettes;
+    private final int[] indexes;
+    private final Object[][] presetValues;
+    private byte[] buffer;
+
+    public ChunkPacketInfo(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk) {
+        this.chunkPacket = chunkPacket;
+        this.chunk = chunk;
+        int sections = chunk.getSectionsCount();
+        bits = new int[sections];
+        palettes = new Object[sections];
+        indexes = new int[sections];
+        presetValues = new Object[sections][];
+    }
+
+    public ClientboundLevelChunkWithLightPacket getChunkPacket() {
+        return chunkPacket;
+    }
+
+    public LevelChunk getChunk() {
+        return chunk;
+    }
+
+    public byte[] getBuffer() {
+        return buffer;
+    }
+
+    public void setBuffer(byte[] buffer) {
+        this.buffer = buffer;
+    }
+
+    public int getBits(int chunkSectionIndex) {
+        return bits[chunkSectionIndex];
+    }
+
+    public void setBits(int chunkSectionIndex, int bits) {
+        this.bits[chunkSectionIndex] = bits;
+    }
+
+    @SuppressWarnings("unchecked")
+    public Palette<T> getPalette(int chunkSectionIndex) {
+        return (Palette<T>) palettes[chunkSectionIndex];
+    }
+
+    public void setPalette(int chunkSectionIndex, Palette<T> palette) {
+        palettes[chunkSectionIndex] = palette;
+    }
+
+    public int getIndex(int chunkSectionIndex) {
+        return indexes[chunkSectionIndex];
+    }
+
+    public void setIndex(int chunkSectionIndex, int index) {
+        indexes[chunkSectionIndex] = index;
+    }
+
+    @SuppressWarnings("unchecked")
+    public T[] getPresetValues(int chunkSectionIndex) {
+        return (T[]) presetValues[chunkSectionIndex];
+    }
+
+    public void setPresetValues(int chunkSectionIndex, T[] presetValues) {
+        this.presetValues[chunkSectionIndex] = presetValues;
+    }
+
+    public boolean isWritten(int chunkSectionIndex) {
+        return bits[chunkSectionIndex] != 0;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/antixray/ChunkPacketInfoAntiXray.java b/src/main/java/io/papermc/paper/antixray/ChunkPacketInfoAntiXray.java
new file mode 100644
index 0000000000000000000000000000000000000000..7d8dff55bfe6779244fcddda284d1faadf2fd261
--- /dev/null
+++ b/src/main/java/io/papermc/paper/antixray/ChunkPacketInfoAntiXray.java
@@ -0,0 +1,29 @@
+package io.papermc.paper.antixray;
+
+import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.LevelChunk;
+
+public final class ChunkPacketInfoAntiXray extends ChunkPacketInfo<BlockState> implements Runnable {
+
+    private final ChunkPacketBlockControllerAntiXray chunkPacketBlockControllerAntiXray;
+    private LevelChunk[] nearbyChunks;
+
+    public ChunkPacketInfoAntiXray(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk, ChunkPacketBlockControllerAntiXray chunkPacketBlockControllerAntiXray) {
+        super(chunkPacket, chunk);
+        this.chunkPacketBlockControllerAntiXray = chunkPacketBlockControllerAntiXray;
+    }
+
+    public LevelChunk[] getNearbyChunks() {
+        return nearbyChunks;
+    }
+
+    public void setNearbyChunks(LevelChunk... nearbyChunks) {
+        this.nearbyChunks = nearbyChunks;
+    }
+
+    @Override
+    public void run() {
+        chunkPacketBlockControllerAntiXray.obfuscate(this);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/PaperCommandSourceStack.java b/src/main/java/io/papermc/paper/command/brigadier/PaperCommandSourceStack.java
index 1b1642f306771f029e6214a2e2ebebb6ae6abc3e..0f7bbc9193bde9a0df296fb63e861aaae278f861 100644
--- a/src/main/java/io/papermc/paper/command/brigadier/PaperCommandSourceStack.java
+++ b/src/main/java/io/papermc/paper/command/brigadier/PaperCommandSourceStack.java
@@ -1,21 +1,23 @@
 package io.papermc.paper.command.brigadier;
 
 import com.destroystokyo.paper.brigadier.BukkitBrigadierCommandSource;
+import com.google.common.base.Preconditions;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.phys.Vec2;
 import net.minecraft.world.phys.Vec3;
 import org.bukkit.Location;
 import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.entity.CraftEntity;
 import org.bukkit.entity.Entity;
-import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
 
 public interface PaperCommandSourceStack extends CommandSourceStack, BukkitBrigadierCommandSource {
 
     net.minecraft.commands.CommandSourceStack getHandle();
 
     @Override
-    default @NotNull Location getLocation() {
+    default @NonNull Location getLocation() {
         Vec2 rot = this.getHandle().getRotation();
         Vec3 pos = this.getHandle().getPosition();
         Level level = this.getHandle().getLevel();
@@ -24,7 +26,7 @@ public interface PaperCommandSourceStack extends CommandSourceStack, BukkitBriga
     }
 
     @Override
-    @NotNull
+    @NonNull
     default CommandSender getSender() {
         return this.getHandle().getBukkitSender();
     }
@@ -40,6 +42,12 @@ public interface PaperCommandSourceStack extends CommandSourceStack, BukkitBriga
         return nmsEntity.getBukkitEntity();
     }
 
+    @Override
+    default CommandSourceStack withExecutor(@NonNull Entity executor) {
+        Preconditions.checkNotNull(executor, "Executor cannot be null.");
+        return this.getHandle().withEntity(((CraftEntity) executor).getHandle());
+    }
+
     // OLD METHODS
     @Override
     default org.bukkit.entity.Entity getBukkitEntity() {
diff --git a/src/main/java/io/papermc/paper/command/subcommands/EntityCommand.java b/src/main/java/io/papermc/paper/command/subcommands/EntityCommand.java
index f671b74e4179fc29bc600b52e456ba9f78d8bbd6..bbd29bcca94a81ad2603afa9ddcb160e925b405e 100644
--- a/src/main/java/io/papermc/paper/command/subcommands/EntityCommand.java
+++ b/src/main/java/io/papermc/paper/command/subcommands/EntityCommand.java
@@ -48,7 +48,7 @@ public final class EntityCommand implements PaperSubcommand {
         if (args.length == 1) {
             return CommandUtil.getListMatchingLast(sender, args, "help", "list");
         } else if (args.length == 2) {
-            return CommandUtil.getListMatchingLast(sender, args, BuiltInRegistries.ENTITY_TYPE.keySet().stream().map(ResourceLocation::toString).sorted().toArray(String[]::new));
+            return CommandUtil.getListMatchingLast(sender, args, BuiltInRegistries.ENTITY_TYPE.keySet());
         }
         return Collections.emptyList();
     }
diff --git a/src/main/java/io/papermc/paper/configuration/Configurations.java b/src/main/java/io/papermc/paper/configuration/Configurations.java
index 8cf720f08514e8e4f62f4ad196f1277bd761c6b2..4a9258b62db3a9d1150f0dfbe916fa549b596686 100644
--- a/src/main/java/io/papermc/paper/configuration/Configurations.java
+++ b/src/main/java/io/papermc/paper/configuration/Configurations.java
@@ -80,7 +80,7 @@ public abstract class Configurations<G, W> {
     }
 
     @MustBeInvokedByOverriders
-    protected YamlConfigurationLoader.Builder createGlobalLoaderBuilder() {
+    protected YamlConfigurationLoader.Builder createGlobalLoaderBuilder(RegistryAccess registryAccess) {
         return this.createLoaderBuilder();
     }
 
@@ -104,7 +104,7 @@ public abstract class Configurations<G, W> {
     }
 
     public G initializeGlobalConfiguration(final RegistryAccess registryAccess) throws ConfigurateException {
-        return this.initializeGlobalConfiguration(creator(this.globalConfigClass, true));
+        return this.initializeGlobalConfiguration(registryAccess, creator(this.globalConfigClass, true));
     }
 
     private void trySaveFileNode(YamlConfigurationLoader loader, ConfigurationNode node, String filename) throws ConfigurateException {
@@ -117,9 +117,9 @@ public abstract class Configurations<G, W> {
         }
     }
 
-    protected G initializeGlobalConfiguration(final CheckedFunction<ConfigurationNode, G, SerializationException> creator) throws ConfigurateException {
+    protected G initializeGlobalConfiguration(final RegistryAccess registryAccess, final CheckedFunction<ConfigurationNode, G, SerializationException> creator) throws ConfigurateException {
         final Path configFile = this.globalFolder.resolve(this.globalConfigFileName);
-        final YamlConfigurationLoader loader = this.createGlobalLoaderBuilder()
+        final YamlConfigurationLoader loader = this.createGlobalLoaderBuilder(registryAccess)
             .defaultOptions(this.applyObjectMapperFactory(this.createGlobalObjectMapperFactoryBuilder().build()))
             .path(configFile)
             .build();
@@ -275,7 +275,7 @@ public abstract class Configurations<G, W> {
     }
 
     public Path getWorldConfigFile(ServerLevel level) {
-        return level.convertable.levelDirectory.path().resolve(this.worldConfigFileName);
+        return level.levelStorageAccess.levelDirectory.path().resolve(this.worldConfigFileName);
     }
 
     public static class ContextMap {
diff --git a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
index 088b8fe5d144807f4da1e85b2fa34dfd21286f8c..d4a0b684e7e5a5d7ea1106d0adeccf12d501676c 100644
--- a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
@@ -5,10 +5,14 @@ import io.papermc.paper.FeatureHooks;
 import io.papermc.paper.configuration.constraint.Constraints;
 import io.papermc.paper.configuration.type.number.DoubleOr;
 import io.papermc.paper.configuration.type.number.IntOr;
+import io.papermc.paper.util.ItemObfuscationBinding;
 import net.kyori.adventure.text.Component;
 import net.kyori.adventure.text.format.NamedTextColor;
+import net.minecraft.core.component.DataComponents;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ServerboundPlaceRecipePacket;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.item.Items;
 import org.jspecify.annotations.Nullable;
 import org.slf4j.Logger;
 import org.spongepowered.configurate.objectmapping.ConfigSerializable;
@@ -20,6 +24,7 @@ import org.spongepowered.configurate.objectmapping.meta.Setting;
 import java.util.Map;
 import java.util.Objects;
 import java.util.OptionalInt;
+import java.util.Set;
 
 @SuppressWarnings({"CanBeFinal", "FieldCanBeLocal", "FieldMayBeFinal", "NotNullFieldNotInitialized", "InnerClassMayBeStatic"})
 public class GlobalConfiguration extends ConfigurationPart {
@@ -69,7 +74,7 @@ public class GlobalConfiguration extends ConfigurationPart {
         )
         public int playerMaxConcurrentChunkGenerates = 0;
     }
-    static void set(GlobalConfiguration instance) {
+    static void set(final GlobalConfiguration instance) {
         GlobalConfiguration.instance = instance;
     }
 
@@ -189,7 +194,6 @@ public class GlobalConfiguration extends ConfigurationPart {
 
     public class Commands extends ConfigurationPart {
         public boolean suggestPlayerNamesWhenNullTabCompletions = true;
-        public boolean fixTargetSelectorTagCompletion = true;
         public boolean timeCommandAffectsAllWorlds = false;
     }
 
@@ -354,4 +358,41 @@ public class GlobalConfiguration extends ConfigurationPart {
         public boolean disableChorusPlantUpdates = false;
         public boolean disableMushroomBlockUpdates = false;
     }
+
+    public Anticheat anticheat;
+
+    public class Anticheat extends ConfigurationPart {
+
+        public Obfuscation obfuscation;
+
+        public class Obfuscation extends ConfigurationPart {
+            public Items items;
+
+            public class Items extends ConfigurationPart {
+
+                public boolean enableItemObfuscation = false;
+                public ItemObfuscationBinding.AssetObfuscationConfiguration allModels = new ItemObfuscationBinding.AssetObfuscationConfiguration(
+                    true,
+                    Set.of(DataComponents.LODESTONE_TRACKER),
+                    Set.of()
+                );
+
+                public Map<ResourceLocation, ItemObfuscationBinding.AssetObfuscationConfiguration> modelOverrides = Map.of(
+                    Objects.requireNonNull(net.minecraft.world.item.Items.ELYTRA.components().get(DataComponents.ITEM_MODEL)),
+                    new ItemObfuscationBinding.AssetObfuscationConfiguration(
+                        true,
+                        Set.of(DataComponents.DAMAGE),
+                        Set.of()
+                    )
+                );
+
+                public transient ItemObfuscationBinding binding;
+
+                @PostProcess
+                public void bindDataSanitizer() {
+                    this.binding = new ItemObfuscationBinding(this);
+                }
+            }
+        }
+    }
 }
diff --git a/src/main/java/io/papermc/paper/configuration/PaperConfigurations.java b/src/main/java/io/papermc/paper/configuration/PaperConfigurations.java
index c5644d8d64f12073e39bc6ed79c8714f4560ff89..e48fa405d92fab221fa8331b65c8f324e801d439 100644
--- a/src/main/java/io/papermc/paper/configuration/PaperConfigurations.java
+++ b/src/main/java/io/papermc/paper/configuration/PaperConfigurations.java
@@ -10,6 +10,7 @@ import io.papermc.paper.configuration.serializer.ComponentSerializer;
 import io.papermc.paper.configuration.serializer.EnumValueSerializer;
 import io.papermc.paper.configuration.serializer.NbtPathSerializer;
 import io.papermc.paper.configuration.serializer.PacketClassSerializer;
+import io.papermc.paper.configuration.serializer.ResourceLocationSerializer;
 import io.papermc.paper.configuration.serializer.StringRepresentableSerializer;
 import io.papermc.paper.configuration.serializer.collections.FastutilMapSerializer;
 import io.papermc.paper.configuration.serializer.collections.MapSerializer;
@@ -48,6 +49,7 @@ import java.util.List;
 import java.util.function.Function;
 import java.util.function.Supplier;
 import net.minecraft.core.RegistryAccess;
+import net.minecraft.core.component.DataComponentType;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MinecraftServer;
@@ -180,6 +182,7 @@ public class PaperConfigurations extends Configurations<GlobalConfiguration, Wor
             .register(Duration.SERIALIZER)
             .register(DurationOrDisabled.SERIALIZER)
             .register(NbtPathSerializer.SERIALIZER)
+            .register(ResourceLocationSerializer.INSTANCE)
         );
     }
 
@@ -193,16 +196,17 @@ public class PaperConfigurations extends Configurations<GlobalConfiguration, Wor
     }
 
     @Override
-    protected YamlConfigurationLoader.Builder createGlobalLoaderBuilder() {
-        return super.createGlobalLoaderBuilder()
-            .defaultOptions(PaperConfigurations::defaultGlobalOptions);
+    protected YamlConfigurationLoader.Builder createGlobalLoaderBuilder(RegistryAccess registryAccess) {
+        return super.createGlobalLoaderBuilder(registryAccess)
+            .defaultOptions((options) -> defaultGlobalOptions(registryAccess, options));
     }
 
-    private static ConfigurationOptions defaultGlobalOptions(ConfigurationOptions options) {
+    private static ConfigurationOptions defaultGlobalOptions(RegistryAccess registryAccess, ConfigurationOptions options) {
         return options
             .header(GLOBAL_HEADER)
             .serializers(builder -> builder
                 .register(new PacketClassSerializer())
+                .register(new RegistryValueSerializer<>(new TypeToken<DataComponentType<?>>() {}, registryAccess, Registries.DATA_COMPONENT_TYPE, false))
             );
     }
 
@@ -316,7 +320,7 @@ public class PaperConfigurations extends Configurations<GlobalConfiguration, Wor
 
     public void reloadConfigs(MinecraftServer server) {
         try {
-            this.initializeGlobalConfiguration(reloader(this.globalConfigClass, GlobalConfiguration.get()));
+            this.initializeGlobalConfiguration(server.registryAccess(), reloader(this.globalConfigClass, GlobalConfiguration.get()));
             this.initializeWorldDefaultsConfiguration(server.registryAccess());
             for (ServerLevel level : server.getAllLevels()) {
                 this.createWorldConfig(createWorldContextMap(level), reloader(this.worldConfigClass, level.paperConfig()));
@@ -327,7 +331,7 @@ public class PaperConfigurations extends Configurations<GlobalConfiguration, Wor
     }
 
     private static ContextMap createWorldContextMap(ServerLevel level) {
-        return createWorldContextMap(level.convertable.levelDirectory.path(), level.serverLevelData.getLevelName(), level.dimension().location(), level.spigotConfig, level.registryAccess(), level.getGameRules());
+        return createWorldContextMap(level.levelStorageAccess.levelDirectory.path(), level.serverLevelData.getLevelName(), level.dimension().location(), level.spigotConfig, level.registryAccess(), level.getGameRules());
     }
 
     public static ContextMap createWorldContextMap(final Path dir, final String levelName, final ResourceLocation worldKey, final SpigotWorldConfig spigotConfig, final RegistryAccess registryAccess, final GameRules gameRules) {
@@ -454,9 +458,9 @@ public class PaperConfigurations extends Configurations<GlobalConfiguration, Wor
     }
 
     @VisibleForTesting
-    static ConfigurationNode createForTesting() {
+    static ConfigurationNode createForTesting(RegistryAccess registryAccess) {
         ObjectMapper.Factory factory = defaultGlobalFactoryBuilder(ObjectMapper.factoryBuilder()).build();
-        ConfigurationOptions options = defaultGlobalOptions(defaultOptions(ConfigurationOptions.defaults()))
+        ConfigurationOptions options = defaultGlobalOptions(registryAccess, defaultOptions(ConfigurationOptions.defaults()))
             .serializers(builder -> builder.register(type -> ConfigurationPart.class.isAssignableFrom(erase(type)), factory.asTypeSerializer()));
         return BasicConfigurationNode.root(options);
     }
diff --git a/src/main/java/io/papermc/paper/configuration/RemovedConfigurations.java b/src/main/java/io/papermc/paper/configuration/RemovedConfigurations.java
index f9a4bb664409a6c691c4dc901afe0bde75813636..8b9ff804237f87cf4bc4d6eb0c7629c52a1b7e97 100644
--- a/src/main/java/io/papermc/paper/configuration/RemovedConfigurations.java
+++ b/src/main/java/io/papermc/paper/configuration/RemovedConfigurations.java
@@ -53,7 +53,8 @@ interface RemovedConfigurations {
         path("entities", "spawning", "despawn-ranges", "hard"),
         path("fixes", "fix-curing-zombie-villager-discount-exploit"),
         path("entities", "mob-effects", "undead-immune-to-certain-effects"),
-        path("entities", "entities-target-with-follow-range")
+        path("entities", "entities-target-with-follow-range"),
+        path("environment", "disable-teleportation-suffocation-check")
     };
     // spawn.keep-spawn-loaded and spawn.keep-spawn-loaded-range are no longer used, but kept
     // in the world default config for compatibility with old worlds being migrated to use the gamerule
@@ -78,7 +79,8 @@ interface RemovedConfigurations {
         path("warnWhenSettingExcessiveVelocity"),
         path("logging", "use-rgb-for-named-text-colors"),
         path("unsupported-settings", "allow-grindstone-overstacking"),
-        path("unsupported-settings", "allow-tripwire-disarming-exploits")
+        path("unsupported-settings", "allow-tripwire-disarming-exploits"),
+        path("commands", "fix-target-selector-tag-completion"),
     };
 
 }
diff --git a/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java b/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
index b1c917d65076a3805e5b78cb946753f0c101e214..d7c9acaffdcff5e35e026ae90a3e521bab13b074 100644
--- a/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
@@ -88,17 +88,6 @@ public class WorldConfiguration extends ConfigurationPart {
 
     public class Anticheat extends ConfigurationPart {
 
-        public Obfuscation obfuscation;
-
-        public class Obfuscation extends ConfigurationPart {
-            public Items items = new Items();
-            public class Items extends ConfigurationPart {
-                public boolean hideItemmeta = false;
-                public boolean hideDurability = false;
-                public boolean hideItemmetaWithVisualEffects = false;
-            }
-        }
-
         public AntiXray antiXray;
 
         public class AntiXray extends ConfigurationPart {
@@ -445,7 +434,6 @@ public class WorldConfiguration extends ConfigurationPart {
         public int portalSearchRadius = 128;
         public int portalCreateRadius = 16;
         public boolean portalSearchVanillaDimensionScaling = true;
-        public boolean disableTeleportationSuffocationCheck = false;
         public IntOr.Disabled netherCeilingVoidDamageHeight = IntOr.Disabled.DISABLED;
         public int maxFluidTicks = 65536;
         public int maxBlockTicks = 65536;
diff --git a/src/main/java/io/papermc/paper/configuration/serializer/ResourceLocationSerializer.java b/src/main/java/io/papermc/paper/configuration/serializer/ResourceLocationSerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..4bb82632260dc21e37b020ac87f29d7a89279e95
--- /dev/null
+++ b/src/main/java/io/papermc/paper/configuration/serializer/ResourceLocationSerializer.java
@@ -0,0 +1,26 @@
+package io.papermc.paper.configuration.serializer;
+
+import java.lang.reflect.Type;
+import java.util.function.Predicate;
+import net.minecraft.resources.ResourceLocation;
+import org.spongepowered.configurate.serialize.ScalarSerializer;
+import org.spongepowered.configurate.serialize.SerializationException;
+
+public class ResourceLocationSerializer extends ScalarSerializer<ResourceLocation> {
+
+    public static final ScalarSerializer<ResourceLocation> INSTANCE = new ResourceLocationSerializer();
+
+    private ResourceLocationSerializer() {
+        super(ResourceLocation.class);
+    }
+
+    @Override
+    public ResourceLocation deserialize(final Type type, final Object obj) throws SerializationException {
+        return ResourceLocation.read(obj.toString()).getOrThrow(s -> new SerializationException(ResourceLocation.class, s));
+    }
+
+    @Override
+    protected Object serialize(final ResourceLocation item, final Predicate<Class<?>> typeSupported) {
+        return item.toString();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/datacomponent/PaperDataComponentType.java b/src/main/java/io/papermc/paper/datacomponent/PaperDataComponentType.java
index e2fcf870b2256e3df90372c3208f3ed27469b16e..7ec9b765f0aaea054c0755500ed339e7c73c3d59 100644
--- a/src/main/java/io/papermc/paper/datacomponent/PaperDataComponentType.java
+++ b/src/main/java/io/papermc/paper/datacomponent/PaperDataComponentType.java
@@ -7,7 +7,6 @@ import net.minecraft.core.component.DataComponentMap;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.core.registries.Registries;
 import org.bukkit.NamespacedKey;
-import org.bukkit.Registry;
 import org.bukkit.craftbukkit.CraftRegistry;
 import org.bukkit.craftbukkit.util.Handleable;
 import org.jspecify.annotations.Nullable;
@@ -23,7 +22,7 @@ public abstract class PaperDataComponentType<T, NMS> implements DataComponentTyp
     }
 
     public static DataComponentType minecraftToBukkit(final net.minecraft.core.component.DataComponentType<?> type) {
-        return CraftRegistry.minecraftToBukkit(type, Registries.DATA_COMPONENT_TYPE, Registry.DATA_COMPONENT_TYPE);
+        return CraftRegistry.minecraftToBukkit(type, Registries.DATA_COMPONENT_TYPE);
     }
 
     public static Set<DataComponentType> minecraftToBukkit(final Set<net.minecraft.core.component.DataComponentType<?>> nmsTypes) {
diff --git a/src/main/java/io/papermc/paper/datacomponent/item/PaperBannerPatternLayers.java b/src/main/java/io/papermc/paper/datacomponent/item/PaperBannerPatternLayers.java
index ca49c2d2e1edcf6c4f7a5ca6c9ba96920aa385f4..9963cbf9f70caa4da44c83d05ea8432ad6366285 100644
--- a/src/main/java/io/papermc/paper/datacomponent/item/PaperBannerPatternLayers.java
+++ b/src/main/java/io/papermc/paper/datacomponent/item/PaperBannerPatternLayers.java
@@ -1,6 +1,5 @@
 package io.papermc.paper.datacomponent.item;
 
-import io.papermc.paper.registry.RegistryAccess;
 import io.papermc.paper.registry.RegistryKey;
 import io.papermc.paper.util.MCUtil;
 import java.util.List;
@@ -20,7 +19,7 @@ public record PaperBannerPatternLayers(
 
     private static List<Pattern> convert(final net.minecraft.world.level.block.entity.BannerPatternLayers nmsPatterns) {
         return MCUtil.transformUnmodifiable(nmsPatterns.layers(), input -> {
-            final Optional<PatternType> type = CraftRegistry.unwrapAndConvertHolder(RegistryAccess.registryAccess().getRegistry(RegistryKey.BANNER_PATTERN), input.pattern());
+            final Optional<PatternType> type = CraftRegistry.unwrapAndConvertHolder(RegistryKey.BANNER_PATTERN, input.pattern());
             return new Pattern(Objects.requireNonNull(DyeColor.getByWoolData((byte) input.color().getId())), type.orElseThrow(() -> new IllegalStateException("Inlined banner patterns are not supported yet in the API!")));
         });
     }
diff --git a/src/main/java/io/papermc/paper/datapack/PaperDatapack.java b/src/main/java/io/papermc/paper/datapack/PaperDatapack.java
index 8bd8263b51fb2bb364353565b1ba26b3b0d1d55e..bbd709529c58d8b690f56c6f523008d7a04bfbcd 100644
--- a/src/main/java/io/papermc/paper/datapack/PaperDatapack.java
+++ b/src/main/java/io/papermc/paper/datapack/PaperDatapack.java
@@ -2,71 +2,25 @@ package io.papermc.paper.datapack;
 
 import io.papermc.paper.adventure.PaperAdventure;
 import io.papermc.paper.event.server.ServerResourcesReloadedEvent;
-import io.papermc.paper.world.flag.PaperFeatureFlagProviderImpl;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
 import net.kyori.adventure.text.Component;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.packs.repository.Pack;
-import net.minecraft.server.packs.repository.PackSource;
-import org.bukkit.FeatureFlag;
-import org.checkerframework.checker.nullness.qual.NonNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
-import org.checkerframework.framework.qual.DefaultQualifier;
+import org.jspecify.annotations.NullMarked;
 
-@DefaultQualifier(NonNull.class)
-public class PaperDatapack implements Datapack {
-
-    private static final Map<PackSource, DatapackSource> PACK_SOURCES = new ConcurrentHashMap<>();
-    static {
-        PACK_SOURCES.put(PackSource.DEFAULT, DatapackSource.DEFAULT);
-        PACK_SOURCES.put(PackSource.BUILT_IN, DatapackSource.BUILT_IN);
-        PACK_SOURCES.put(PackSource.FEATURE, DatapackSource.FEATURE);
-        PACK_SOURCES.put(PackSource.WORLD, DatapackSource.WORLD);
-        PACK_SOURCES.put(PackSource.SERVER, DatapackSource.SERVER);
-    }
+@NullMarked
+public class PaperDatapack extends PaperDiscoveredDatapack implements Datapack {
 
     private final Pack pack;
     private final boolean enabled;
 
     PaperDatapack(final Pack pack, final boolean enabled) {
+        super(pack);
         this.pack = pack;
         this.enabled = enabled;
     }
 
-    @Override
-    public String getName() {
-        return this.pack.getId();
-    }
-
-    @Override
-    public Component getTitle() {
-        return PaperAdventure.asAdventure(this.pack.getTitle());
-    }
-
-    @Override
-    public Component getDescription() {
-        return PaperAdventure.asAdventure(this.pack.getDescription());
-    }
-
-    @Override
-    public boolean isRequired() {
-        return this.pack.isRequired();
-    }
-
-    @Override
-    public Compatibility getCompatibility() {
-        return Datapack.Compatibility.valueOf(this.pack.getCompatibility().name());
-    }
-
-    @Override
-    public Set<FeatureFlag> getRequiredFeatures() {
-        return PaperFeatureFlagProviderImpl.fromNms(this.pack.getRequestedFeatures());
-    }
-
     @Override
     public boolean isEnabled() {
         return this.enabled;
@@ -76,7 +30,7 @@ public class PaperDatapack implements Datapack {
     public void setEnabled(final boolean enabled) {
         final MinecraftServer server = MinecraftServer.getServer();
         final List<Pack> enabledPacks = new ArrayList<>(server.getPackRepository().getSelectedPacks());
-        final @Nullable Pack packToChange = server.getPackRepository().getPack(this.getName());
+        final Pack packToChange = server.getPackRepository().getPack(this.getName());
         if (packToChange == null) {
             throw new IllegalStateException("Cannot toggle state of pack that doesn't exist: " + this.getName());
         }
@@ -91,11 +45,6 @@ public class PaperDatapack implements Datapack {
         server.reloadResources(enabledPacks.stream().map(Pack::getId).toList(), ServerResourcesReloadedEvent.Cause.PLUGIN);
     }
 
-    @Override
-    public DatapackSource getSource() {
-        return PACK_SOURCES.computeIfAbsent(this.pack.location().source(), source -> new DatapackSourceImpl(source.toString()));
-    }
-
     @Override
     public Component computeDisplayName() {
         return PaperAdventure.asAdventure(this.pack.getChatLink(this.enabled));
diff --git a/src/main/java/io/papermc/paper/datapack/PaperDatapackRegistrar.java b/src/main/java/io/papermc/paper/datapack/PaperDatapackRegistrar.java
new file mode 100644
index 0000000000000000000000000000000000000000..f5479c8b268b2bd2c0ebc6ae46224800d4be0b7b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/datapack/PaperDatapackRegistrar.java
@@ -0,0 +1,167 @@
+package io.papermc.paper.datapack;
+
+import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableMap;
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.adventure.PaperAdventure;
+import io.papermc.paper.plugin.bootstrap.BootstrapContext;
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.lifecycle.event.registrar.PaperRegistrar;
+import java.io.IOException;
+import java.net.URI;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Optional;
+import java.util.function.Consumer;
+import net.kyori.adventure.text.Component;
+import net.minecraft.server.packs.PackLocationInfo;
+import net.minecraft.server.packs.PackSelectionConfig;
+import net.minecraft.server.packs.PackType;
+import net.minecraft.server.packs.VanillaPackResourcesBuilder;
+import net.minecraft.server.packs.repository.FolderRepositorySource;
+import net.minecraft.server.packs.repository.Pack;
+import net.minecraft.server.packs.repository.PackDetector;
+import net.minecraft.world.level.validation.ContentValidationException;
+import net.minecraft.world.level.validation.DirectoryValidator;
+import net.minecraft.world.level.validation.ForbiddenSymlinkInfo;
+import org.jetbrains.annotations.Unmodifiable;
+import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.Nullable;
+import org.slf4j.Logger;
+
+@NullMarked
+public class PaperDatapackRegistrar implements PaperRegistrar<BootstrapContext>, DatapackRegistrar {
+
+    private static final Logger LOGGER = LogUtils.getClassLogger();
+
+    private final PackDetector<Pack.ResourcesSupplier> detector;
+    public final Map<String, Pack> discoveredPacks;
+    private @Nullable BootstrapContext owner;
+
+    public PaperDatapackRegistrar(final DirectoryValidator symlinkValidator, final Map<String, Pack> discoveredPacks) {
+        this.detector = new FolderRepositorySource.FolderPackDetector(symlinkValidator);
+        this.discoveredPacks = discoveredPacks;
+    }
+
+    @Override
+    public void setCurrentContext(final @Nullable BootstrapContext owner) {
+        this.owner = owner;
+    }
+
+    @Override
+    public boolean hasPackDiscovered(final String name) {
+        return this.discoveredPacks.containsKey(name);
+    }
+
+    @Override
+    public DiscoveredDatapack getDiscoveredPack(final String name) {
+        if (!this.hasPackDiscovered(name)) {
+            throw new NoSuchElementException("No pack with id " + name + " was discovered");
+        }
+        return new PaperDiscoveredDatapack(this.discoveredPacks.get(name));
+    }
+
+    @Override
+    public boolean removeDiscoveredPack(final String name) {
+        return this.discoveredPacks.remove(name) != null;
+    }
+
+    @Override
+    public @Unmodifiable Map<String, DiscoveredDatapack> getDiscoveredPacks() {
+        final ImmutableMap.Builder<String, DiscoveredDatapack> builder = ImmutableMap.builderWithExpectedSize(this.discoveredPacks.size());
+        for (final Map.Entry<String, Pack> entry : this.discoveredPacks.entrySet()) {
+            builder.put(entry.getKey(), new PaperDiscoveredDatapack(entry.getValue()));
+        }
+        return builder.buildOrThrow();
+    }
+
+    @Override
+    public @Nullable DiscoveredDatapack discoverPack(final URI uri, final String id, final Consumer<Configurer> configurer) throws IOException {
+        Preconditions.checkState(this.owner != null, "Discovering packs is not supported outside of lifecycle events");
+        return this.discoverPack(this.owner.getPluginMeta(), uri, id, configurer);
+    }
+
+    @Override
+    public @Nullable DiscoveredDatapack discoverPack(final Path path, final String id, final Consumer<Configurer> configurer) throws IOException {
+        Preconditions.checkState(this.owner != null, "Discovering packs is not supported outside of lifecycle events");
+        return this.discoverPack(this.owner.getPluginMeta(), path, id, configurer);
+    }
+
+    @Override
+    public @Nullable DiscoveredDatapack discoverPack(final PluginMeta pluginMeta, final URI uri, final String id, final Consumer<Configurer> configurer) throws IOException {
+        return this.discoverPack(pluginMeta, VanillaPackResourcesBuilder.safeGetPath(uri), id, configurer);
+    }
+
+    @Override
+    public @Nullable DiscoveredDatapack discoverPack(final PluginMeta pluginMeta, final Path path, final String id, final Consumer<Configurer> configurer) throws IOException {
+        Preconditions.checkState(this.owner != null, "Discovering packs is not supported outside of lifecycle events");
+        final List<ForbiddenSymlinkInfo> badLinks = new ArrayList<>();
+        final Pack.ResourcesSupplier resourcesSupplier = this.detector.detectPackResources(path, badLinks);
+        if (!badLinks.isEmpty()) {
+            LOGGER.warn("Ignoring potential pack entry: {}", ContentValidationException.getMessage(path, badLinks));
+            return null;
+        } else if (resourcesSupplier != null) {
+            final String packId = pluginMeta.getName() + "/" + id;
+            final ConfigurerImpl configurerImpl = new ConfigurerImpl(Component.text(packId));
+            configurer.accept(configurerImpl);
+            final PackLocationInfo locInfo = new PackLocationInfo(packId,
+                PaperAdventure.asVanilla(configurerImpl.title),
+                PluginPackSource.INSTANCE,
+                Optional.empty()
+            );
+            final Pack pack = Pack.readMetaAndCreate(locInfo,
+                resourcesSupplier,
+                PackType.SERVER_DATA,
+                new PackSelectionConfig(
+                    configurerImpl.autoEnableOnServerStart,
+                    configurerImpl.position,
+                    configurerImpl.fixedPosition
+                ));
+            if (pack != null) {
+                this.discoveredPacks.put(packId, pack);
+                return new PaperDiscoveredDatapack(pack);
+            }
+            return null;
+        } else {
+            LOGGER.info("Found non-pack entry '{}', ignoring", path);
+            return null;
+        }
+    }
+
+    static final class ConfigurerImpl implements Configurer {
+
+        private Component title;
+        private boolean autoEnableOnServerStart = false;
+        private boolean fixedPosition = false;
+        private Pack.Position position = Pack.Position.TOP;
+
+        ConfigurerImpl(final Component title) {
+            this.title = title;
+        }
+
+        @Override
+        public Configurer title(final Component title) {
+            this.title = title;
+            return this;
+        }
+
+        @Override
+        public Configurer autoEnableOnServerStart(final boolean autoEnableOnServerStart) {
+            this.autoEnableOnServerStart = autoEnableOnServerStart;
+            return this;
+        }
+
+        @Override
+        public Configurer position(final boolean fixed, final Datapack.Position position) {
+            this.fixedPosition = fixed;
+            this.position = switch (position) {
+                case TOP -> Pack.Position.TOP;
+                case BOTTOM -> Pack.Position.BOTTOM;
+            };
+            return this;
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/datapack/PaperDiscoveredDatapack.java b/src/main/java/io/papermc/paper/datapack/PaperDiscoveredDatapack.java
new file mode 100644
index 0000000000000000000000000000000000000000..acb0701aa2c38cd23cc1bb3154c953bc1554fcb1
--- /dev/null
+++ b/src/main/java/io/papermc/paper/datapack/PaperDiscoveredDatapack.java
@@ -0,0 +1,69 @@
+package io.papermc.paper.datapack;
+
+import com.google.common.collect.ImmutableMap;
+import io.papermc.paper.adventure.PaperAdventure;
+import io.papermc.paper.world.flag.PaperFeatureFlagProviderImpl;
+import java.util.Map;
+import java.util.Set;
+import net.kyori.adventure.text.Component;
+import net.minecraft.server.packs.repository.Pack;
+import net.minecraft.server.packs.repository.PackSource;
+import org.bukkit.FeatureFlag;
+import org.jspecify.annotations.NullMarked;
+
+@NullMarked
+public class PaperDiscoveredDatapack implements DiscoveredDatapack {
+
+    private static final Map<PackSource, DatapackSource> PACK_SOURCES;
+    static {
+        PACK_SOURCES = ImmutableMap.<PackSource, DatapackSource>builder()
+            .put(PackSource.DEFAULT, DatapackSource.DEFAULT)
+            .put(PackSource.BUILT_IN, DatapackSource.BUILT_IN)
+            .put(PackSource.FEATURE, DatapackSource.FEATURE)
+            .put(PackSource.WORLD, DatapackSource.WORLD)
+            .put(PackSource.SERVER, DatapackSource.SERVER)
+            .put(PluginPackSource.INSTANCE, DatapackSource.PLUGIN)
+            .buildOrThrow();
+    }
+
+    private final Pack pack;
+
+    PaperDiscoveredDatapack(final Pack pack) {
+        this.pack = pack;
+    }
+
+    @Override
+    public String getName() {
+        return this.pack.getId();
+    }
+
+    @Override
+    public Component getTitle() {
+        return PaperAdventure.asAdventure(this.pack.getTitle());
+    }
+
+    @Override
+    public Component getDescription() {
+        return PaperAdventure.asAdventure(this.pack.getDescription());
+    }
+
+    @Override
+    public boolean isRequired() {
+        return this.pack.isRequired();
+    }
+
+    @Override
+    public Datapack.Compatibility getCompatibility() {
+        return Datapack.Compatibility.valueOf(this.pack.getCompatibility().name());
+    }
+
+    @Override
+    public Set<FeatureFlag> getRequiredFeatures() {
+        return PaperFeatureFlagProviderImpl.fromNms(this.pack.getRequestedFeatures());
+    }
+
+    @Override
+    public DatapackSource getSource() {
+        return PACK_SOURCES.get(this.pack.location().source());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/datapack/PluginPackSource.java b/src/main/java/io/papermc/paper/datapack/PluginPackSource.java
new file mode 100644
index 0000000000000000000000000000000000000000..79a92a2a4047613c87bfc382a80532152909a29a
--- /dev/null
+++ b/src/main/java/io/papermc/paper/datapack/PluginPackSource.java
@@ -0,0 +1,25 @@
+package io.papermc.paper.datapack;
+
+import net.minecraft.ChatFormatting;
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.packs.repository.PackSource;
+import org.jspecify.annotations.NullMarked;
+
+@NullMarked
+final class PluginPackSource implements PackSource {
+
+    static final PackSource INSTANCE = new PluginPackSource();
+
+    private PluginPackSource() {
+    }
+
+    @Override
+    public Component decorate(final Component packDisplayName) {
+        return Component.translatable("pack.nameAndSource", packDisplayName, "plugin").withStyle(ChatFormatting.GRAY);
+    }
+
+    @Override
+    public boolean shouldAddAutomatically() {
+        return true;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/entity/activation/ActivationType.java b/src/main/java/io/papermc/paper/entity/activation/ActivationType.java
new file mode 100644
index 0000000000000000000000000000000000000000..cd43845a0819b5b63259d7a87ebb1cf5659ea5bc
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/activation/ActivationType.java
@@ -0,0 +1,47 @@
+package io.papermc.paper.entity.activation;
+
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.FlyingMob;
+import net.minecraft.world.entity.PathfinderMob;
+import net.minecraft.world.entity.ambient.AmbientCreature;
+import net.minecraft.world.entity.animal.WaterAnimal;
+import net.minecraft.world.entity.monster.Enemy;
+import net.minecraft.world.entity.npc.Villager;
+import net.minecraft.world.entity.raid.Raider;
+import net.minecraft.world.phys.AABB;
+
+public enum ActivationType {
+    WATER,
+    FLYING_MONSTER,
+    VILLAGER,
+    MONSTER,
+    ANIMAL,
+    RAIDER,
+    MISC;
+
+    AABB boundingBox = new AABB(0, 0, 0, 0, 0, 0);
+
+    /**
+     * Returns the activation type for the given entity.
+     *
+     * @param entity entity to get the activation type for
+     * @return activation type
+     */
+    public static ActivationType activationTypeFor(final Entity entity) {
+        if (entity instanceof WaterAnimal) {
+            return ActivationType.WATER;
+        } else if (entity instanceof Villager) {
+            return ActivationType.VILLAGER;
+        } else if (entity instanceof FlyingMob && entity instanceof Enemy) {
+            return ActivationType.FLYING_MONSTER;
+        } else if (entity instanceof Raider) {
+            return ActivationType.RAIDER;
+        } else if (entity instanceof Enemy) {
+            return ActivationType.MONSTER;
+        } else if (entity instanceof PathfinderMob || entity instanceof AmbientCreature) {
+            return ActivationType.ANIMAL;
+        } else {
+            return ActivationType.MISC;
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/inventory/PaperInventoryCustomHolderContainer.java b/src/main/java/io/papermc/paper/inventory/PaperInventoryCustomHolderContainer.java
index 224d4b2cc45b0d02230a76caee9c88573a448b4c..f3ef3634970fb09580f0d567c1938a093924ae7d 100644
--- a/src/main/java/io/papermc/paper/inventory/PaperInventoryCustomHolderContainer.java
+++ b/src/main/java/io/papermc/paper/inventory/PaperInventoryCustomHolderContainer.java
@@ -105,13 +105,13 @@ public final class PaperInventoryCustomHolderContainer implements Container {
     }
 
     @Override
-    public void onOpen(CraftHumanEntity who) {
-        this.delegate.onOpen(who);
+    public void onOpen(CraftHumanEntity player) {
+        this.delegate.onOpen(player);
     }
 
     @Override
-    public void onClose(CraftHumanEntity who) {
-        this.delegate.onClose(who);
+    public void onClose(CraftHumanEntity player) {
+        this.delegate.onClose(player);
     }
 
     @Override
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/LaunchEntryPointHandler.java b/src/main/java/io/papermc/paper/plugin/entrypoint/LaunchEntryPointHandler.java
index 48bc745ca9632fc46b5f786ff570434702eb47f2..c75f72b470a926fef8deddcece97920c7da74913 100644
--- a/src/main/java/io/papermc/paper/plugin/entrypoint/LaunchEntryPointHandler.java
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/LaunchEntryPointHandler.java
@@ -6,10 +6,9 @@ import io.papermc.paper.plugin.storage.ProviderStorage;
 import io.papermc.paper.plugin.storage.ServerPluginProviderStorage;
 import it.unimi.dsi.fastutil.objects.Object2BooleanMap;
 import it.unimi.dsi.fastutil.objects.Object2BooleanOpenHashMap;
-import org.jetbrains.annotations.ApiStatus;
-
 import java.util.HashMap;
 import java.util.Map;
+import org.jetbrains.annotations.ApiStatus;
 
 /**
  * Used by the server to register/load plugin bootstrappers and plugins.
diff --git a/src/main/java/io/papermc/paper/plugin/provider/source/FileProviderSource.java b/src/main/java/io/papermc/paper/plugin/provider/source/FileProviderSource.java
index 48604e7f96adc9e226e034054c5e2bad0b024eb5..a0b84535a9d3833d4df692b85b272f145559dd80 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/source/FileProviderSource.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/source/FileProviderSource.java
@@ -9,7 +9,6 @@ import io.papermc.paper.plugin.provider.type.PluginFileType;
 import org.bukkit.plugin.InvalidPluginException;
 import org.jetbrains.annotations.Nullable;
 
-import java.io.File;
 import java.io.IOException;
 import java.nio.file.FileVisitResult;
 import java.nio.file.FileVisitor;
@@ -99,7 +98,7 @@ public class FileProviderSource implements ProviderSource<Path, Path> {
     /**
      * Replaces a plugin with a plugin of the same plugin name in the update folder.
      *
-     * @param file
+     * @param file The plugin jar file to look for updates for.
      */
     private Path checkUpdate(Path file) throws InvalidPluginException {
         PluginInitializerManager pluginSystem = PluginInitializerManager.instance();
@@ -121,11 +120,22 @@ public class FileProviderSource implements ProviderSource<Path, Path> {
                     throw new RuntimeException("Could not copy '" + updateLocation + "' to '" + file + "' in update plugin process", exception);
                 }
 
-                // Idk what this is about, TODO
-                File newName = new File(file.toFile().getParentFile(), updateLocation.toFile().getName());
-                file.toFile().renameTo(newName);
-                updateLocation.toFile().delete();
-                return newName.toPath();
+                // Rename the plugin file to the update file's name.
+                final Path renamedFile = file.resolveSibling(updateLocation.getFileName());
+                try {
+                    Files.move(file, renamedFile, StandardCopyOption.REPLACE_EXISTING);
+                } catch (IOException exception) {
+                    throw new RuntimeException("Could not rename '" + file + "' to '" + renamedFile + "' in update plugin process", exception);
+                }
+
+                // Delete the file from the update folder now that it's copied over successfully
+                try {
+                    Files.delete(updateLocation);
+                } catch (IOException exception) {
+                    throw new RuntimeException("Could not delete '" + updateLocation + "' from update folder in update plugin process", exception);
+                }
+
+                return renamedFile;
             }
         } catch (Exception e) {
             throw new InvalidPluginException(e);
diff --git a/src/main/java/io/papermc/paper/registry/PaperRegistries.java b/src/main/java/io/papermc/paper/registry/PaperRegistries.java
index 3ebc3dbc86f3f448f0c555366b55a77876ef5d6f..c0b17315a32bd68917abc991b2811b6ad51ff963 100644
--- a/src/main/java/io/papermc/paper/registry/PaperRegistries.java
+++ b/src/main/java/io/papermc/paper/registry/PaperRegistries.java
@@ -4,10 +4,13 @@ import com.google.common.base.Preconditions;
 import io.papermc.paper.adventure.PaperAdventure;
 import io.papermc.paper.datacomponent.DataComponentTypes;
 import io.papermc.paper.datacomponent.PaperDataComponentType;
+import io.papermc.paper.registry.data.PaperBannerPatternRegistryEntry;
+import io.papermc.paper.registry.data.PaperDamageTypeRegistryEntry;
 import io.papermc.paper.registry.data.PaperEnchantmentRegistryEntry;
 import io.papermc.paper.registry.data.PaperGameEventRegistryEntry;
 import io.papermc.paper.registry.data.PaperPaintingVariantRegistryEntry;
 import io.papermc.paper.registry.entry.RegistryEntry;
+import io.papermc.paper.registry.entry.RegistryEntryMeta;
 import io.papermc.paper.registry.tag.TagKey;
 import java.util.Collections;
 import java.util.IdentityHashMap;
@@ -94,21 +97,21 @@ public final class PaperRegistries {
             start(Registries.MENU, RegistryKey.MENU).craft(MenuType.class, CraftMenuType::new).build(),
             start(Registries.ATTRIBUTE, RegistryKey.ATTRIBUTE).craft(Attribute.class, CraftAttribute::new).build(),
             start(Registries.FLUID, RegistryKey.FLUID).craft(Fluid.class, CraftFluid::new).build(),
-            start(Registries.SOUND_EVENT, RegistryKey.SOUND_EVENT).craft(Sound.class, CraftSound::new).build(),
+            start(Registries.SOUND_EVENT, RegistryKey.SOUND_EVENT).craft(Sound.class, CraftSound::new, true).build(),
             start(Registries.DATA_COMPONENT_TYPE, RegistryKey.DATA_COMPONENT_TYPE).craft(DataComponentTypes.class, PaperDataComponentType::of).build(),
 
             // data-drivens
             start(Registries.BIOME, RegistryKey.BIOME).craft(Biome.class, CraftBiome::new).build().delayed(),
             start(Registries.STRUCTURE, RegistryKey.STRUCTURE).craft(Structure.class, CraftStructure::new).build().delayed(),
-            start(Registries.TRIM_MATERIAL, RegistryKey.TRIM_MATERIAL).craft(TrimMaterial.class, CraftTrimMaterial::new).build().delayed(),
-            start(Registries.TRIM_PATTERN, RegistryKey.TRIM_PATTERN).craft(TrimPattern.class, CraftTrimPattern::new).build().delayed(),
-            start(Registries.DAMAGE_TYPE, RegistryKey.DAMAGE_TYPE).craft(DamageType.class, CraftDamageType::new).build().delayed(),
+            start(Registries.TRIM_MATERIAL, RegistryKey.TRIM_MATERIAL).craft(TrimMaterial.class, CraftTrimMaterial::new, true).build().delayed(),
+            start(Registries.TRIM_PATTERN, RegistryKey.TRIM_PATTERN).craft(TrimPattern.class, CraftTrimPattern::new, true).build().delayed(),
+            start(Registries.DAMAGE_TYPE, RegistryKey.DAMAGE_TYPE).craft(DamageType.class, CraftDamageType::new).writable(PaperDamageTypeRegistryEntry.PaperBuilder::new).delayed(),
             start(Registries.WOLF_VARIANT, RegistryKey.WOLF_VARIANT).craft(Wolf.Variant.class, CraftWolf.CraftVariant::new).build().delayed(),
-            start(Registries.ENCHANTMENT, RegistryKey.ENCHANTMENT).craft(Enchantment.class, CraftEnchantment::new).writable(PaperEnchantmentRegistryEntry.PaperBuilder::new).withSerializationUpdater(FieldRename.ENCHANTMENT_RENAME).delayed(),
+            start(Registries.ENCHANTMENT, RegistryKey.ENCHANTMENT).craft(Enchantment.class, CraftEnchantment::new).serializationUpdater(FieldRename.ENCHANTMENT_RENAME).writable(PaperEnchantmentRegistryEntry.PaperBuilder::new).delayed(),
             start(Registries.JUKEBOX_SONG, RegistryKey.JUKEBOX_SONG).craft(JukeboxSong.class, CraftJukeboxSong::new).build().delayed(),
-            start(Registries.BANNER_PATTERN, RegistryKey.BANNER_PATTERN).craft(PatternType.class, CraftPatternType::new).build().delayed(),
-            start(Registries.PAINTING_VARIANT, RegistryKey.PAINTING_VARIANT).craft(Art.class, CraftArt::new).writable(PaperPaintingVariantRegistryEntry.PaperBuilder::new).delayed(),
-            start(Registries.INSTRUMENT, RegistryKey.INSTRUMENT).craft(MusicInstrument.class, CraftMusicInstrument::new).build().delayed(),
+            start(Registries.BANNER_PATTERN, RegistryKey.BANNER_PATTERN).craft(PatternType.class, CraftPatternType::new, true).writable(PaperBannerPatternRegistryEntry.PaperBuilder::new).delayed(),
+            start(Registries.PAINTING_VARIANT, RegistryKey.PAINTING_VARIANT).craft(Art.class, CraftArt::new, true).writable(PaperPaintingVariantRegistryEntry.PaperBuilder::new).delayed(),
+            start(Registries.INSTRUMENT, RegistryKey.INSTRUMENT).craft(MusicInstrument.class, CraftMusicInstrument::new, true).build().delayed(),
 
             // api-only
             start(Registries.ENTITY_TYPE, RegistryKey.ENTITY_TYPE).apiOnly(PaperSimpleRegistry::entityType),
@@ -136,6 +139,18 @@ public final class PaperRegistries {
         return (RegistryEntry<M, T>) BY_REGISTRY_KEY.get(registryKey);
     }
 
+    @SuppressWarnings("unchecked")
+    public static <M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> RegistryEntryMeta.Buildable<M, T, B> getBuildableMeta(final ResourceKey<? extends Registry<M>> resourceKey) {
+        final RegistryEntry<M, T> entry = getEntry(resourceKey);
+        if (entry == null) {
+            throw new IllegalArgumentException("No registry entry for " + resourceKey);
+        }
+        if (!(entry.meta() instanceof final RegistryEntryMeta.Buildable<M, T, ?> buildableMeta)) {
+            throw new IllegalArgumentException("Registry entry for " + resourceKey + " is not buildable");
+        }
+        return (RegistryEntryMeta.Buildable<M, T, B>) buildableMeta;
+    }
+
     @SuppressWarnings("unchecked")
     public static <M, T> RegistryKey<T> registryFromNms(final ResourceKey<? extends Registry<M>> registryResourceKey) {
         return (RegistryKey<T>) Objects.requireNonNull(BY_RESOURCE_KEY.get(registryResourceKey), registryResourceKey + " doesn't have an api RegistryKey").apiKey();
diff --git a/src/main/java/io/papermc/paper/registry/PaperRegistryAccess.java b/src/main/java/io/papermc/paper/registry/PaperRegistryAccess.java
index ed071ed34e16812f133102b0d66a5201a94639f2..e96c28cecc9b371be3d4c1eb183743a7c6375ac8 100644
--- a/src/main/java/io/papermc/paper/registry/PaperRegistryAccess.java
+++ b/src/main/java/io/papermc/paper/registry/PaperRegistryAccess.java
@@ -1,7 +1,7 @@
 package io.papermc.paper.registry;
 
-import io.papermc.paper.registry.entry.ApiRegistryEntry;
 import io.papermc.paper.registry.entry.RegistryEntry;
+import io.papermc.paper.registry.entry.RegistryEntryMeta;
 import io.papermc.paper.registry.legacy.DelayedRegistry;
 import io.papermc.paper.registry.legacy.DelayedRegistryEntry;
 import io.papermc.paper.registry.legacy.LegacyRegistryIdentifiers;
@@ -13,6 +13,7 @@ import java.util.stream.Collectors;
 import net.minecraft.resources.ResourceKey;
 import org.bukkit.Keyed;
 import org.bukkit.Registry;
+import org.bukkit.craftbukkit.CraftRegistry;
 import org.jetbrains.annotations.VisibleForTesting;
 import org.jspecify.annotations.Nullable;
 
@@ -31,7 +32,10 @@ public class PaperRegistryAccess implements RegistryAccess {
 
     @VisibleForTesting
     public Set<RegistryKey<?>> getLoadedServerBackedRegistries() {
-        return this.registries.keySet().stream().filter(registryHolder -> !(PaperRegistries.getEntry(registryHolder) instanceof ApiRegistryEntry)).collect(Collectors.toUnmodifiableSet());
+        return this.registries.keySet().stream().filter(registryHolder -> {
+            final RegistryEntry<?, ?> entry = PaperRegistries.getEntry(registryHolder);
+            return entry != null && !(entry.meta() instanceof RegistryEntryMeta.ApiOnly<?,?>);
+        }).collect(Collectors.toUnmodifiableSet());
     }
 
     @SuppressWarnings("unchecked")
@@ -69,7 +73,7 @@ public class PaperRegistryAccess implements RegistryAccess {
         if (PaperRegistries.getEntry(key) == null) {
             throw new NoSuchElementException(key + " is not a valid registry key");
         }
-        final @Nullable RegistryHolder<T> registryHolder = (RegistryHolder<T>) this.registries.get(key);
+        final RegistryHolder<T> registryHolder = (RegistryHolder<T>) this.registries.get(key);
         if (registryHolder == null) {
             throw new IllegalArgumentException(key + " points to a registry that is not available yet");
         }
@@ -101,13 +105,22 @@ public class PaperRegistryAccess implements RegistryAccess {
         this.registerRegistry(resourceKey, registry, false);
     }
 
+    public <M> void lockReferenceHolders(final ResourceKey<? extends net.minecraft.core.Registry<M>> resourceKey) {
+        final RegistryEntry<M, Keyed> entry = PaperRegistries.getEntry(resourceKey);
+        if (entry == null || !(entry.meta() instanceof final RegistryEntryMeta.ServerSide<M, Keyed> serverSide) || !serverSide.registryTypeMapper().constructorUsesHolder()) {
+            return;
+        }
+        final CraftRegistry<?, M> registry = (CraftRegistry<?, M>) this.getRegistry(entry.apiKey());
+        registry.lockReferenceHolders();
+    }
+
     @SuppressWarnings("unchecked") // this method should be called right after any new MappedRegistry instances are created to later be used by the server.
     private <M, B extends Keyed, R extends Registry<B>> void registerRegistry(final ResourceKey<? extends net.minecraft.core.Registry<M>> resourceKey, final net.minecraft.core.Registry<M> registry, final boolean replace) {
-        final @Nullable RegistryEntry<M, B> entry = PaperRegistries.getEntry(resourceKey);
+        final RegistryEntry<M, B> entry = PaperRegistries.getEntry(resourceKey);
         if (entry == null) { // skip registries that don't have API entries
             return;
         }
-        final @Nullable RegistryHolder<B> registryHolder = (RegistryHolder<B>) this.registries.get(entry.apiKey());
+        final RegistryHolder<B> registryHolder = (RegistryHolder<B>) this.registries.get(entry.apiKey());
         if (registryHolder == null || replace) {
             // if the holder doesn't exist yet, or is marked as "replaceable", put it in the map.
             this.registries.put(entry.apiKey(), entry.createRegistryHolder(registry));
diff --git a/src/main/java/io/papermc/paper/registry/PaperRegistryBuilder.java b/src/main/java/io/papermc/paper/registry/PaperRegistryBuilder.java
index 6a60d7b7edeedb150afea41d58855b2d8521f297..a3cb9a4209debcccbd8e3ed1e798df13bcf2dcd2 100644
--- a/src/main/java/io/papermc/paper/registry/PaperRegistryBuilder.java
+++ b/src/main/java/io/papermc/paper/registry/PaperRegistryBuilder.java
@@ -12,14 +12,8 @@ public interface PaperRegistryBuilder<M, T> extends RegistryBuilder<T> {
 
         B fill(Conversions conversions, @Nullable M nms);
 
-        default Factory<M, T, B> asFactory() {
-            return (lookup) -> this.fill(lookup, null);
+        default B create(final Conversions conversions) {
+            return this.fill(conversions, null);
         }
     }
-
-    @FunctionalInterface
-    interface Factory<M, T, B extends PaperRegistryBuilder<M, T>> {
-
-        B create(Conversions conversions);
-    }
 }
diff --git a/src/main/java/io/papermc/paper/registry/PaperRegistryBuilderFactory.java b/src/main/java/io/papermc/paper/registry/PaperRegistryBuilderFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..e83a6336bbd13a1722831cf2c541a017c088df17
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/PaperRegistryBuilderFactory.java
@@ -0,0 +1,51 @@
+package io.papermc.paper.registry;
+
+import io.papermc.paper.adventure.PaperAdventure;
+import io.papermc.paper.registry.data.util.Conversions;
+import java.util.function.Function;
+import net.minecraft.resources.ResourceLocation;
+import org.bukkit.Keyed;
+import org.jspecify.annotations.Nullable;
+
+public class PaperRegistryBuilderFactory<M, A extends Keyed, B extends PaperRegistryBuilder<M, A>> implements RegistryBuilderFactory<A, B> { // TODO remove Keyed
+
+    private final Conversions conversions;
+    private final PaperRegistryBuilder.Filler<M, A, B> builderFiller;
+    private final Function<? super ResourceLocation, ? extends @Nullable M> existingValueGetter;
+    private @Nullable B builder;
+
+    public PaperRegistryBuilderFactory(final Conversions conversions, final PaperRegistryBuilder.Filler<M, A, B> builderFiller, final Function<? super ResourceLocation, ? extends @Nullable M> existingValueGetter) {
+        this.conversions = conversions;
+        this.builderFiller = builderFiller;
+        this.existingValueGetter = existingValueGetter;
+    }
+
+    private void validate() {
+        if (this.builder != null) {
+            throw new IllegalStateException("Already created a builder");
+        }
+    }
+
+    public B requireBuilder() {
+        if (this.builder == null) {
+            throw new IllegalStateException("Builder not created yet");
+        }
+        return this.builder;
+    }
+
+    @Override
+    public B empty() {
+        this.validate();
+        return this.builder = this.builderFiller.create(this.conversions);
+    }
+
+    @Override
+    public B copyFrom(final TypedKey<A> key) {
+        this.validate();
+        final M existing = this.existingValueGetter.apply(PaperAdventure.asVanilla(key));
+        if (existing == null) {
+            throw new IllegalArgumentException("Key " + key + " doesn't exist");
+        }
+        return this.builder = this.builderFiller.fill(this.conversions, existing);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/PaperRegistryListenerManager.java b/src/main/java/io/papermc/paper/registry/PaperRegistryListenerManager.java
index 4f98c15d40e95031326d0524c51f2864ce52223e..540aaa09649cf5e9a3b1eed7c2b7ad71fa2e2ba9 100644
--- a/src/main/java/io/papermc/paper/registry/PaperRegistryListenerManager.java
+++ b/src/main/java/io/papermc/paper/registry/PaperRegistryListenerManager.java
@@ -9,7 +9,7 @@ import io.papermc.paper.plugin.lifecycle.event.LifecycleEventRunner;
 import io.papermc.paper.plugin.lifecycle.event.types.LifecycleEventType;
 import io.papermc.paper.registry.data.util.Conversions;
 import io.papermc.paper.registry.entry.RegistryEntry;
-import io.papermc.paper.registry.entry.RegistryEntryInfo;
+import io.papermc.paper.registry.entry.RegistryEntryMeta;
 import io.papermc.paper.registry.event.RegistryEntryAddEventImpl;
 import io.papermc.paper.registry.event.RegistryEventMap;
 import io.papermc.paper.registry.event.RegistryEventProvider;
@@ -28,6 +28,7 @@ import net.minecraft.core.WritableRegistry;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
+import org.bukkit.Keyed;
 import org.intellij.lang.annotations.Subst;
 import org.jspecify.annotations.Nullable;
 
@@ -86,8 +87,7 @@ public class PaperRegistryListenerManager {
         this.registerWithListeners(registry, key, nms, registrationInfo, WritableRegistry::register, conversions);
     }
 
-    // TODO remove Keyed
-    public <M, T extends org.bukkit.Keyed, B extends PaperRegistryBuilder<M, T>, R> R registerWithListeners(
+    public <M, T extends Keyed, B extends PaperRegistryBuilder<M, T>, R> R registerWithListeners( // TODO remove Keyed
         final Registry<M> registry,
         final ResourceKey<M> key,
         final M nms,
@@ -96,34 +96,33 @@ public class PaperRegistryListenerManager {
         final Conversions conversions
     ) {
         Preconditions.checkState(LaunchEntryPointHandler.INSTANCE.hasEntered(Entrypoint.BOOTSTRAPPER), registry.key() + " tried to run modification listeners before bootstrappers have been called"); // verify that bootstrappers have been called
-        final RegistryEntryInfo<M, T> entry = PaperRegistries.getEntry(registry.key());
-        if (!RegistryEntry.Modifiable.isModifiable(entry) || !this.valueAddEventTypes.hasHandlers(entry.apiKey())) {
+        final RegistryEntry<M, T> entry = PaperRegistries.getEntry(registry.key());
+        if (entry == null || !entry.meta().modificationApiSupport().canModify() || !this.valueAddEventTypes.hasHandlers(entry.apiKey())) {
             return registerMethod.register((WritableRegistry<M>) registry, key, nms, registrationInfo);
         }
-        final RegistryEntry.Modifiable<M, T, B> modifiableEntry = RegistryEntry.Modifiable.asModifiable(entry);
-        @SuppressWarnings("PatternValidation") final TypedKey<T> typedKey = TypedKey.create(entry.apiKey(), Key.key(key.location().getNamespace(), key.location().getPath()));
-        final B builder = modifiableEntry.fillBuilder(conversions, nms);
+        final RegistryEntryMeta.Buildable<M, T, B> modifiableEntry = (RegistryEntryMeta.Buildable<M, T, B>) entry.meta();
+        final B builder = modifiableEntry.builderFiller().fill(conversions, nms);
         return this.registerWithListeners(registry, modifiableEntry, key, nms, builder, registrationInfo, registerMethod, conversions);
     }
 
-    <M, T extends org.bukkit.Keyed, B extends PaperRegistryBuilder<M, T>> void registerWithListeners( // TODO remove Keyed
+    <M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> void registerWithListeners( // TODO remove Keyed
         final WritableRegistry<M> registry,
-        final RegistryEntryInfo<M, T> entry,
+        final RegistryEntryMeta.Buildable<M, T, B> entry,
         final ResourceKey<M> key,
         final B builder,
         final RegistrationInfo registrationInfo,
         final Conversions conversions
     ) {
-        if (!RegistryEntry.Modifiable.isModifiable(entry) || !this.valueAddEventTypes.hasHandlers(entry.apiKey())) {
+        if (!entry.modificationApiSupport().canModify() || !this.valueAddEventTypes.hasHandlers(entry.apiKey())) {
             registry.register(key, builder.build(), registrationInfo);
             return;
         }
-        this.registerWithListeners(registry, RegistryEntry.Modifiable.asModifiable(entry), key, null, builder, registrationInfo, WritableRegistry::register, conversions);
+        this.registerWithListeners(registry, entry, key, null, builder, registrationInfo, WritableRegistry::register, conversions);
     }
 
-    public <M, T extends org.bukkit.Keyed, B extends PaperRegistryBuilder<M, T>, R> R registerWithListeners( // TODO remove Keyed
+    public <M, T extends Keyed, B extends PaperRegistryBuilder<M, T>, R> R registerWithListeners( // TODO remove Keyed
         final Registry<M> registry,
-        final RegistryEntry.Modifiable<M, T, B> entry,
+        final RegistryEntryMeta.Buildable<M, T, B> entry,
         final ResourceKey<M> key,
         final @Nullable M oldNms,
         final B builder,
@@ -156,26 +155,28 @@ public class PaperRegistryListenerManager {
         R register(WritableRegistry<M> writableRegistry, ResourceKey<M> key, M value, RegistrationInfo registrationInfo);
     }
 
-    public <M, T extends org.bukkit.Keyed, B extends PaperRegistryBuilder<M, T>> void runFreezeListeners(final ResourceKey<? extends Registry<M>> resourceKey, final Conversions conversions) {
-        final RegistryEntryInfo<M, T> entry = PaperRegistries.getEntry(resourceKey);
-        if (!RegistryEntry.Addable.isAddable(entry) || !this.freezeEventTypes.hasHandlers(entry.apiKey())) {
+    public <M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> void runFreezeListeners(final ResourceKey<? extends Registry<M>> resourceKey, final Conversions conversions) {
+        final RegistryEntry<M, T> entry = PaperRegistries.getEntry(resourceKey);
+        if (entry == null || !entry.meta().modificationApiSupport().canAdd() || !this.freezeEventTypes.hasHandlers(entry.apiKey())) {
             return;
         }
-        final RegistryEntry.Addable<M, T, B> writableEntry = RegistryEntry.Addable.asAddable(entry);
+        final RegistryEntryMeta.Buildable<M, T, B> writableEntry = (RegistryEntryMeta.Buildable<M, T, B>) entry.meta();
         final WritableCraftRegistry<M, T, B> writableRegistry = PaperRegistryAccess.instance().getWritableRegistry(entry.apiKey());
         final RegistryFreezeEventImpl<T, B> event = writableEntry.createFreezeEvent(writableRegistry, conversions);
         LifecycleEventRunner.INSTANCE.callEvent(this.freezeEventTypes.getEventType(entry.apiKey()), event);
     }
 
     public <T, B extends RegistryBuilder<T>> RegistryEntryAddEventType<T, B> getRegistryValueAddEventType(final RegistryEventProvider<T, B> type) {
-        if (!RegistryEntry.Modifiable.isModifiable(PaperRegistries.getEntry(type.registryKey()))) {
+        final RegistryEntry<?, ?> entry = PaperRegistries.getEntry(type.registryKey());
+        if (entry == null || !entry.meta().modificationApiSupport().canModify()) {
             throw new IllegalArgumentException(type.registryKey() + " does not support RegistryEntryAddEvent");
         }
         return this.valueAddEventTypes.getOrCreate(type.registryKey(), RegistryEntryAddEventTypeImpl::new);
     }
 
     public <T, B extends RegistryBuilder<T>> LifecycleEventType.Prioritizable<BootstrapContext, RegistryFreezeEvent<T, B>> getRegistryFreezeEventType(final RegistryEventProvider<T, B> type) {
-        if (!RegistryEntry.Addable.isAddable(PaperRegistries.getEntry(type.registryKey()))) {
+        final RegistryEntry<?, ?> entry = PaperRegistries.getEntry(type.registryKey());
+        if (entry == null || !entry.meta().modificationApiSupport().canAdd()) {
             throw new IllegalArgumentException(type.registryKey() + " does not support RegistryFreezeEvent");
         }
         return this.freezeEventTypes.getOrCreate(type.registryKey(), RegistryLifecycleEventType::new);
diff --git a/src/main/java/io/papermc/paper/registry/PaperSimpleRegistry.java b/src/main/java/io/papermc/paper/registry/PaperSimpleRegistry.java
index cc39bc68d29055ef6429f08f975412bd9fe68dbc..7c3fdfb46efb2737515f9dcf56d9569ffefa59f5 100644
--- a/src/main/java/io/papermc/paper/registry/PaperSimpleRegistry.java
+++ b/src/main/java/io/papermc/paper/registry/PaperSimpleRegistry.java
@@ -3,6 +3,7 @@ package io.papermc.paper.registry;
 import io.papermc.paper.registry.set.NamedRegistryKeySetImpl;
 import io.papermc.paper.registry.tag.Tag;
 import io.papermc.paper.registry.tag.TagKey;
+import java.util.Collection;
 import java.util.function.Predicate;
 import net.minecraft.core.HolderSet;
 import net.minecraft.core.registries.BuiltInRegistries;
@@ -51,4 +52,9 @@ public class PaperSimpleRegistry<T extends Enum<T> & Keyed, M> extends Registry.
         final HolderSet.Named<M> namedHolderSet = this.nmsRegistry.get(PaperRegistries.toNms(key)).orElseThrow();
         return new NamedRegistryKeySetImpl<>(key, namedHolderSet);
     }
+
+    @Override
+    public Collection<Tag<T>> getTags() {
+        return this.nmsRegistry.getTags().<Tag<T>>map(NamedRegistryKeySetImpl::new).toList();
+    }
 }
diff --git a/src/main/java/io/papermc/paper/registry/WritableCraftRegistry.java b/src/main/java/io/papermc/paper/registry/WritableCraftRegistry.java
index f201f142505db8f5a87c20346f6e2998263372fd..a294ec37b6f593d502d2e044f63b54ec36878c33 100644
--- a/src/main/java/io/papermc/paper/registry/WritableCraftRegistry.java
+++ b/src/main/java/io/papermc/paper/registry/WritableCraftRegistry.java
@@ -2,52 +2,42 @@ package io.papermc.paper.registry;
 
 import com.mojang.serialization.Lifecycle;
 import io.papermc.paper.registry.data.util.Conversions;
-import io.papermc.paper.registry.entry.RegistryEntry;
-import io.papermc.paper.registry.entry.RegistryTypeMapper;
+import io.papermc.paper.registry.entry.RegistryEntryMeta;
 import io.papermc.paper.registry.event.WritableRegistry;
 import java.util.Optional;
-import java.util.function.BiFunction;
 import java.util.function.Consumer;
 import net.minecraft.core.MappedRegistry;
 import net.minecraft.core.RegistrationInfo;
 import net.minecraft.resources.ResourceKey;
 import org.bukkit.Keyed;
-import org.bukkit.NamespacedKey;
 import org.bukkit.craftbukkit.CraftRegistry;
-import org.bukkit.craftbukkit.util.ApiVersion;
 
 public class WritableCraftRegistry<M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> extends CraftRegistry<T, M> {
 
     private static final RegistrationInfo FROM_PLUGIN = new RegistrationInfo(Optional.empty(), Lifecycle.experimental());
 
-    private final RegistryEntry.BuilderHolder<M, T, B> entry;
+    private final RegistryEntryMeta.Buildable<M, T, B> meta;
     private final MappedRegistry<M> registry;
-    private final PaperRegistryBuilder.Factory<M, T, ? extends B> builderFactory;
 
     public WritableCraftRegistry(
-        final RegistryEntry.BuilderHolder<M, T, B> entry,
-        final Class<?> classToPreload,
         final MappedRegistry<M> registry,
-        final BiFunction<NamespacedKey, ApiVersion, NamespacedKey> serializationUpdater,
-        final PaperRegistryBuilder.Factory<M, T, ? extends B> builderFactory,
-        final RegistryTypeMapper<M, T> minecraftToBukkit
+        final RegistryEntryMeta.Buildable<M, T, B> meta
     ) {
-        super(classToPreload, registry, minecraftToBukkit, serializationUpdater);
-        this.entry = entry;
+        super(meta, registry);
         this.registry = registry;
-        this.builderFactory = builderFactory;
+        this.meta = meta;
     }
 
-    public void register(final TypedKey<T> key, final Consumer<? super B> value, final Conversions conversions) {
+    public void register(final TypedKey<T> key, final Consumer<RegistryBuilderFactory<T, B>> value, final Conversions conversions) {
         final ResourceKey<M> resourceKey = PaperRegistries.toNms(key);
         this.registry.validateWrite(resourceKey);
-        final B builder = this.newBuilder(conversions);
-        value.accept(builder);
+        final PaperRegistryBuilderFactory<M, T, B> builderFactory = new PaperRegistryBuilderFactory<>(conversions, this.meta.builderFiller(), this.registry.temporaryUnfrozenMap::get);
+        value.accept(builderFactory);
         PaperRegistryListenerManager.INSTANCE.registerWithListeners(
             this.registry,
-            RegistryEntry.Modifiable.asModifiable(this.entry),
+            this.meta,
             resourceKey,
-            builder,
+            builderFactory.requireBuilder(),
             FROM_PLUGIN,
             conversions
         );
@@ -57,10 +47,6 @@ public class WritableCraftRegistry<M, T extends Keyed, B extends PaperRegistryBu
         return new ApiWritableRegistry(conversions);
     }
 
-    protected B newBuilder(final Conversions conversions) {
-        return this.builderFactory.create(conversions);
-    }
-
     public class ApiWritableRegistry implements WritableRegistry<T, B> {
 
         private final Conversions conversions;
@@ -70,7 +56,7 @@ public class WritableCraftRegistry<M, T extends Keyed, B extends PaperRegistryBu
         }
 
         @Override
-        public void register(final TypedKey<T> key, final Consumer<? super B> value) {
+        public void registerWith(final TypedKey<T> key, final Consumer<RegistryBuilderFactory<T, B>> value) {
             WritableCraftRegistry.this.register(key, value, this.conversions);
         }
     }
diff --git a/src/main/java/io/papermc/paper/registry/data/InlinedRegistryBuilderProviderImpl.java b/src/main/java/io/papermc/paper/registry/data/InlinedRegistryBuilderProviderImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..e0d23b3dc527de3d997fd8ec77ad3138cd2f5eeb
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/data/InlinedRegistryBuilderProviderImpl.java
@@ -0,0 +1,34 @@
+package io.papermc.paper.registry.data;
+
+import com.google.common.base.Preconditions;
+import io.papermc.paper.registry.PaperRegistries;
+import io.papermc.paper.registry.PaperRegistryBuilder;
+import io.papermc.paper.registry.PaperRegistryBuilderFactory;
+import io.papermc.paper.registry.RegistryBuilderFactory;
+import io.papermc.paper.registry.data.util.Conversions;
+import io.papermc.paper.registry.entry.RegistryEntryMeta;
+import java.util.function.Consumer;
+import net.minecraft.core.Holder;
+import net.minecraft.core.Registry;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.resources.ResourceKey;
+import org.bukkit.Art;
+import org.bukkit.Keyed;
+import org.bukkit.craftbukkit.CraftRegistry;
+
+@SuppressWarnings("BoundedWildcard")
+public final class InlinedRegistryBuilderProviderImpl implements InlinedRegistryBuilderProvider {
+
+    private static <M, A extends Keyed, B extends PaperRegistryBuilder<M, A>> A create(final ResourceKey<? extends Registry<M>> registryKey, final Consumer<PaperRegistryBuilderFactory<M, A, B>> value) {
+        final RegistryEntryMeta.Buildable<M, A, B> buildableMeta = PaperRegistries.getBuildableMeta(registryKey);
+        Preconditions.checkArgument(buildableMeta.registryTypeMapper().supportsDirectHolders(), "Registry type mapper must support direct holders");
+        final PaperRegistryBuilderFactory<M, A, B> builderFactory = new PaperRegistryBuilderFactory<>(Conversions.global(), buildableMeta.builderFiller(), CraftRegistry.getMinecraftRegistry(buildableMeta.mcKey())::getValue);
+        value.accept(builderFactory);
+        return buildableMeta.registryTypeMapper().createBukkit(Holder.direct(builderFactory.requireBuilder().build()));
+    }
+
+    @Override
+    public Art createPaintingVariant(final Consumer<RegistryBuilderFactory<Art, ? extends PaintingVariantRegistryEntry.Builder>> value) {
+        return create(Registries.PAINTING_VARIANT, value::accept);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/data/PaperBannerPatternRegistryEntry.java b/src/main/java/io/papermc/paper/registry/data/PaperBannerPatternRegistryEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..70d226a14a8d461bf019434cdd16953451feae64
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/data/PaperBannerPatternRegistryEntry.java
@@ -0,0 +1,65 @@
+package io.papermc.paper.registry.data;
+
+import io.papermc.paper.adventure.PaperAdventure;
+import io.papermc.paper.registry.PaperRegistryBuilder;
+import io.papermc.paper.registry.data.util.Conversions;
+import net.kyori.adventure.key.Key;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.level.block.entity.BannerPattern;
+import org.bukkit.block.banner.PatternType;
+import org.jspecify.annotations.Nullable;
+
+import static io.papermc.paper.registry.data.util.Checks.*;
+
+public class PaperBannerPatternRegistryEntry implements BannerPatternRegistryEntry {
+
+    protected @Nullable ResourceLocation assetId;
+    protected @Nullable String translationKey;
+
+    public PaperBannerPatternRegistryEntry(
+        final Conversions ignoredConversions,
+        final @Nullable BannerPattern internal
+    ) {
+        if (internal == null) return;
+
+        this.assetId = internal.assetId();
+        this.translationKey = internal.translationKey();
+    }
+
+    @Override
+    public Key assetId() {
+        return PaperAdventure.asAdventure(asConfigured(this.assetId, "assetId"));
+    }
+
+    @Override
+    public String translationKey() {
+        return asConfigured(this.translationKey, "translationKey");
+    }
+
+    public static final class PaperBuilder extends PaperBannerPatternRegistryEntry implements Builder, PaperRegistryBuilder<BannerPattern, PatternType> {
+
+        public PaperBuilder(final Conversions conversions, final @Nullable BannerPattern internal) {
+            super(conversions, internal);
+        }
+
+        @Override
+        public Builder assetId(final Key assetId) {
+            this.assetId = PaperAdventure.asVanilla(asArgument(assetId, "assetId"));
+            return this;
+        }
+
+        @Override
+        public Builder translationKey(final String translationKey) {
+            this.translationKey = asArgument(translationKey, "translationKey");
+            return this;
+        }
+
+        @Override
+        public BannerPattern build() {
+            return new BannerPattern(
+                asConfigured(this.assetId, "assetId"),
+                this.translationKey()
+            );
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/data/PaperDamageTypeRegistryEntry.java b/src/main/java/io/papermc/paper/registry/data/PaperDamageTypeRegistryEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..e28dc4df91345f12e32fa9d190059ed2e53a55e4
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/data/PaperDamageTypeRegistryEntry.java
@@ -0,0 +1,112 @@
+package io.papermc.paper.registry.data;
+
+import io.papermc.paper.registry.PaperRegistryBuilder;
+import io.papermc.paper.registry.data.util.Conversions;
+import net.minecraft.world.damagesource.DamageEffects;
+import net.minecraft.world.damagesource.DamageScaling;
+import net.minecraft.world.damagesource.DamageType;
+import net.minecraft.world.damagesource.DeathMessageType;
+import org.bukkit.craftbukkit.damage.CraftDamageEffect;
+import org.bukkit.craftbukkit.damage.CraftDamageType;
+import org.bukkit.damage.DamageEffect;
+import org.jspecify.annotations.Nullable;
+
+import static io.papermc.paper.registry.data.util.Checks.asConfigured;
+
+public class PaperDamageTypeRegistryEntry implements DamageTypeRegistryEntry {
+
+    protected @Nullable String messageId;
+    protected @Nullable Float exhaustion;
+    protected @Nullable DamageScaling damageScaling;
+    protected DamageEffects damageEffects = DamageEffects.HURT;
+    protected DeathMessageType deathMessageType = DeathMessageType.DEFAULT;
+
+    protected final Conversions conversions;
+
+    public PaperDamageTypeRegistryEntry(
+        final Conversions conversions,
+        final @Nullable DamageType internal
+    ) {
+        this.conversions = conversions;
+        if (internal == null) return;
+
+        this.messageId = internal.msgId();
+        this.exhaustion = internal.exhaustion();
+        this.damageScaling = internal.scaling();
+        this.damageEffects = internal.effects();
+        this.deathMessageType = internal.deathMessageType();
+    }
+
+    @Override
+    public String messageId() {
+        return asConfigured(messageId, "messsageId");
+    }
+
+    @Override
+    public float exhaustion() {
+        return asConfigured(exhaustion, "exhaustion");
+    }
+
+    @Override
+    public org.bukkit.damage.DamageScaling damageScaling() {
+        return CraftDamageType.damageScalingToBukkit(asConfigured(this.damageScaling, "damageScaling"));
+    }
+
+    @Override
+    public DamageEffect damageEffect() {
+        return CraftDamageEffect.toBukkit(damageEffects);
+    }
+
+    @Override
+    public org.bukkit.damage.DeathMessageType deathMessageType() {
+        return CraftDamageType.deathMessageTypeToBukkit(deathMessageType);
+    }
+
+    public static final class PaperBuilder extends PaperDamageTypeRegistryEntry implements DamageTypeRegistryEntry.Builder, PaperRegistryBuilder<DamageType, org.bukkit.damage.DamageType> {
+
+        public PaperBuilder(final Conversions conversions, final @Nullable DamageType internal) {
+            super(conversions, internal);
+        }
+
+        @Override
+        public Builder messageId(final String messageId) {
+            this.messageId = messageId;
+            return this;
+        }
+
+        @Override
+        public Builder exhaustion(final float exhaustion) {
+            this.exhaustion = exhaustion;
+            return this;
+        }
+
+        @Override
+        public Builder damageScaling(final org.bukkit.damage.DamageScaling scaling) {
+            this.damageScaling = CraftDamageType.damageScalingToNMS(scaling);
+            return this;
+        }
+
+        @Override
+        public Builder damageEffect(final DamageEffect effect) {
+            this.damageEffects = ((CraftDamageEffect) effect).getHandle();
+            return this;
+        }
+
+        @Override
+        public Builder deathMessageType(final org.bukkit.damage.DeathMessageType deathMessageType) {
+            this.deathMessageType = CraftDamageType.deathMessageTypeToNMS(deathMessageType);
+            return this;
+        }
+
+        @Override
+        public DamageType build() {
+            return new DamageType(
+                asConfigured(this.messageId, "messsageId"),
+                asConfigured(this.damageScaling, "scaling"),
+                asConfigured(this.exhaustion, "exhaustion"),
+                this.damageEffects,
+                this.deathMessageType
+            );
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/entry/RegistryEntry.java b/src/main/java/io/papermc/paper/registry/entry/RegistryEntry.java
index 32089721edfd806d082bd267bba040e249dbf75b..17c7ec77cf1a58657b5deb29702d6399760f7ec2 100644
--- a/src/main/java/io/papermc/paper/registry/entry/RegistryEntry.java
+++ b/src/main/java/io/papermc/paper/registry/entry/RegistryEntry.java
@@ -1,27 +1,24 @@
 package io.papermc.paper.registry.entry;
 
-import io.papermc.paper.registry.PaperRegistryBuilder;
 import io.papermc.paper.registry.RegistryHolder;
 import io.papermc.paper.registry.RegistryKey;
-import io.papermc.paper.registry.TypedKey;
-import io.papermc.paper.registry.WritableCraftRegistry;
-import io.papermc.paper.registry.data.util.Conversions;
-import io.papermc.paper.registry.event.RegistryEntryAddEventImpl;
-import io.papermc.paper.registry.event.RegistryFreezeEventImpl;
 import io.papermc.paper.registry.legacy.DelayedRegistryEntry;
-import java.util.function.BiFunction;
 import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceKey;
 import org.bukkit.Keyed;
-import org.bukkit.NamespacedKey;
-import org.bukkit.craftbukkit.util.ApiVersion;
-import org.jspecify.annotations.Nullable;
 
-public interface RegistryEntry<M, B extends Keyed> extends RegistryEntryInfo<M, B> { // TODO remove Keyed
+public interface RegistryEntry<M, A extends Keyed> { // TODO remove Keyed
 
-    RegistryHolder<B> createRegistryHolder(Registry<M> nmsRegistry);
+    RegistryHolder<A> createRegistryHolder(Registry<M> nmsRegistry);
 
-    default RegistryEntry<M, B> withSerializationUpdater(final BiFunction<NamespacedKey, ApiVersion, NamespacedKey> updater) {
-        return this;
+    RegistryEntryMeta<M, A> meta();
+
+    default RegistryKey<A> apiKey() {
+        return this.meta().apiKey();
+    }
+
+    default ResourceKey<? extends Registry<M>> mcKey() {
+        return this.meta().mcKey();
     }
 
     /**
@@ -30,66 +27,7 @@ public interface RegistryEntry<M, B extends Keyed> extends RegistryEntryInfo<M,
      * as fields, but instead be obtained via {@link io.papermc.paper.registry.RegistryAccess#getRegistry(RegistryKey)}
      */
     @Deprecated
-    default RegistryEntry<M, B> delayed() {
+    default RegistryEntry<M, A> delayed() {
         return new DelayedRegistryEntry<>(this);
     }
-
-    interface BuilderHolder<M, T, B extends PaperRegistryBuilder<M, T>> extends RegistryEntryInfo<M, T> {
-
-        B fillBuilder(Conversions conversions, M nms);
-    }
-
-    /**
-     * Can mutate values being added to the registry
-     */
-    interface Modifiable<M, T, B extends PaperRegistryBuilder<M, T>> extends BuilderHolder<M, T, B> {
-
-        static boolean isModifiable(final @Nullable RegistryEntryInfo<?, ?> entry) {
-            return entry instanceof RegistryEntry.Modifiable<?, ?, ?> || (entry instanceof final DelayedRegistryEntry<?, ?> delayed && delayed.delegate() instanceof RegistryEntry.Modifiable<?, ?, ?>);
-        }
-
-        static <M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> Modifiable<M, T, B> asModifiable(final RegistryEntryInfo<M, T> entry) { // TODO remove Keyed
-            return (Modifiable<M, T, B>) possiblyUnwrap(entry);
-        }
-
-        default RegistryEntryAddEventImpl<T, B> createEntryAddEvent(final TypedKey<T> key, final B initialBuilder, final Conversions conversions) {
-            return new RegistryEntryAddEventImpl<>(key, initialBuilder, this.apiKey(), conversions);
-        }
-    }
-
-    /**
-     * Can only add new values to the registry, not modify any values.
-     */
-    interface Addable<M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> extends BuilderHolder<M, T, B> { // TODO remove Keyed
-
-        default RegistryFreezeEventImpl<T, B> createFreezeEvent(final WritableCraftRegistry<M, T, B> writableRegistry, final Conversions conversions) {
-            return new RegistryFreezeEventImpl<>(this.apiKey(), writableRegistry.createApiWritableRegistry(conversions), conversions);
-        }
-
-        static boolean isAddable(final @Nullable RegistryEntryInfo<?, ?> entry) {
-            return entry instanceof RegistryEntry.Addable<?, ?, ?> || (entry instanceof final DelayedRegistryEntry<?, ?> delayed && delayed.delegate() instanceof RegistryEntry.Addable<?, ?, ?>);
-        }
-
-        static <M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> Addable<M, T, B> asAddable(final RegistryEntryInfo<M, T> entry) {
-            return (Addable<M, T, B>) possiblyUnwrap(entry);
-        }
-    }
-
-    /**
-     * Can mutate values and add new values.
-     */
-    interface Writable<M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> extends Modifiable<M, T, B>, Addable<M, T, B> { // TODO remove Keyed
-
-        static boolean isWritable(final @Nullable RegistryEntryInfo<?, ?> entry) {
-            return entry instanceof RegistryEntry.Writable<?, ?, ?> || (entry instanceof final DelayedRegistryEntry<?, ?> delayed && delayed.delegate() instanceof RegistryEntry.Writable<?, ?, ?>);
-        }
-
-        static <M, T extends Keyed, B extends PaperRegistryBuilder<M, T>> Writable<M, T, B> asWritable(final RegistryEntryInfo<M, T> entry) { // TODO remove Keyed
-            return (Writable<M, T, B>) possiblyUnwrap(entry);
-        }
-    }
-
-    private static <M, B extends Keyed> RegistryEntryInfo<M, B> possiblyUnwrap(final RegistryEntryInfo<M, B> entry) {
-        return entry instanceof final DelayedRegistryEntry<M, B> delayed ? delayed.delegate() : entry;
-    }
 }
diff --git a/src/main/java/io/papermc/paper/registry/entry/RegistryEntryBuilder.java b/src/main/java/io/papermc/paper/registry/entry/RegistryEntryBuilder.java
index 5352ec936c7bdd5ca74fca182eafb21e9d190d74..57a46cc9015122fb35b1a5bf8a2067ea1f0c77df 100644
--- a/src/main/java/io/papermc/paper/registry/entry/RegistryEntryBuilder.java
+++ b/src/main/java/io/papermc/paper/registry/entry/RegistryEntryBuilder.java
@@ -1,6 +1,5 @@
 package io.papermc.paper.registry.entry;
 
-import com.mojang.datafixers.util.Either;
 import io.papermc.paper.registry.PaperRegistryBuilder;
 import io.papermc.paper.registry.RegistryKey;
 import java.util.function.BiFunction;
@@ -11,6 +10,11 @@ import net.minecraft.core.Registry;
 import net.minecraft.resources.ResourceKey;
 import org.bukkit.Keyed;
 import org.bukkit.NamespacedKey;
+import org.bukkit.craftbukkit.util.ApiVersion;
+
+import static io.papermc.paper.registry.entry.RegistryEntryMeta.RegistryModificationApiSupport.ADDABLE;
+import static io.papermc.paper.registry.entry.RegistryEntryMeta.RegistryModificationApiSupport.MODIFIABLE;
+import static io.papermc.paper.registry.entry.RegistryEntryMeta.RegistryModificationApiSupport.WRITABLE;
 
 public class RegistryEntryBuilder<M, A extends Keyed> { // TODO remove Keyed
 
@@ -30,7 +34,7 @@ public class RegistryEntryBuilder<M, A extends Keyed> { // TODO remove Keyed
     }
 
     public RegistryEntry<M, A> apiOnly(final Supplier<org.bukkit.Registry<A>> apiRegistrySupplier) {
-        return new ApiRegistryEntry<>(this.mcKey, this.apiKey, apiRegistrySupplier);
+        return new RegistryEntryImpl<>(new RegistryEntryMeta.ApiOnly<>(this.mcKey, this.apiKey, apiRegistrySupplier));
     }
 
     public CraftStage<M, A> craft(final Class<?> classToPreload, final BiFunction<? super NamespacedKey, M, ? extends A> minecraftToBukkit) {
@@ -38,13 +42,20 @@ public class RegistryEntryBuilder<M, A extends Keyed> { // TODO remove Keyed
     }
 
     public CraftStage<M, A> craft(final Class<?> classToPreload, final Function<Holder<M>, ? extends A> minecraftToBukkit) {
-        return new CraftStage<>(this.mcKey, this.apiKey, classToPreload, new RegistryTypeMapper<>(minecraftToBukkit));
+        return this.craft(classToPreload, minecraftToBukkit, false);
+    }
+
+    public CraftStage<M, A> craft(final Class<?> classToPreload, final Function<Holder<M>, ? extends A> minecraftToBukkit, final boolean allowDirect) {
+        return new CraftStage<>(this.mcKey, this.apiKey, classToPreload, new RegistryTypeMapper<>(minecraftToBukkit, allowDirect));
     }
 
     public static final class CraftStage<M, A extends Keyed> extends RegistryEntryBuilder<M, A> { // TODO remove Keyed
 
+        private static final BiFunction<NamespacedKey, ApiVersion, NamespacedKey> EMPTY = (namespacedKey, apiVersion) -> namespacedKey;
+
         private final Class<?> classToPreload;
         private final RegistryTypeMapper<M, A> minecraftToBukkit;
+        private BiFunction<NamespacedKey, ApiVersion, NamespacedKey> serializationUpdater = EMPTY;
 
         private CraftStage(
             final ResourceKey<? extends Registry<M>> mcKey,
@@ -57,20 +68,29 @@ public class RegistryEntryBuilder<M, A extends Keyed> { // TODO remove Keyed
             this.minecraftToBukkit = minecraftToBukkit;
         }
 
+        public CraftStage<M, A> serializationUpdater(final BiFunction<NamespacedKey, ApiVersion, NamespacedKey> serializationUpdater) {
+            this.serializationUpdater = serializationUpdater;
+            return this;
+        }
+
         public RegistryEntry<M, A> build() {
-            return new CraftRegistryEntry<>(this.mcKey, this.apiKey, this.classToPreload, this.minecraftToBukkit);
+            return new RegistryEntryImpl<>(new RegistryEntryMeta.Craft<>(this.mcKey, this.apiKey, this.classToPreload, this.minecraftToBukkit, this.serializationUpdater));
         }
 
         public <B extends PaperRegistryBuilder<M, A>> RegistryEntry<M, A> modifiable(final PaperRegistryBuilder.Filler<M, A, B> filler) {
-            return new ModifiableRegistryEntry<>(this.mcKey, this.apiKey, this.classToPreload, this.minecraftToBukkit, filler);
+            return this.create(filler, MODIFIABLE);
         }
 
         public <B extends PaperRegistryBuilder<M, A>> RegistryEntry<M, A> addable(final PaperRegistryBuilder.Filler<M, A, B> filler) {
-            return new AddableRegistryEntry<>(this.mcKey, this.apiKey, this.classToPreload, this.minecraftToBukkit, filler);
+            return this.create(filler, ADDABLE);
         }
 
         public <B extends PaperRegistryBuilder<M, A>> RegistryEntry<M, A> writable(final PaperRegistryBuilder.Filler<M, A, B> filler) {
-            return new WritableRegistryEntry<>(this.mcKey, this.apiKey, this.classToPreload, this.minecraftToBukkit, filler);
+            return this.create(filler, WRITABLE);
+        }
+
+        private <B extends PaperRegistryBuilder<M, A>> RegistryEntry<M, A> create(final PaperRegistryBuilder.Filler<M, A, B> filler, final RegistryEntryMeta.RegistryModificationApiSupport support) {
+            return new RegistryEntryImpl<>(new RegistryEntryMeta.Buildable<>(this.mcKey, this.apiKey, this.classToPreload, this.minecraftToBukkit, this.serializationUpdater, filler, support));
         }
     }
 }
diff --git a/src/main/java/io/papermc/paper/registry/entry/RegistryEntryImpl.java b/src/main/java/io/papermc/paper/registry/entry/RegistryEntryImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..1c8b2d4855f375d8a5744823d539f1be6ca45474
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/entry/RegistryEntryImpl.java
@@ -0,0 +1,13 @@
+package io.papermc.paper.registry.entry;
+
+import io.papermc.paper.registry.RegistryHolder;
+import net.minecraft.core.Registry;
+import org.bukkit.Keyed;
+
+record RegistryEntryImpl<M, A extends Keyed>(RegistryEntryMeta<M, A> meta) implements RegistryEntry<M, A> {
+
+    @Override
+    public RegistryHolder<A> createRegistryHolder(final Registry<M> nmsRegistry) {
+        return new RegistryHolder.Memoized<>(() -> this.meta().createApiRegistry(nmsRegistry));
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/entry/RegistryEntryMeta.java b/src/main/java/io/papermc/paper/registry/entry/RegistryEntryMeta.java
new file mode 100644
index 0000000000000000000000000000000000000000..7cd152734fb5d46f4c329623e2ca0635b2c11748
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/entry/RegistryEntryMeta.java
@@ -0,0 +1,122 @@
+package io.papermc.paper.registry.entry;
+
+import com.google.common.base.Preconditions;
+import io.papermc.paper.registry.PaperRegistryBuilder;
+import io.papermc.paper.registry.RegistryKey;
+import io.papermc.paper.registry.TypedKey;
+import io.papermc.paper.registry.WritableCraftRegistry;
+import io.papermc.paper.registry.data.util.Conversions;
+import io.papermc.paper.registry.event.RegistryEntryAddEventImpl;
+import io.papermc.paper.registry.event.RegistryFreezeEventImpl;
+import java.util.function.BiFunction;
+import java.util.function.Supplier;
+import net.minecraft.core.MappedRegistry;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceKey;
+import org.bukkit.Keyed;
+import org.bukkit.NamespacedKey;
+import org.bukkit.craftbukkit.CraftRegistry;
+import org.bukkit.craftbukkit.util.ApiVersion;
+
+public sealed interface RegistryEntryMeta<M, A extends Keyed> permits RegistryEntryMeta.ApiOnly, RegistryEntryMeta.ServerSide { // TODO remove Keyed
+
+    ResourceKey<? extends Registry<M>> mcKey();
+
+    RegistryKey<A> apiKey();
+
+    org.bukkit.Registry<A> createApiRegistry(final Registry<M> nmsRegistry);
+
+    default RegistryModificationApiSupport modificationApiSupport() {
+        return RegistryModificationApiSupport.NONE;
+    }
+
+    record ApiOnly<M, A extends Keyed>(ResourceKey<? extends Registry<M>> mcKey, RegistryKey<A> apiKey, Supplier<org.bukkit.Registry<A>> registrySupplier) implements RegistryEntryMeta<M, A> { // TODO remove Keyed
+
+        @Override
+        public org.bukkit.Registry<A> createApiRegistry(final Registry<M> nmsRegistry) {
+            return this.registrySupplier.get();
+        }
+    }
+
+    sealed interface ServerSide<M, A extends Keyed> extends RegistryEntryMeta<M, A> permits RegistryEntryMeta.Craft, RegistryEntryMeta.Buildable { // TODO remove Keyed
+
+        Class<?> classToPreload();
+
+        RegistryTypeMapper<M, A> registryTypeMapper();
+
+        BiFunction<NamespacedKey, ApiVersion, NamespacedKey> serializationUpdater();
+
+        default org.bukkit.Registry<A> createApiRegistry(final Registry<M> nmsRegistry) {
+            return new CraftRegistry<>(this, nmsRegistry);
+        }
+    }
+
+    record Craft<M, A extends Keyed>(
+        ResourceKey<? extends Registry<M>> mcKey,
+        RegistryKey<A> apiKey,
+        Class<?> classToPreload,
+        RegistryTypeMapper<M, A> registryTypeMapper,
+        BiFunction<NamespacedKey, ApiVersion, NamespacedKey> serializationUpdater
+    ) implements ServerSide<M, A> { // TODO remove Keyed
+
+        public Craft {
+            Preconditions.checkArgument(!classToPreload.getPackageName().startsWith("net.minecraft"), classToPreload + " should not be in the net.minecraft package as the class-to-preload");
+        }
+    }
+
+    enum RegistryModificationApiSupport {
+        /**
+         * Cannot add or modify values in the registry.
+         */
+        NONE,
+        /**
+         * Can only add new values to the registry, not modify any values.
+         */
+        ADDABLE,
+        /**
+         * Can mutate values being added to the registry
+         */
+        MODIFIABLE,
+        /**
+         * Can mutate values and add new values.
+         */
+        WRITABLE,
+        ;
+
+        public boolean canAdd() {
+            return this != MODIFIABLE && this != NONE;
+        }
+
+        public boolean canModify() {
+            return this != ADDABLE && this != NONE;
+        }
+    }
+
+    record Buildable<M, A extends Keyed, B extends PaperRegistryBuilder<M, A>>( // TODO remove Keyed
+        ResourceKey<? extends Registry<M>> mcKey,
+        RegistryKey<A> apiKey,
+        Class<?> classToPreload,
+        RegistryTypeMapper<M, A> registryTypeMapper,
+        BiFunction<NamespacedKey, ApiVersion, NamespacedKey> serializationUpdater,
+        PaperRegistryBuilder.Filler<M, A, B> builderFiller,
+        RegistryModificationApiSupport modificationApiSupport
+    ) implements ServerSide<M, A> {
+
+        public RegistryEntryAddEventImpl<A, B> createEntryAddEvent(final TypedKey<A> key, final B initialBuilder, final Conversions conversions) {
+            return new RegistryEntryAddEventImpl<>(key, initialBuilder, this.apiKey(), conversions);
+        }
+
+        public RegistryFreezeEventImpl<A, B> createFreezeEvent(final WritableCraftRegistry<M, A, B> writableRegistry, final Conversions conversions) {
+            return new RegistryFreezeEventImpl<>(this.apiKey(), writableRegistry.createApiWritableRegistry(conversions), conversions);
+        }
+
+        @Override
+        public org.bukkit.Registry<A> createApiRegistry(final Registry<M> nmsRegistry) {
+            if (this.modificationApiSupport.canAdd()) {
+                return new WritableCraftRegistry<>((MappedRegistry<M>) nmsRegistry, this);
+            } else {
+                return ServerSide.super.createApiRegistry(nmsRegistry);
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/entry/RegistryTypeMapper.java b/src/main/java/io/papermc/paper/registry/entry/RegistryTypeMapper.java
index c950524f7928c03fb8e4f89521f98ad38e6bd892..87c0f502afb5c639bbe5191e379e1205288973b3 100644
--- a/src/main/java/io/papermc/paper/registry/entry/RegistryTypeMapper.java
+++ b/src/main/java/io/papermc/paper/registry/entry/RegistryTypeMapper.java
@@ -1,7 +1,7 @@
 package io.papermc.paper.registry.entry;
 
-import com.google.common.base.Preconditions;
 import com.mojang.datafixers.util.Either;
+import io.papermc.paper.util.MCUtil;
 import java.util.function.BiFunction;
 import java.util.function.Function;
 import net.minecraft.core.Holder;
@@ -9,29 +9,40 @@ import org.bukkit.NamespacedKey;
 
 public final class RegistryTypeMapper<M, A> {
 
-    final Either<BiFunction<? super NamespacedKey, M, ? extends A>, Function<Holder<M>, ? extends A>> minecraftToBukkit;
+    private static <M, A> Function<Holder<M>, ? extends A> wrap(final BiFunction<? super NamespacedKey, M, ? extends A> byValueCreator) {
+        return holder -> {
+            if (!(holder instanceof final Holder.Reference<M> reference)) {
+                throw new IllegalArgumentException("This type does not support direct holders: " + holder);
+            }
+            return byValueCreator.apply(MCUtil.fromResourceKey(reference.key()), reference.value());
+        };
+    }
+
+    final Either<Function<Holder<M>, ? extends A>, BiFunction<? super NamespacedKey, M, ? extends A>> minecraftToBukkit;
+    private final boolean supportsDirectHolders;
 
     public RegistryTypeMapper(final BiFunction<? super NamespacedKey, M, ? extends A> byValueCreator) {
-        this.minecraftToBukkit = Either.left(byValueCreator);
+        this.minecraftToBukkit = Either.right(byValueCreator);
+        this.supportsDirectHolders = false;
     }
 
-    public RegistryTypeMapper(final Function<Holder<M>, ? extends A> byHolderCreator) {
-        this.minecraftToBukkit = Either.right(byHolderCreator);
+    public RegistryTypeMapper(final Function<Holder<M>, ? extends A> byHolderCreator, final boolean supportsDirectHolders) {
+        this.minecraftToBukkit = Either.left(byHolderCreator);
+        this.supportsDirectHolders = supportsDirectHolders;
     }
 
-    public A createBukkit(final NamespacedKey key, final Holder<M> minecraft) {
-        return this.minecraftToBukkit.map(
-            minecraftToBukkit -> minecraftToBukkit.apply(key, minecraft.value()),
-            minecraftToBukkit -> minecraftToBukkit.apply(minecraft)
-        );
+    public A createBukkit(final Holder<M> minecraft) {
+        return this.minecraftToBukkit.<Function<Holder<M>, ? extends A>>map(
+            Function.identity(),
+            RegistryTypeMapper::wrap
+        ).apply(minecraft);
     }
 
     public boolean supportsDirectHolders() {
-        return this.minecraftToBukkit.right().isPresent();
+        return this.supportsDirectHolders;
     }
 
-    public A convertDirectHolder(final Holder<M> directHolder) {
-        Preconditions.checkArgument(this.supportsDirectHolders() && directHolder.kind() == Holder.Kind.DIRECT);
-        return this.minecraftToBukkit.right().orElseThrow().apply(directHolder);
+    public boolean constructorUsesHolder() {
+        return this.minecraftToBukkit.left().isPresent();
     }
 }
diff --git a/src/main/java/io/papermc/paper/registry/legacy/DelayedRegistry.java b/src/main/java/io/papermc/paper/registry/legacy/DelayedRegistry.java
index fdc475f2b112ba88ff1d89cb0c4eaa465b2d034c..527fbbbbebccdc449dbfb0d085cf4894453f8796 100644
--- a/src/main/java/io/papermc/paper/registry/legacy/DelayedRegistry.java
+++ b/src/main/java/io/papermc/paper/registry/legacy/DelayedRegistry.java
@@ -2,6 +2,7 @@ package io.papermc.paper.registry.legacy;
 
 import io.papermc.paper.registry.tag.Tag;
 import io.papermc.paper.registry.tag.TagKey;
+import java.util.Collection;
 import java.util.Iterator;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
@@ -38,11 +39,6 @@ public final class DelayedRegistry<T extends Keyed, R extends Registry<T>> imple
         return this.delegate().get(key);
     }
 
-    @Override
-    public T getOrThrow(final NamespacedKey key) {
-        return this.delegate().getOrThrow(key);
-    }
-
     @Override
     public Iterator<T> iterator() {
         return this.delegate().iterator();
@@ -67,4 +63,9 @@ public final class DelayedRegistry<T extends Keyed, R extends Registry<T>> imple
     public @NonNull Tag<T> getTag(final TagKey<T> key) {
         return this.delegate().getTag(key);
     }
+
+    @Override
+    public Collection<Tag<T>> getTags() {
+        return this.delegate().getTags();
+    }
 }
diff --git a/src/main/java/io/papermc/paper/registry/legacy/DelayedRegistryEntry.java b/src/main/java/io/papermc/paper/registry/legacy/DelayedRegistryEntry.java
index 110b8d559f49f9e4f181b47663962a139a273a72..168afab750e6d657a8a81aa782520568705ccaf8 100644
--- a/src/main/java/io/papermc/paper/registry/legacy/DelayedRegistryEntry.java
+++ b/src/main/java/io/papermc/paper/registry/legacy/DelayedRegistryEntry.java
@@ -1,26 +1,20 @@
 package io.papermc.paper.registry.legacy;
 
 import io.papermc.paper.registry.RegistryHolder;
-import io.papermc.paper.registry.RegistryKey;
 import io.papermc.paper.registry.entry.RegistryEntry;
+import io.papermc.paper.registry.entry.RegistryEntryMeta;
 import net.minecraft.core.Registry;
-import net.minecraft.resources.ResourceKey;
 import org.bukkit.Keyed;
 
-public record DelayedRegistryEntry<M, T extends Keyed>(RegistryEntry<M, T> delegate) implements RegistryEntry<M, T> {
+public record DelayedRegistryEntry<M, A extends Keyed>(RegistryEntry<M, A> delegate) implements RegistryEntry<M, A> {
 
     @Override
-    public ResourceKey<? extends Registry<M>> mcKey() {
-        return this.delegate.mcKey();
+    public RegistryEntryMeta<M, A> meta() {
+        return this.delegate.meta();
     }
 
     @Override
-    public RegistryKey<T> apiKey() {
-        return this.delegate.apiKey();
-    }
-
-    @Override
-    public RegistryHolder<T> createRegistryHolder(final Registry<M> nmsRegistry) {
+    public RegistryHolder<A> createRegistryHolder(final Registry<M> nmsRegistry) {
         return this.delegate.createRegistryHolder(nmsRegistry);
     }
 }
diff --git a/src/main/java/io/papermc/paper/registry/set/NamedRegistryKeySetImpl.java b/src/main/java/io/papermc/paper/registry/set/NamedRegistryKeySetImpl.java
index 7b15640c2f10c72f2612ab2270adc5689dfd9e5a..79499fa9023f1861c619605d37d6d96a8b153cb7 100644
--- a/src/main/java/io/papermc/paper/registry/set/NamedRegistryKeySetImpl.java
+++ b/src/main/java/io/papermc/paper/registry/set/NamedRegistryKeySetImpl.java
@@ -26,6 +26,10 @@ public record NamedRegistryKeySetImpl<T extends Keyed, M>( // TODO remove Keyed
     HolderSet.Named<M> namedSet
 ) implements Tag<T>, org.bukkit.Tag<T> {
 
+    public NamedRegistryKeySetImpl(final HolderSet.Named<M> namedSet) {
+        this(PaperRegistries.fromNms(namedSet.key()), namedSet);
+    }
+
     @Override
     public @Unmodifiable Collection<TypedKey<T>> values() {
         final ImmutableList.Builder<TypedKey<T>> builder = ImmutableList.builder();
diff --git a/src/main/java/io/papermc/paper/util/Holderable.java b/src/main/java/io/papermc/paper/util/Holderable.java
index 77c4acd13cfcaf0164bf872c157a55195909a00c..746c14b1792dd060a9cf19865c10cb93e1e7f688 100644
--- a/src/main/java/io/papermc/paper/util/Holderable.java
+++ b/src/main/java/io/papermc/paper/util/Holderable.java
@@ -4,10 +4,12 @@ import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.JsonOps;
+import io.papermc.paper.registry.RegistryAccess;
+import io.papermc.paper.registry.RegistryKey;
 import net.kyori.adventure.key.Key;
 import net.minecraft.core.Holder;
 import net.minecraft.resources.RegistryOps;
-import org.bukkit.Keyed;
+import org.bukkit.NamespacedKey;
 import org.bukkit.Registry;
 import org.bukkit.craftbukkit.CraftRegistry;
 import org.bukkit.craftbukkit.util.Handleable;
@@ -25,7 +27,8 @@ public interface Holderable<M> extends Handleable<M> {
         return this.getHolder().value();
     }
 
-    static <T extends Keyed, M> @Nullable T fromBukkitSerializationObject(final Object deserialized, final Codec<? extends Holder<M>> codec, final Registry<T> registry) { // TODO remove Keyed
+    static <T extends org.bukkit.Keyed, M> @Nullable T fromBukkitSerializationObject(final Object deserialized, final Codec<M> directCodec, final RegistryKey<T> registryKey) { // TODO remove Keyed
+        final Registry<T> registry = RegistryAccess.registryAccess().getRegistry(registryKey);
         return switch (deserialized) {
             case @Subst("key:value") final String string -> {
                 if (!(Key.parseable(string))) {
@@ -33,23 +36,23 @@ public interface Holderable<M> extends Handleable<M> {
                 }
                 yield registry.get(Key.key(string));
             }
-            case JsonObjectWrapper(JsonObject element) -> {
+            case JsonObjectWrapper(final JsonObject element) -> {
                 if (!(registry instanceof final CraftRegistry<?, ?> craftRegistry) || !craftRegistry.supportsDirectHolders()) {
                     throw new IllegalArgumentException("Cannot deserialize direct holders for " + registry);
                 }
                 final RegistryOps<JsonElement> ops = CraftRegistry.getMinecraftRegistry().createSerializationContext(JsonOps.INSTANCE);
-                final Holder<M> holder = codec.decode(ops, element).getOrThrow().getFirst();
-                yield ((CraftRegistry<T, M>) registry).convertDirectHolder(holder);
+                final M holder = directCodec.decode(ops, element).getOrThrow().getFirst();
+                yield ((CraftRegistry<T, M>) registry).createBukkit(Holder.direct(holder));
             }
             default -> throw new IllegalArgumentException("Cannot deserialize " + deserialized);
         };
     }
 
-    default Object toBukkitSerializationObject(final Codec<? super Holder<M>> codec) {
+    default Object toBukkitSerializationObject(final Codec<? super M> directCodec) {
         return switch (this.getHolder()) {
             case final Holder.Direct<M> direct -> {
                 final RegistryOps<JsonElement> ops = CraftRegistry.getMinecraftRegistry().createSerializationContext(JsonOps.INSTANCE);
-                yield new JsonObjectWrapper(codec.encodeStart(ops, direct).getOrThrow().getAsJsonObject());
+                yield new JsonObjectWrapper(directCodec.encodeStart(ops, direct.value()).getOrThrow().getAsJsonObject());
             }
             case final Holder.Reference<M> reference -> reference.key().location().toString();
             default -> throw new IllegalArgumentException("Cannot serialize " + this.getHolder());
@@ -75,4 +78,12 @@ public interface Holderable<M> extends Handleable<M> {
     default String implToString() {
         return "%s{holder=%s}".formatted(this.getClass().getSimpleName(), this.getHolder().toString());
     }
+
+    default @Nullable NamespacedKey getKeyOrNull() {
+        return this.getHolder().unwrapKey().map(MCUtil::fromResourceKey).orElse(null);
+    }
+
+    default NamespacedKey getKey() {
+        return MCUtil.fromResourceKey(this.getHolder().unwrapKey().orElseThrow(() -> new IllegalStateException("Cannot get key for this registry item, because it is not registered.")));
+    }
 }
diff --git a/src/main/java/io/papermc/paper/util/ItemComponentSanitizer.java b/src/main/java/io/papermc/paper/util/ItemComponentSanitizer.java
new file mode 100644
index 0000000000000000000000000000000000000000..15236ed57721b4231c55eb96f6004b5f902a2bf7
--- /dev/null
+++ b/src/main/java/io/papermc/paper/util/ItemComponentSanitizer.java
@@ -0,0 +1,98 @@
+package io.papermc.paper.util;
+
+import com.google.common.collect.ImmutableMap;
+import io.papermc.paper.configuration.GlobalConfiguration;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.function.UnaryOperator;
+import net.minecraft.Util;
+import net.minecraft.core.component.DataComponentType;
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.util.RandomSource;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.alchemy.PotionContents;
+import net.minecraft.world.item.component.LodestoneTracker;
+import net.minecraft.world.item.enchantment.ItemEnchantments;
+import org.jspecify.annotations.NullMarked;
+
+@NullMarked
+public final class ItemComponentSanitizer {
+
+    /*
+     * This returns for types, that when configured to be serialized, should instead return these objects.
+     * This is possibly because dropping the patched type may introduce visual changes.
+     */
+    static final Map<DataComponentType<?>, UnaryOperator<?>> SANITIZATION_OVERRIDES = Util.make(ImmutableMap.<DataComponentType<?>, UnaryOperator<?>>builder(), (map) -> {
+            put(map, DataComponents.LODESTONE_TRACKER, empty(new LodestoneTracker(Optional.empty(), false))); // We need it to be present to keep the glint
+            put(map, DataComponents.ENCHANTMENTS, empty(dummyEnchantments())); // We need to keep it present to keep the glint
+            put(map, DataComponents.STORED_ENCHANTMENTS, empty(dummyEnchantments())); // We need to keep it present to keep the glint
+            put(map, DataComponents.POTION_CONTENTS, ItemComponentSanitizer::sanitizePotionContents); // Custom situational serialization
+        }
+    ).build();
+
+    @SuppressWarnings({"rawtypes", "unchecked"})
+    private static <T> void put(final ImmutableMap.Builder map, final DataComponentType<T> type, final UnaryOperator<T> object) {
+        map.put(type, object);
+    }
+
+    private static <T> UnaryOperator<T> empty(final T object) {
+        return (unused) -> object;
+    }
+
+    private static PotionContents sanitizePotionContents(final PotionContents potionContents) {
+        // We have a custom color! We can hide everything!
+        if (potionContents.customColor().isPresent()) {
+            return new PotionContents(Optional.empty(), potionContents.customColor(), List.of(), Optional.empty());
+        }
+
+        // WE cannot hide anything really, as the color is a mix of potion/potion contents, which can
+        // possibly be reversed.
+        return potionContents;
+    }
+
+    // We cant use the empty map from enchantments because we want to keep the glow
+    private static ItemEnchantments dummyEnchantments() {
+        final ItemEnchantments.Mutable obj = new ItemEnchantments.Mutable(ItemEnchantments.EMPTY);
+        obj.set(MinecraftServer.getServer().registryAccess().lookupOrThrow(Registries.ENCHANTMENT).getRandom(RandomSource.create()).orElseThrow(), 1);
+        return obj.toImmutable();
+    }
+
+    public static int sanitizeCount(final ItemObfuscationSession obfuscationSession, final ItemStack itemStack, final int count) {
+        if (obfuscationSession.obfuscationLevel() != ItemObfuscationSession.ObfuscationLevel.ALL) return count; // Ignore if we are not obfuscating
+
+        if (GlobalConfiguration.get().anticheat.obfuscation.items.binding.getAssetObfuscation(itemStack).sanitizeCount()) {
+            return 1;
+        } else {
+            return count;
+        }
+    }
+
+    public static boolean shouldDrop(final ItemObfuscationSession obfuscationSession, final DataComponentType<?> key) {
+        if (obfuscationSession.obfuscationLevel() != ItemObfuscationSession.ObfuscationLevel.ALL) return false; // Ignore if we are not obfuscating
+
+        final ItemStack targetItemstack = obfuscationSession.context().itemStack();
+
+        // Only drop if configured to do so.
+        return GlobalConfiguration.get().anticheat.obfuscation.items.binding.getAssetObfuscation(targetItemstack).patchStrategy().get(key) == ItemObfuscationBinding.BoundObfuscationConfiguration.MutationType.Drop.INSTANCE;
+    }
+
+    public static Optional<?> override(final ItemObfuscationSession obfuscationSession, final DataComponentType<?> key, final Optional<?> value) {
+        if (obfuscationSession.obfuscationLevel() != ItemObfuscationSession.ObfuscationLevel.ALL) return value; // Ignore if we are not obfuscating
+
+        // Ignore removed values
+        if (value.isEmpty()) {
+            return value;
+        }
+
+        final ItemStack targetItemstack = obfuscationSession.context().itemStack();
+
+        return switch (GlobalConfiguration.get().anticheat.obfuscation.items.binding.getAssetObfuscation(targetItemstack).patchStrategy().get(key)) {
+            case final ItemObfuscationBinding.BoundObfuscationConfiguration.MutationType.Drop ignored -> Optional.empty();
+            case final ItemObfuscationBinding.BoundObfuscationConfiguration.MutationType.Sanitize sanitize -> Optional.of(sanitize.sanitizer().apply(value.get()));
+            case null -> value;
+        };
+    }
+}
diff --git a/src/main/java/io/papermc/paper/util/ItemObfuscationBinding.java b/src/main/java/io/papermc/paper/util/ItemObfuscationBinding.java
new file mode 100644
index 0000000000000000000000000000000000000000..db7ac8a93b6af996ba47320fdda3606b2af8024f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/util/ItemObfuscationBinding.java
@@ -0,0 +1,133 @@
+package io.papermc.paper.util;
+
+import io.papermc.paper.configuration.GlobalConfiguration;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.UnaryOperator;
+import net.minecraft.core.component.DataComponentType;
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.item.ItemStack;
+import org.jspecify.annotations.NullMarked;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+import org.spongepowered.configurate.objectmapping.meta.Required;
+
+/**
+ * The item obfuscation binding is a state bound by the configured item obfuscation.
+ * It only hosts the bound and computed data from the global configuration.
+ */
+@NullMarked
+public final class ItemObfuscationBinding {
+
+    public final ItemObfuscationSession.ObfuscationLevel level;
+    private final BoundObfuscationConfiguration base;
+    private final Map<ResourceLocation, BoundObfuscationConfiguration> overrides;
+
+    public ItemObfuscationBinding(final GlobalConfiguration.Anticheat.Obfuscation.Items items) {
+        this.level = items.enableItemObfuscation ? ItemObfuscationSession.ObfuscationLevel.ALL : ItemObfuscationSession.ObfuscationLevel.OVERSIZED;
+        this.base = bind(items.allModels);
+        final Map<ResourceLocation, BoundObfuscationConfiguration> overrides = new HashMap<>();
+        for (final Map.Entry<ResourceLocation, AssetObfuscationConfiguration> entry : items.modelOverrides.entrySet()) {
+            overrides.put(entry.getKey(), bind(entry.getValue()));
+        }
+        this.overrides = Collections.unmodifiableMap(overrides);
+    }
+
+    public record BoundObfuscationConfiguration(boolean sanitizeCount,
+                                                Map<DataComponentType<?>, MutationType> patchStrategy) {
+
+        sealed interface MutationType permits MutationType.Drop, MutationType.Sanitize {
+            enum Drop implements MutationType {
+                INSTANCE
+            }
+
+            record Sanitize(UnaryOperator sanitizer) implements MutationType {
+
+            }
+        }
+    }
+
+    @ConfigSerializable
+    public record AssetObfuscationConfiguration(@Required boolean sanitizeCount,
+                                                Set<DataComponentType<?>> dontObfuscate,
+                                                Set<DataComponentType<?>> alsoObfuscate) {
+
+    }
+
+    private static BoundObfuscationConfiguration bind(final AssetObfuscationConfiguration config) {
+        final Set<DataComponentType<?>> base = new HashSet<>(BASE_OVERRIDERS);
+        base.addAll(config.alsoObfuscate());
+        base.removeAll(config.dontObfuscate());
+
+        final Map<DataComponentType<?>, BoundObfuscationConfiguration.MutationType> finalStrategy = new HashMap<>();
+        // Configure what path the data component should go through, should it be dropped, or should it be sanitized?
+        for (final DataComponentType<?> type : base) {
+            // We require some special logic, sanitize it rather than dropping it.
+            final UnaryOperator<?> sanitizationOverride = ItemComponentSanitizer.SANITIZATION_OVERRIDES.get(type);
+            if (sanitizationOverride != null) {
+                finalStrategy.put(type, new BoundObfuscationConfiguration.MutationType.Sanitize(sanitizationOverride));
+            } else {
+                finalStrategy.put(type, BoundObfuscationConfiguration.MutationType.Drop.INSTANCE);
+            }
+        }
+
+        return new BoundObfuscationConfiguration(config.sanitizeCount(), finalStrategy);
+    }
+
+    public BoundObfuscationConfiguration getAssetObfuscation(final ItemStack itemStack) {
+        if (this.overrides.isEmpty()) {
+            return this.base;
+        }
+        return this.overrides.getOrDefault(itemStack.get(DataComponents.ITEM_MODEL), this.base);
+    }
+
+    static final Set<DataComponentType<?>> BASE_OVERRIDERS = Set.of(
+        DataComponents.MAX_STACK_SIZE,
+        DataComponents.MAX_DAMAGE,
+        DataComponents.DAMAGE,
+        DataComponents.UNBREAKABLE,
+        DataComponents.CUSTOM_NAME,
+        DataComponents.ITEM_NAME,
+        DataComponents.LORE,
+        DataComponents.RARITY,
+        DataComponents.ENCHANTMENTS,
+        DataComponents.CAN_PLACE_ON,
+        DataComponents.CAN_BREAK,
+        DataComponents.ATTRIBUTE_MODIFIERS,
+        DataComponents.HIDE_ADDITIONAL_TOOLTIP,
+        DataComponents.HIDE_TOOLTIP,
+        DataComponents.REPAIR_COST,
+        DataComponents.USE_REMAINDER,
+        DataComponents.FOOD,
+        DataComponents.DAMAGE_RESISTANT,
+        // Not important on the player
+        DataComponents.TOOL,
+        DataComponents.ENCHANTABLE,
+        DataComponents.REPAIRABLE,
+        DataComponents.GLIDER,
+        DataComponents.TOOLTIP_STYLE,
+        DataComponents.DEATH_PROTECTION,
+        DataComponents.STORED_ENCHANTMENTS,
+        DataComponents.MAP_ID,
+        DataComponents.POTION_CONTENTS,
+        DataComponents.SUSPICIOUS_STEW_EFFECTS,
+        DataComponents.WRITABLE_BOOK_CONTENT,
+        DataComponents.WRITTEN_BOOK_CONTENT,
+        DataComponents.CUSTOM_DATA,
+        DataComponents.ENTITY_DATA,
+        DataComponents.BUCKET_ENTITY_DATA,
+        DataComponents.BLOCK_ENTITY_DATA,
+        DataComponents.INSTRUMENT,
+        DataComponents.OMINOUS_BOTTLE_AMPLIFIER,
+        DataComponents.JUKEBOX_PLAYABLE,
+        DataComponents.LODESTONE_TRACKER,
+        DataComponents.FIREWORKS,
+        DataComponents.NOTE_BLOCK_SOUND,
+        DataComponents.BEES,
+        DataComponents.LOCK,
+        DataComponents.CONTAINER_LOOT
+    );
+}
diff --git a/src/main/java/io/papermc/paper/util/ItemObfuscationSession.java b/src/main/java/io/papermc/paper/util/ItemObfuscationSession.java
new file mode 100644
index 0000000000000000000000000000000000000000..deafa923d5623665bb40d87ba81912a6b272bd38
--- /dev/null
+++ b/src/main/java/io/papermc/paper/util/ItemObfuscationSession.java
@@ -0,0 +1,114 @@
+package io.papermc.paper.util;
+
+import java.util.function.UnaryOperator;
+import com.google.common.base.Preconditions;
+import net.minecraft.world.item.ItemStack;
+import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.Nullable;
+
+/**
+ * The item obfuscation session may be started by a thread to indicate that items should be obfuscated when serialized
+ * for network usage.
+ * <p>
+ * A session is persistent throughout an entire thread and will be "activated" by passing an {@link ObfuscationContext}
+ * to start/switch context methods.
+ */
+@NullMarked
+public class ItemObfuscationSession implements SafeAutoClosable {
+
+    static final ThreadLocal<ItemObfuscationSession> THREAD_LOCAL_SESSION = ThreadLocal.withInitial(ItemObfuscationSession::new);
+
+    public static ItemObfuscationSession currentSession() {
+        return THREAD_LOCAL_SESSION.get();
+    }
+
+    /**
+     * Obfuscation level on a specific context.
+     */
+    public enum ObfuscationLevel {
+        NONE,
+        OVERSIZED,
+        ALL;
+
+        public boolean obfuscateOversized() {
+            return switch (this) {
+                case OVERSIZED, ALL -> true;
+                default -> false;
+            };
+        }
+
+        public boolean isObfuscating() {
+            return this != NONE;
+        }
+    }
+
+    public static ItemObfuscationSession start(final ObfuscationLevel level) {
+        final ItemObfuscationSession sanitizer = THREAD_LOCAL_SESSION.get();
+        sanitizer.switchContext(new ObfuscationContext(sanitizer, null, null, level));
+        return sanitizer;
+    }
+
+    /**
+     * Updates the context of the currently running session by requiring the unary operator to emit a new context
+     * based on the current one.
+     * The method expects the caller to use the withers on the context.
+     *
+     * @param contextUpdater the operator to construct the new context.
+     * @return the context callback to close once the context expires.
+     */
+    public static SafeAutoClosable withContext(final UnaryOperator<ObfuscationContext> contextUpdater) {
+        final ItemObfuscationSession session = THREAD_LOCAL_SESSION.get();
+
+        // Don't pass any context if we are not currently sanitizing
+        if (!session.obfuscationLevel().isObfuscating()) return () -> {
+        };
+
+        final ObfuscationContext newContext = contextUpdater.apply(session.context());
+        Preconditions.checkState(newContext != session.context(), "withContext yielded same context instance, this will break the stack on close");
+        session.switchContext(newContext);
+        return newContext;
+    }
+
+    private final ObfuscationContext root = new ObfuscationContext(this, null, null, ObfuscationLevel.NONE);
+    private ObfuscationContext context = root;
+
+    public void switchContext(final ObfuscationContext context) {
+        this.context = context;
+    }
+
+    public ObfuscationContext context() {
+        return this.context;
+    }
+
+    @Override
+    public void close() {
+        this.context = root;
+    }
+
+    public ObfuscationLevel obfuscationLevel() {
+        return this.context.level;
+    }
+
+    public record ObfuscationContext(
+        ItemObfuscationSession parent,
+        @Nullable ObfuscationContext previousContext,
+        @Nullable ItemStack itemStack,
+        ObfuscationLevel level
+    ) implements SafeAutoClosable {
+
+        public ObfuscationContext itemStack(final ItemStack itemStack) {
+            return new ObfuscationContext(this.parent, this, itemStack, this.level);
+        }
+
+        public ObfuscationContext level(final ObfuscationLevel obfuscationLevel) {
+            return new ObfuscationContext(this.parent, this, this.itemStack, obfuscationLevel);
+        }
+
+        @Override
+        public void close() {
+            // Restore the previous context when this context is closed.
+            this.parent().switchContext(this.previousContext);
+        }
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/util/LogManagerShutdownThread.java b/src/main/java/io/papermc/paper/util/LogManagerShutdownThread.java
index 183e141d0c13190c6905dc4510d891992afef878..3d7df554b89cff23f64da7ad48b5e4d26ac2baf7 100644
--- a/src/main/java/io/papermc/paper/util/LogManagerShutdownThread.java
+++ b/src/main/java/io/papermc/paper/util/LogManagerShutdownThread.java
@@ -1,16 +1,19 @@
 package io.papermc.paper.util;
 
-public class LogManagerShutdownThread extends Thread {
+import org.apache.logging.log4j.LogManager;
+
+public final class LogManagerShutdownThread extends Thread {
 
     static LogManagerShutdownThread INSTANCE = new LogManagerShutdownThread();
-    public static final void hook() {
+
+    public static void hook() {
         if (INSTANCE == null) {
             throw new IllegalStateException("Cannot re-hook after being unhooked");
         }
         Runtime.getRuntime().addShutdownHook(INSTANCE);
     }
 
-    public static final void unhook() {
+    public static void unhook() {
         Runtime.getRuntime().removeShutdownHook(INSTANCE);
         INSTANCE = null;
     }
@@ -21,6 +24,6 @@ public class LogManagerShutdownThread extends Thread {
 
     @Override
     public void run() {
-        org.apache.logging.log4j.LogManager.shutdown();
+        LogManager.shutdown();
     }
 }
diff --git a/src/main/java/io/papermc/paper/util/OldEnumHolderable.java b/src/main/java/io/papermc/paper/util/OldEnumHolderable.java
new file mode 100644
index 0000000000000000000000000000000000000000..0c4ddd9ea9b5359179acecaebabc3cac1be9bb8c
--- /dev/null
+++ b/src/main/java/io/papermc/paper/util/OldEnumHolderable.java
@@ -0,0 +1,92 @@
+package io.papermc.paper.util;
+
+import com.google.common.base.Preconditions;
+import java.util.Locale;
+import net.minecraft.core.Holder;
+import org.bukkit.Keyed;
+import org.bukkit.NamespacedKey;
+import org.bukkit.util.OldEnum;
+import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.Nullable;
+
+@SuppressWarnings({"removal", "DeprecatedIsStillUsed"})
+@Deprecated
+@NullMarked
+public abstract class OldEnumHolderable<A extends OldEnum<A>, M> implements Holderable<M>, OldEnum<A>, Keyed {
+
+    private final Holder<M> holder;
+    private final int ordinal;
+    private final @Nullable String name;
+
+    protected OldEnumHolderable(final Holder<M> holder, final int ordinal) {
+        this.holder = holder;
+        this.ordinal = ordinal;
+        if (holder instanceof final Holder.Reference<M> reference) {
+            // For backwards compatibility, minecraft values will stile return the uppercase name without the namespace,
+            // in case plugins use for example the name as key in a config file to receive registry item specific values.
+            // Custom registry items will return the key with namespace. For a plugin this should look than like a new registry item
+            // (which can always be added in new minecraft versions and the plugin should therefore handle it accordingly).
+            if (NamespacedKey.MINECRAFT.equals(reference.key().location().getNamespace())) {
+                this.name = reference.key().location().getPath().toUpperCase(Locale.ROOT);
+            } else {
+                this.name = reference.key().location().toString();
+            }
+        } else {
+            this.name = null;
+        }
+    }
+
+    @Override
+    public Holder<M> getHolder() {
+        return this.holder;
+    }
+
+    @Override
+    @Deprecated
+    public int compareTo(final A other) {
+        this.checkIsReference();
+        return this.ordinal - other.ordinal();
+    }
+
+    @Override
+    @Deprecated
+    public String name() {
+        this.checkIsReference();
+        return this.name;
+    }
+
+    @Override
+    @Deprecated
+    public int ordinal() {
+        this.checkIsReference();
+        return this.ordinal;
+    }
+
+    private void checkIsReference() {
+        Preconditions.checkState(this.holder.kind() == Holder.Kind.REFERENCE, "Cannot call method for this registry item, because it is not registered.");
+    }
+
+    @Override
+    public NamespacedKey getKey() {
+        return MCUtil.fromResourceKey(this.holder.unwrapKey().orElseThrow(() -> new IllegalStateException("Cannot get key for this registry item, because it is not registered.")));
+    }
+
+    @Override
+    public boolean equals(final Object obj) {
+        return this.implEquals(obj);
+    }
+
+    @Override
+    public int hashCode() {
+        return this.implHashCode();
+    }
+
+    @Override
+    public String toString() {
+        if (this.name != null) {
+            // TODO remove in next feature release or 1.22
+            return this.name;
+        }
+        return this.implToString();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/util/OversizedItemComponentSanitizer.java b/src/main/java/io/papermc/paper/util/OversizedItemComponentSanitizer.java
new file mode 100644
index 0000000000000000000000000000000000000000..fc20f3f61b2fc1e0d5ab7ed327b941f82d22ebdf
--- /dev/null
+++ b/src/main/java/io/papermc/paper/util/OversizedItemComponentSanitizer.java
@@ -0,0 +1,105 @@
+package io.papermc.paper.util;
+
+import it.unimi.dsi.fastutil.objects.ObjectArrayList;
+import java.util.List;
+import java.util.function.UnaryOperator;
+import net.minecraft.network.RegistryFriendlyByteBuf;
+import net.minecraft.network.codec.StreamCodec;
+import net.minecraft.util.Mth;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.item.component.BundleContents;
+import net.minecraft.world.item.component.ChargedProjectiles;
+import net.minecraft.world.item.component.ItemContainerContents;
+import org.checkerframework.checker.nullness.qual.NonNull;
+
+public final class OversizedItemComponentSanitizer {
+
+    /*
+    These represent codecs that are meant to help get rid of possibly big items by ALWAYS hiding this data.
+     */
+    public static final StreamCodec<RegistryFriendlyByteBuf, ChargedProjectiles> CHARGED_PROJECTILES = codec(ChargedProjectiles.STREAM_CODEC, OversizedItemComponentSanitizer::sanitizeChargedProjectiles);
+    public static final StreamCodec<RegistryFriendlyByteBuf, ItemContainerContents> CONTAINER = codec(ItemContainerContents.STREAM_CODEC, contents -> ItemContainerContents.EMPTY);
+    public static final StreamCodec<RegistryFriendlyByteBuf, BundleContents> BUNDLE_CONTENTS = new StreamCodec<>() {
+        @Override
+        public BundleContents decode(final RegistryFriendlyByteBuf buffer) {
+            return BundleContents.STREAM_CODEC.decode(buffer);
+        }
+
+        @Override
+        public void encode(final RegistryFriendlyByteBuf buffer, final BundleContents value) {
+            if (!ItemObfuscationSession.currentSession().obfuscationLevel().obfuscateOversized()) {
+                BundleContents.STREAM_CODEC.encode(buffer, value);
+                return;
+            }
+
+            // Disable further obfuscation to skip e.g. count.
+            try (final SafeAutoClosable ignored = ItemObfuscationSession.withContext(c -> c.level(ItemObfuscationSession.ObfuscationLevel.OVERSIZED))){
+                BundleContents.STREAM_CODEC.encode(buffer, sanitizeBundleContents(value));
+            }
+        }
+    };
+
+    private static <B, A> StreamCodec<B, A> codec(final StreamCodec<B, A> delegate, final UnaryOperator<A> sanitizer) {
+        return new DataSanitizationCodec<>(delegate, sanitizer);
+    }
+
+    private static ChargedProjectiles sanitizeChargedProjectiles(final ChargedProjectiles projectiles) {
+        if (projectiles.isEmpty()) {
+            return projectiles;
+        }
+
+        return ChargedProjectiles.of(List.of(
+            new ItemStack(
+                projectiles.contains(Items.FIREWORK_ROCKET)
+                    ? Items.FIREWORK_ROCKET
+                    : Items.ARROW
+            )));
+    }
+
+    // Although bundles no longer change their size based on fullness, fullness is exposed in item models.
+    private static BundleContents sanitizeBundleContents(final BundleContents contents) {
+        if (contents.isEmpty()) {
+            return contents;
+        }
+
+        // A bundles content weight may be anywhere from 0 to, basically, infinity.
+        // A weight of 1 is the usual maximum case
+        int sizeUsed = Mth.mulAndTruncate(contents.weight(), 64);
+        // Early out, *most* bundles should not be overfilled above a weight of one.
+        if (sizeUsed <= 64) {
+            return new BundleContents(List.of(new ItemStack(Items.PAPER, Math.max(1, sizeUsed))));
+        }
+
+        final List<ItemStack> sanitizedRepresentation = new ObjectArrayList<>(sizeUsed / 64 + 1);
+        while (sizeUsed > 0) {
+            final int stackCount = Math.min(64, sizeUsed);
+            sanitizedRepresentation.add(new ItemStack(Items.PAPER, stackCount));
+            sizeUsed -= stackCount;
+        }
+        // Now we add a single fake item that uses the same amount of slots as all other items.
+        // Ensure that potentially overstacked bundles are not represented by empty (count=0) itemstacks.
+        return new BundleContents(sanitizedRepresentation);
+    }
+
+    // Codec used to override encoding if sanitization is enabled
+    private record DataSanitizationCodec<B, A>(StreamCodec<B, A> delegate,
+                                               UnaryOperator<A> sanitizer) implements StreamCodec<B, A> {
+
+        @Override
+        public @NonNull A decode(final @NonNull B buf) {
+            return this.delegate.decode(buf);
+        }
+
+        @SuppressWarnings("resource")
+        @Override
+        public void encode(final @NonNull B buf, final @NonNull A value) {
+            if (!ItemObfuscationSession.currentSession().obfuscationLevel().obfuscateOversized()) {
+                this.delegate.encode(buf, value);
+            } else {
+                this.delegate.encode(buf, this.sanitizer.apply(value));
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/util/SafeAutoClosable.java b/src/main/java/io/papermc/paper/util/SafeAutoClosable.java
new file mode 100644
index 0000000000000000000000000000000000000000..4bc1c5853cec9efa93fb9926964f4880bb5d102a
--- /dev/null
+++ b/src/main/java/io/papermc/paper/util/SafeAutoClosable.java
@@ -0,0 +1,10 @@
+package io.papermc.paper.util;
+
+/**
+ * A type of {@link AutoCloseable} that does not throw a checked exception.
+ */
+public interface SafeAutoClosable extends AutoCloseable {
+
+    @Override
+    void close();
+}
diff --git a/src/main/java/io/papermc/paper/world/worldgen/OptionallyFlatBedrockConditionSource.java b/src/main/java/io/papermc/paper/world/worldgen/OptionallyFlatBedrockConditionSource.java
index b5580727eef106fa193e450038d1b20d8d396059..60b6e040df57c11b7b66b7e0ef81b4b5c5e5e571 100644
--- a/src/main/java/io/papermc/paper/world/worldgen/OptionallyFlatBedrockConditionSource.java
+++ b/src/main/java/io/papermc/paper/world/worldgen/OptionallyFlatBedrockConditionSource.java
@@ -18,6 +18,7 @@ import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.framework.qual.DefaultQualifier;
 
 // Modelled off of SurfaceRules$VerticalGradientConditionSource
+// Flat bedrock generator settings
 @DefaultQualifier(NonNull.class)
 public record OptionallyFlatBedrockConditionSource(ResourceLocation randomName, VerticalAnchor trueAtAndBelow, VerticalAnchor falseAtAndAbove, boolean isRoof) implements SurfaceRules.ConditionSource {
 
@@ -45,7 +46,7 @@ public record OptionallyFlatBedrockConditionSource(ResourceLocation randomName,
 
     @Override
     public SurfaceRules.Condition apply(final SurfaceRules.Context context) {
-        boolean hasFlatBedrock = context.context.getWorld().paperConfig().environment.generateFlatBedrock;
+        boolean hasFlatBedrock = context.context.level().paperConfig().environment.generateFlatBedrock;
         int tempTrueAtAndBelowY = this.trueAtAndBelow().resolveY(context.context);
         int tempFalseAtAndAboveY = this.falseAtAndAbove().resolveY(context.context);
 
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftArt.java b/src/main/java/org/bukkit/craftbukkit/CraftArt.java
index 0207c7c50706cf490d652f4f519d059f7453180f..b784da2a5cd819bb944bb87fad64a1ecf182c46d 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftArt.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftArt.java
@@ -1,26 +1,23 @@
 package org.bukkit.craftbukkit;
 
-import com.google.common.base.Preconditions;
-import java.util.Locale;
+import io.papermc.paper.adventure.PaperAdventure;
+import io.papermc.paper.util.OldEnumHolderable;
+import net.kyori.adventure.text.Component;
 import net.minecraft.core.Holder;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.world.entity.decoration.PaintingVariant;
 import org.bukkit.Art;
-import org.bukkit.NamespacedKey;
-import org.bukkit.Registry;
-import org.bukkit.craftbukkit.util.Handleable;
-import org.jetbrains.annotations.NotNull;
 
-public class CraftArt implements Art, Handleable<PaintingVariant> {
+public class CraftArt extends OldEnumHolderable<Art, PaintingVariant> implements Art {
 
     private static int count = 0;
 
     public static Art minecraftToBukkit(PaintingVariant minecraft) {
-        return CraftRegistry.minecraftToBukkit(minecraft, Registries.PAINTING_VARIANT, Registry.ART);
+        return CraftRegistry.minecraftToBukkit(minecraft, Registries.PAINTING_VARIANT);
     }
 
     public static Art minecraftHolderToBukkit(Holder<PaintingVariant> minecraft) {
-        return CraftArt.minecraftToBukkit(minecraft.value());
+        return CraftRegistry.minecraftHolderToBukkit(minecraft, Registries.PAINTING_VARIANT);
     }
 
     public static PaintingVariant bukkitToMinecraft(Art bukkit) {
@@ -28,118 +25,41 @@ public class CraftArt implements Art, Handleable<PaintingVariant> {
     }
 
     public static Holder<PaintingVariant> bukkitToMinecraftHolder(Art bukkit) {
-        Preconditions.checkArgument(bukkit != null);
-
-        net.minecraft.core.Registry<PaintingVariant> registry = CraftRegistry.getMinecraftRegistry(Registries.PAINTING_VARIANT);
-
-        if (registry.wrapAsHolder(CraftArt.bukkitToMinecraft(bukkit)) instanceof Holder.Reference<PaintingVariant> holder) {
-            return holder;
-        }
-
-        throw new IllegalArgumentException("No Reference holder found for " + bukkit
-                + ", this can happen if a plugin creates its own painting variant with out properly registering it.");
-    }
-
-    private final NamespacedKey key;
-    private final PaintingVariant paintingVariant;
-    private final String name;
-    private final int ordinal;
-
-    public CraftArt(NamespacedKey key, PaintingVariant paintingVariant) {
-        this.key = key;
-        this.paintingVariant = paintingVariant;
-        // For backwards compatibility, minecraft values will stile return the uppercase name without the namespace,
-        // in case plugins use for example the name as key in a config file to receive art specific values.
-        // Custom arts will return the key with namespace. For a plugin this should look than like a new art
-        // (which can always be added in new minecraft versions and the plugin should therefore handle it accordingly).
-        if (NamespacedKey.MINECRAFT.equals(key.getNamespace())) {
-            this.name = key.getKey().toUpperCase(Locale.ROOT);
-        } else {
-            this.name = key.toString();
-        }
-        this.ordinal = CraftArt.count++;
+        return CraftRegistry.bukkitToMinecraftHolder(bukkit, Registries.PAINTING_VARIANT);
     }
 
-    @Override
-    public PaintingVariant getHandle() {
-        return this.paintingVariant;
+    public CraftArt(Holder<PaintingVariant> paintingVariant) {
+        super(paintingVariant, count++);
     }
 
     @Override
     public int getBlockWidth() {
-        return this.paintingVariant.width();
+        return this.getHandle().width();
     }
 
     @Override
     public int getBlockHeight() {
-        return this.paintingVariant.height();
+        return this.getHandle().height();
     }
 
     // Paper start - Expand Art API
     @Override
-    public net.kyori.adventure.text.Component title() {
-        return this.paintingVariant.title().map(io.papermc.paper.adventure.PaperAdventure::asAdventure).orElse(null);
+    public Component title() {
+        return this.getHandle().title().map(PaperAdventure::asAdventure).orElse(null);
     }
 
     @Override
     public net.kyori.adventure.text.Component author() {
-        return this.paintingVariant.author().map(io.papermc.paper.adventure.PaperAdventure::asAdventure).orElse(null);
+        return this.getHandle().author().map(PaperAdventure::asAdventure).orElse(null);
     }
 
     public net.kyori.adventure.key.Key assetId() {
-        return io.papermc.paper.adventure.PaperAdventure.asAdventure(this.paintingVariant.assetId());
+        return PaperAdventure.asAdventure(this.getHandle().assetId());
     }
     // Paper end - Expand Art API
 
     @Override
     public int getId() {
-        return CraftRegistry.getMinecraftRegistry(Registries.PAINTING_VARIANT).getId(this.paintingVariant);
-    }
-
-    @NotNull
-    @Override
-    public NamespacedKey getKey() {
-        if (true) return java.util.Objects.requireNonNull(org.bukkit.Registry.ART.getKey(this), () -> this + " doesn't have a key"); // Paper
-        return this.key;
-    }
-
-    @Override
-    public int compareTo(@NotNull Art art) {
-        return this.ordinal - art.ordinal();
-    }
-
-    @NotNull
-    @Override
-    public String name() {
-        return this.name;
-    }
-
-    @Override
-    public int ordinal() {
-        return this.ordinal;
-    }
-
-    @Override
-    public String toString() {
-        // For backwards compatibility
-        return this.name();
-    }
-
-    @Override
-    public boolean equals(Object other) {
-        if (this == other) {
-            return true;
-        }
-
-        if (!(other instanceof CraftArt otherArt)) {
-            return false;
-        }
-
-        return this.getKey().equals(otherArt.getKey());
-    }
-
-    @Override
-    public int hashCode() {
-        return this.getKey().hashCode();
+        return CraftRegistry.getMinecraftRegistry(Registries.PAINTING_VARIANT).getId(this.getHandle());
     }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
index c2bffe3450ee9f768e00a23ec09df74d7a06d49b..de8b9048c8395c05b8688bc9d984b8ad680f15b3 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
@@ -83,12 +83,12 @@ public class CraftChunk implements Chunk {
     }
 
     public ChunkAccess getHandle(ChunkStatus chunkStatus) {
-        // Paper start - rewrite chunk system
+        // Paper start - chunk system
         net.minecraft.world.level.chunk.LevelChunk full = this.worldServer.getChunkIfLoaded(this.x, this.z);
         if (full != null) {
             return full;
         }
-        // Paper end - rewrite chunk system
+        // Paper end - chunk system
         ChunkAccess chunkAccess = this.worldServer.getChunk(this.x, this.z, chunkStatus);
 
         // SPIGOT-7332: Get unwrapped extension
@@ -123,12 +123,12 @@ public class CraftChunk implements Chunk {
 
     @Override
     public boolean isEntitiesLoaded() {
-        return this.getCraftWorld().getHandle().areEntitiesLoaded(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(this.x, this.z)); // Paper - rewrite chunk system
+        return this.getCraftWorld().getHandle().areEntitiesLoaded(ChunkPos.asLong(this.x, this.z)); // Paper - chunk system
     }
 
     @Override
     public Entity[] getEntities() {
-        return this.getCraftWorld().getHandle().getChunkEntities(this.x, this.z); // Paper - rewrite chunk system
+        return FeatureHooks.getChunkEntities(this.worldServer, this.x, this.z); // Paper - chunk system
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftFluid.java b/src/main/java/org/bukkit/craftbukkit/CraftFluid.java
index 6cbd9d313d26bd443893db225858b557de96ab54..f01fadad746a792c239e0dc8dbabe0e0b0613119 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftFluid.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftFluid.java
@@ -4,7 +4,6 @@ import java.util.Locale;
 import net.minecraft.core.registries.Registries;
 import org.bukkit.Fluid;
 import org.bukkit.NamespacedKey;
-import org.bukkit.Registry;
 import org.bukkit.craftbukkit.util.Handleable;
 import org.jetbrains.annotations.NotNull;
 
@@ -13,7 +12,7 @@ public class CraftFluid implements Fluid, Handleable<net.minecraft.world.level.m
     private static int count = 0;
 
     public static Fluid minecraftToBukkit(net.minecraft.world.level.material.Fluid minecraft) {
-        return CraftRegistry.minecraftToBukkit(minecraft, Registries.FLUID, Registry.FLUID);
+        return CraftRegistry.minecraftToBukkit(minecraft, Registries.FLUID);
     }
 
     public static net.minecraft.world.level.material.Fluid bukkitToMinecraft(Fluid bukkit) {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftGameEvent.java b/src/main/java/org/bukkit/craftbukkit/CraftGameEvent.java
index ea9fe1f8b1a1685ea975eba0ca418a831006065a..a95033ff27570a3a7aa929d810f756ea2f5d2d40 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftGameEvent.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftGameEvent.java
@@ -3,14 +3,13 @@ package org.bukkit.craftbukkit;
 import net.minecraft.core.registries.Registries;
 import org.bukkit.GameEvent;
 import org.bukkit.NamespacedKey;
-import org.bukkit.Registry;
 import org.bukkit.craftbukkit.util.Handleable;
 import org.jetbrains.annotations.NotNull;
 
 public class CraftGameEvent extends GameEvent implements Handleable<net.minecraft.world.level.gameevent.GameEvent> {
 
     public static GameEvent minecraftToBukkit(net.minecraft.world.level.gameevent.GameEvent minecraft) {
-        return CraftRegistry.minecraftToBukkit(minecraft, Registries.GAME_EVENT, Registry.GAME_EVENT);
+        return CraftRegistry.minecraftToBukkit(minecraft, Registries.GAME_EVENT);
     }
 
     public static net.minecraft.world.level.gameevent.GameEvent bukkitToMinecraft(GameEvent bukkit) {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftJukeboxSong.java b/src/main/java/org/bukkit/craftbukkit/CraftJukeboxSong.java
index 2772c19f58a35713d61aab24f6f0d6f5070153c6..e75c045e338aa88d081feab36130679f167af476 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftJukeboxSong.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftJukeboxSong.java
@@ -6,14 +6,13 @@ import net.minecraft.core.registries.Registries;
 import net.minecraft.network.chat.contents.TranslatableContents;
 import org.bukkit.JukeboxSong;
 import org.bukkit.NamespacedKey;
-import org.bukkit.Registry;
 import org.bukkit.craftbukkit.util.Handleable;
 import org.jetbrains.annotations.NotNull;
 
 public class CraftJukeboxSong implements JukeboxSong, Handleable<net.minecraft.world.item.JukeboxSong> {
 
     public static JukeboxSong minecraftToBukkit(net.minecraft.world.item.JukeboxSong minecraft) {
-        return CraftRegistry.minecraftToBukkit(minecraft, Registries.JUKEBOX_SONG, Registry.JUKEBOX_SONG);
+        return CraftRegistry.minecraftToBukkit(minecraft, Registries.JUKEBOX_SONG);
     }
 
     public static JukeboxSong minecraftHolderToBukkit(Holder<net.minecraft.world.item.JukeboxSong> minecraft) {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftMusicInstrument.java b/src/main/java/org/bukkit/craftbukkit/CraftMusicInstrument.java
index aa19ac75135893b81000d1bd63795457a777e9eb..26a93c4f257ab2d871dc4b03bf27124a6db2ce79 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftMusicInstrument.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftMusicInstrument.java
@@ -1,23 +1,24 @@
 package org.bukkit.craftbukkit;
 
 import com.google.common.base.Preconditions;
+import io.papermc.paper.registry.RegistryKey;
+import io.papermc.paper.util.Holderable;
 import net.minecraft.core.Holder;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.world.item.Instrument;
 import org.bukkit.MusicInstrument;
 import org.bukkit.NamespacedKey;
 import org.bukkit.Registry;
-import org.bukkit.craftbukkit.util.Handleable;
 import org.jetbrains.annotations.NotNull;
 
 public class CraftMusicInstrument extends MusicInstrument implements io.papermc.paper.util.Holderable<Instrument> {
 
     public static MusicInstrument minecraftToBukkit(Instrument minecraft) {
-        return CraftRegistry.minecraftToBukkit(minecraft, Registries.INSTRUMENT, Registry.INSTRUMENT);
+        return CraftRegistry.minecraftToBukkit(minecraft, Registries.INSTRUMENT);
     }
 
     public static MusicInstrument minecraftHolderToBukkit(Holder<Instrument> minecraft) {
-        return CraftRegistry.minecraftHolderToBukkit(minecraft, Registry.INSTRUMENT); // Paper - switch to Holder
+        return CraftRegistry.minecraftHolderToBukkit(minecraft, Registries.INSTRUMENT); // Paper - switch to Holder
     }
 
     public static Instrument bukkitToMinecraft(MusicInstrument bukkit) {
@@ -31,18 +32,15 @@ public class CraftMusicInstrument extends MusicInstrument implements io.papermc.
     public static Object bukkitToString(MusicInstrument bukkit) { // Paper - switch to Holder
         Preconditions.checkArgument(bukkit != null);
 
-        return ((CraftMusicInstrument) bukkit).toBukkitSerializationObject(Instrument.CODEC); // Paper - switch to Holder
+        return ((CraftMusicInstrument) bukkit).toBukkitSerializationObject(Instrument.DIRECT_CODEC); // Paper - switch to Holder
     }
 
     public static MusicInstrument stringToBukkit(Object string) { // Paper - switch to Holder
         Preconditions.checkArgument(string != null);
 
-        return io.papermc.paper.util.Holderable.fromBukkitSerializationObject(string, Instrument.CODEC, Registry.INSTRUMENT); // Paper - switch to Holder
+        return io.papermc.paper.util.Holderable.fromBukkitSerializationObject(string, Instrument.CODEC, RegistryKey.INSTRUMENT); // Paper - switch to Holder
     }
 
-    private final NamespacedKey key;
-    private final Instrument handle;
-
     // Paper start - switch to Holder
     @Override
     public boolean equals(final Object o) {
@@ -62,8 +60,6 @@ public class CraftMusicInstrument extends MusicInstrument implements io.papermc.
     private final Holder<Instrument> holder;
     public CraftMusicInstrument(Holder<Instrument> holder) {
         this.holder = holder;
-        this.key = holder.unwrapKey().map(io.papermc.paper.util.MCUtil::fromResourceKey).orElse(null);
-        this.handle = holder.value();
         // Paper end - switch to Holder
     }
 
@@ -75,8 +71,7 @@ public class CraftMusicInstrument extends MusicInstrument implements io.papermc.
     @NotNull
     @Override
     public NamespacedKey getKey() {
-        if (true) return java.util.Objects.requireNonNull(org.bukkit.Registry.INSTRUMENT.getKey(this), () -> this + " doesn't have a key"); // Paper
-        return this.key;
+        return Holderable.super.getKey();
     }
 
     // Paper start - add translationKey methods
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftRegistry.java b/src/main/java/org/bukkit/craftbukkit/CraftRegistry.java
index a7e745bc137910d02e4f93a601575ebd5cfb57cc..2de46d741928dc971dcc5ee6a5a41d5c867154c8 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftRegistry.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftRegistry.java
@@ -1,82 +1,49 @@
 package org.bukkit.craftbukkit;
 
 import com.google.common.base.Preconditions;
+import io.papermc.paper.registry.PaperRegistries;
+import io.papermc.paper.registry.RegistryAccess;
+import io.papermc.paper.registry.RegistryKey;
+import io.papermc.paper.registry.entry.RegistryEntryMeta;
+import io.papermc.paper.registry.set.NamedRegistryKeySetImpl;
+import io.papermc.paper.registry.tag.Tag;
+import io.papermc.paper.util.Holderable;
+import io.papermc.paper.util.MCUtil;
+import java.util.Collection;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
+import java.util.Optional;
 import java.util.function.BiFunction;
 import java.util.stream.Stream;
 import net.minecraft.core.Holder;
-import net.minecraft.core.RegistryAccess;
-import net.minecraft.core.registries.Registries;
+import net.minecraft.core.HolderOwner;
 import net.minecraft.resources.ResourceKey;
-import org.bukkit.Art;
-import org.bukkit.Fluid;
-import org.bukkit.GameEvent;
-import org.bukkit.JukeboxSong;
 import org.bukkit.Keyed;
-import org.bukkit.MusicInstrument;
 import org.bukkit.NamespacedKey;
 import org.bukkit.Particle;
 import org.bukkit.Registry;
-import org.bukkit.Sound;
-import org.bukkit.attribute.Attribute;
-import org.bukkit.block.Biome;
-import org.bukkit.block.BlockType;
-import org.bukkit.block.banner.PatternType;
-import org.bukkit.craftbukkit.attribute.CraftAttribute;
-import org.bukkit.craftbukkit.block.CraftBiome;
-import org.bukkit.craftbukkit.block.CraftBlockType;
-import org.bukkit.craftbukkit.block.banner.CraftPatternType;
-import org.bukkit.craftbukkit.damage.CraftDamageType;
-import org.bukkit.craftbukkit.enchantments.CraftEnchantment;
-import org.bukkit.craftbukkit.entity.CraftCat;
-import org.bukkit.craftbukkit.entity.CraftFrog;
-import org.bukkit.craftbukkit.entity.CraftVillager;
-import org.bukkit.craftbukkit.entity.CraftWolf;
-import org.bukkit.craftbukkit.generator.structure.CraftStructure;
-import org.bukkit.craftbukkit.generator.structure.CraftStructureType;
-import org.bukkit.craftbukkit.inventory.CraftItemType;
-import org.bukkit.craftbukkit.inventory.CraftMenuType;
-import org.bukkit.craftbukkit.inventory.trim.CraftTrimMaterial;
-import org.bukkit.craftbukkit.inventory.trim.CraftTrimPattern;
 import org.bukkit.craftbukkit.legacy.FieldRename;
-import org.bukkit.craftbukkit.map.CraftMapCursor;
-import org.bukkit.craftbukkit.potion.CraftPotionEffectType;
 import org.bukkit.craftbukkit.util.ApiVersion;
 import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.craftbukkit.util.Handleable;
-import org.bukkit.damage.DamageType;
-import org.bukkit.enchantments.Enchantment;
-import org.bukkit.entity.Cat;
 import org.bukkit.entity.EntityType;
-import org.bukkit.entity.Frog;
-import org.bukkit.entity.Villager;
-import org.bukkit.entity.Wolf;
-import org.bukkit.generator.structure.Structure;
-import org.bukkit.generator.structure.StructureType;
-import org.bukkit.inventory.ItemType;
-import org.bukkit.inventory.MenuType;
-import org.bukkit.inventory.meta.trim.TrimMaterial;
-import org.bukkit.inventory.meta.trim.TrimPattern;
-import org.bukkit.map.MapCursor;
-import org.bukkit.potion.PotionEffectType;
 import org.jetbrains.annotations.NotNull;
 
 public class CraftRegistry<B extends Keyed, M> implements Registry<B> {
 
-    private static RegistryAccess registry;
+    private static net.minecraft.core.RegistryAccess registry;
 
-    public static void setMinecraftRegistry(RegistryAccess registry) {
+    public static void setMinecraftRegistry(final net.minecraft.core.RegistryAccess registry) {
         Preconditions.checkState(CraftRegistry.registry == null, "Registry already set");
         CraftRegistry.registry = registry;
     }
 
-    public static RegistryAccess getMinecraftRegistry() {
+    public static net.minecraft.core.RegistryAccess getMinecraftRegistry() {
         return CraftRegistry.registry;
     }
 
-    public static <E> net.minecraft.core.Registry<E> getMinecraftRegistry(ResourceKey<net.minecraft.core.Registry<E>> key) {
+    public static <E> net.minecraft.core.Registry<E> getMinecraftRegistry(ResourceKey<? extends net.minecraft.core.Registry<E>> key) {
         return CraftRegistry.getMinecraftRegistry().lookupOrThrow(key);
     }
 
@@ -84,49 +51,46 @@ public class CraftRegistry<B extends Keyed, M> implements Registry<B> {
      * Usage note: Only use this method to delegate the conversion methods from the individual Craft classes to here.
      * Do not use it in other parts of CraftBukkit, use the methods in the respective Craft classes instead.
      *
-     * @param minecraft the minecraft representation
+     * @param minecraft   the minecraft representation
      * @param registryKey the registry key of the minecraft registry to use
-     * @param bukkitRegistry the bukkit registry to use
      * @return the bukkit representation of the minecraft value
      */
-    public static <B extends Keyed, M> B minecraftToBukkit(M minecraft, ResourceKey<net.minecraft.core.Registry<M>> registryKey, Registry<B> bukkitRegistry) {
+    public static <B extends Keyed, M> B minecraftToBukkit(M minecraft, ResourceKey<? extends net.minecraft.core.Registry<M>> registryKey) {
         Preconditions.checkArgument(minecraft != null);
 
         net.minecraft.core.Registry<M> registry = CraftRegistry.getMinecraftRegistry(registryKey);
-        // Paper start - support direct Holders
+        final Registry<B> bukkitRegistry = RegistryAccess.registryAccess().getRegistry(PaperRegistries.registryFromNms(registryKey));
         final java.util.Optional<ResourceKey<M>> resourceKey = registry.getResourceKey(minecraft);
         if (resourceKey.isEmpty() && bukkitRegistry instanceof final CraftRegistry<?, ?> craftRegistry && craftRegistry.supportsDirectHolders()) {
-            return ((CraftRegistry<B, M>) registry).convertDirectHolder(Holder.direct(minecraft));
+            return ((CraftRegistry<B, M>) bukkitRegistry).createBukkit(Holder.direct(minecraft));
         } else if (resourceKey.isEmpty()) {
             throw new IllegalStateException(String.format("Cannot convert '%s' to bukkit representation, since it is not registered.", minecraft));
         }
         final B bukkit = bukkitRegistry.get(CraftNamespacedKey.fromMinecraft(resourceKey.get().location()));
-        // Paper end - support direct Holders
 
         Preconditions.checkArgument(bukkit != null);
 
         return bukkit;
     }
 
-    // Paper start - support direct Holders
-    public static <B extends Keyed, M> B minecraftHolderToBukkit(final Holder<M> minecraft, final Registry<B> bukkitRegistry) {
+    public static <B extends Keyed, M> B minecraftHolderToBukkit(final Holder<M> minecraft, final ResourceKey<? extends net.minecraft.core.Registry<M>> registryKey) {
         Preconditions.checkArgument(minecraft != null);
 
+        final Registry<B> bukkitRegistry = RegistryAccess.registryAccess().getRegistry(PaperRegistries.registryFromNms(registryKey));
         final B bukkit = switch (minecraft) {
             case final Holder.Direct<M> direct -> {
                 if (!(bukkitRegistry instanceof final CraftRegistry<?, ?> craftRegistry) || !craftRegistry.supportsDirectHolders()) {
                     throw new IllegalArgumentException("Cannot convert direct holder to bukkit representation");
                 }
-                yield ((CraftRegistry<B, M>) bukkitRegistry).convertDirectHolder(direct);
+                yield ((CraftRegistry<B, M>) bukkitRegistry).createBukkit(direct);
             }
-            case final Holder.Reference<M> reference -> bukkitRegistry.get(io.papermc.paper.util.MCUtil.fromResourceKey(reference.key()));
+            case final Holder.Reference<M> reference -> bukkitRegistry.get(MCUtil.fromResourceKey(reference.key()));
             default -> throw new IllegalArgumentException("Unknown holder: " + minecraft);
         };
         Preconditions.checkArgument(bukkit != null);
 
         return bukkit;
     }
-    // Paper end - support direct Holders
 
     /**
      * Usage note: Only use this method to delegate the conversion methods from the individual Craft classes to here.
@@ -160,13 +124,10 @@ public class CraftRegistry<B extends Keyed, M> implements Registry<B> {
     }
 
     // Paper start - fixup upstream being dum
-    public static <T extends org.bukkit.Keyed, M> java.util.Optional<T> unwrapAndConvertHolder(final io.papermc.paper.registry.RegistryKey<T> registryKey, final Holder<M> value) {
-        return unwrapAndConvertHolder(io.papermc.paper.registry.RegistryAccess.registryAccess().getRegistry(registryKey), value);
-    }
-
-    public static <T extends org.bukkit.Keyed, M> java.util.Optional<T> unwrapAndConvertHolder(final Registry<T> registry, final Holder<M> value) {
-        if (registry instanceof CraftRegistry<?,?> craftRegistry && craftRegistry.supportsDirectHolders() && value.kind() == Holder.Kind.DIRECT) {
-            return java.util.Optional.of(((CraftRegistry<T, M>) registry).convertDirectHolder(value));
+    public static <T extends Keyed, M> Optional<T> unwrapAndConvertHolder(final RegistryKey<T> registryKey, final Holder<M> value) {
+        final Registry<T> registry = RegistryAccess.registryAccess().getRegistry(registryKey);
+        if (registry instanceof final CraftRegistry<?,?> craftRegistry && craftRegistry.supportsDirectHolders() && value.kind() == Holder.Kind.DIRECT) {
+            return Optional.of(((CraftRegistry<T, M>) registry).createBukkit(value));
         }
         return value.unwrapKey().map(key -> registry.get(CraftNamespacedKey.fromMinecraft(key.location())));
     }
@@ -175,7 +136,8 @@ public class CraftRegistry<B extends Keyed, M> implements Registry<B> {
     // Paper - move to PaperRegistries
 
     // Paper - NOTE: As long as all uses of the method below relate to *serialization* via ConfigurationSerializable, it's fine
-    public static <B extends Keyed> B get(Registry<B> bukkit, NamespacedKey namespacedKey, ApiVersion apiVersion) {
+    public static <B extends Keyed> B get(RegistryKey<B> bukkitKey, NamespacedKey namespacedKey, ApiVersion apiVersion) {
+        final Registry<B> bukkit = RegistryAccess.registryAccess().getRegistry(bukkitKey);
         if (bukkit instanceof CraftRegistry<B, ?> craft) {
             return craft.get(craft.serializationUpdater.apply(namespacedKey, apiVersion)); // Paper
         }
@@ -197,22 +159,41 @@ public class CraftRegistry<B extends Keyed, M> implements Registry<B> {
 
     private final Class<?> bukkitClass; // Paper - relax preload class
     private final Map<NamespacedKey, B> cache = new HashMap<>();
-    private final Map<B, NamespacedKey> byValue = new java.util.IdentityHashMap<>(); // Paper - improve Registry
     private final net.minecraft.core.Registry<M> minecraftRegistry;
     private final io.papermc.paper.registry.entry.RegistryTypeMapper<M, B> minecraftToBukkit; // Paper - switch to Holder
     private final BiFunction<NamespacedKey, ApiVersion, NamespacedKey> serializationUpdater; // Paper - rename to make it *clear* what it is *only* for
-    private boolean init;
+    private final InvalidHolderOwner invalidHolderOwner = new InvalidHolderOwner();
+    private boolean lockReferenceHolders;
 
     public CraftRegistry(Class<?> bukkitClass, net.minecraft.core.Registry<M> minecraftRegistry, BiFunction<? super NamespacedKey, M, B> minecraftToBukkit, BiFunction<NamespacedKey, ApiVersion, NamespacedKey> serializationUpdater) { // Paper - relax preload class
         // Paper start - switch to Holder
         this(bukkitClass, minecraftRegistry, new io.papermc.paper.registry.entry.RegistryTypeMapper<>(minecraftToBukkit), serializationUpdater);
     }
+    public CraftRegistry(final RegistryEntryMeta.ServerSide<M, B> meta, final net.minecraft.core.Registry<M> minecraftRegistry) {
+        this(meta.classToPreload(), minecraftRegistry, meta.registryTypeMapper(), meta.serializationUpdater());
+    }
     public CraftRegistry(Class<?> bukkitClass, net.minecraft.core.Registry<M> minecraftRegistry, io.papermc.paper.registry.entry.RegistryTypeMapper<M, B> minecraftToBukkit, BiFunction<NamespacedKey, ApiVersion, NamespacedKey> serializationUpdater) { // Paper - relax preload class
         // Paper end - support Holders
         this.bukkitClass = bukkitClass;
         this.minecraftRegistry = minecraftRegistry;
         this.minecraftToBukkit = minecraftToBukkit;
         this.serializationUpdater = serializationUpdater;
+        this.lockReferenceHolders = !this.minecraftToBukkit.constructorUsesHolder();
+    }
+
+    public void lockReferenceHolders() {
+        Preconditions.checkState(this.cache.isEmpty(), "Registry %s is already loaded", this.minecraftRegistry.key());
+
+        try {
+            Class.forName(this.bukkitClass.getName()); // this should always trigger the initialization of the class
+        } catch (final ClassNotFoundException e) {
+            throw new IllegalStateException("Failed to load class " + this.bukkitClass.getSimpleName(), e);
+        }
+        if (!this.minecraftToBukkit.constructorUsesHolder()) {
+            return;
+        }
+        Preconditions.checkState(!this.lockReferenceHolders, "Reference holders are already locked");
+        this.lockReferenceHolders = true;
     }
 
     // Paper - inline into CraftRegistry#get(Registry, NamespacedKey, ApiVersion) above
@@ -224,48 +205,28 @@ public class CraftRegistry<B extends Keyed, M> implements Registry<B> {
             return cached;
         }
 
-        // Make sure that the bukkit class is loaded before creating an instance.
-        // This ensures that only one instance with a given key is created.
-        //
-        // Without this code (when bukkit class is not loaded):
-        // Registry#get -> #createBukkit -> (load class -> create default) -> put in cache
-        // Result: Registry#get != <bukkitClass>.<field> for possible one registry item
-        //
-        // With this code (when bukkit class is not loaded):
-        // Registry#get -> (load class -> create default) -> Registry#get -> get from cache
-        // Result: Registry#get == <bukkitClass>.<field>
-        if (!this.init) {
-            this.init = true;
-            try {
-                Class.forName(this.bukkitClass.getName());
-            } catch (ClassNotFoundException e) {
-                throw new RuntimeException("Could not load registry class " + this.bukkitClass, e);
-            }
-
-            return this.get(namespacedKey);
+        final Optional<Holder.Reference<M>> holderOptional = this.minecraftRegistry.get(CraftNamespacedKey.toMinecraft(namespacedKey));
+        final Holder.Reference<M> holder;
+        if (holderOptional.isPresent()) {
+            holder = holderOptional.get();
+        } else if (!this.lockReferenceHolders && this.minecraftToBukkit.constructorUsesHolder()) { // only works if its Holderable
+            // we lock the reference holders after the preload class has been initialized
+            // this is to support the vanilla mechanic of preventing vanilla registry entries being loaded. We need
+            // to create something to fill the API constant fields, so we create a dummy reference holder.
+            holder = Holder.Reference.createStandAlone(this.invalidHolderOwner, MCUtil.toResourceKey(this.minecraftRegistry.key(), namespacedKey));
+        } else {
+            holder = null;
         }
-
-        B bukkit = this.createBukkit(namespacedKey, this.minecraftRegistry.get(CraftNamespacedKey.toMinecraft(namespacedKey)).orElse(null)); // Paper - switch to Holder
+        final B bukkit = this.createBukkit(holder);
         if (bukkit == null) {
             return null;
         }
 
         this.cache.put(namespacedKey, bukkit);
-        this.byValue.put(bukkit, namespacedKey); // Paper - improve Registry
 
         return bukkit;
     }
 
-    @NotNull
-    @Override
-    public B getOrThrow(@NotNull NamespacedKey namespacedKey) {
-        B object = this.get(namespacedKey);
-
-        Preconditions.checkArgument(object != null, "No %s registry entry found for key %s.", this.minecraftRegistry.key(), namespacedKey);
-
-        return object;
-    }
-
     @NotNull
     @Override
     public Stream<B> stream() {
@@ -277,28 +238,25 @@ public class CraftRegistry<B extends Keyed, M> implements Registry<B> {
         return this.stream().iterator();
     }
 
-    public B createBukkit(NamespacedKey namespacedKey, Holder<M> minecraft) { // Paper - switch to Holder
+    public B createBukkit(Holder<M> minecraft) {
         if (minecraft == null) {
             return null;
         }
 
-        return this.minecraftToBukkit.createBukkit(namespacedKey, minecraft); // Paper - switch to Holder
+        return this.minecraftToBukkit.createBukkit(minecraft);
     }
 
-    // Paper start - support Direct Holders
     public boolean supportsDirectHolders() {
         return this.minecraftToBukkit.supportsDirectHolders();
     }
 
-    public B convertDirectHolder(Holder<M> holder) {
-        return this.minecraftToBukkit.convertDirectHolder(holder);
-    }
-    // Paper end - support Direct Holders
-
     // Paper start - improve Registry
     @Override
     public NamespacedKey getKey(final B value) {
-        return this.byValue.get(value);
+        if (value instanceof Holderable<?> holderable) {
+            return holderable.getKeyOrNull();
+        }
+        return value.getKey();
     }
     // Paper end - improve Registry
 
@@ -313,5 +271,13 @@ public class CraftRegistry<B extends Keyed, M> implements Registry<B> {
         final net.minecraft.core.HolderSet.Named<M> namedHolderSet = this.minecraftRegistry.get(io.papermc.paper.registry.PaperRegistries.toNms(key)).orElseThrow();
         return new io.papermc.paper.registry.set.NamedRegistryKeySetImpl<>(key, namedHolderSet);
     }
+
+    @Override
+    public Collection<Tag<B>> getTags() {
+        return this.minecraftRegistry.getTags().<Tag<B>>map(NamedRegistryKeySetImpl::new).toList();
+    }
     // Paper end - RegistrySet API
+
+    final class InvalidHolderOwner implements HolderOwner<M> {
+    }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 97b5d6ba2b19a7c730730c74175a29157aed1840..d2de789967f8f1942e91d9e4c547113a5e31382b 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -258,6 +258,7 @@ import org.bukkit.scoreboard.Criteria;
 import org.bukkit.structure.StructureManager;
 import org.bukkit.util.StringUtil;
 import org.bukkit.util.permissions.DefaultPermissions;
+import org.jetbrains.annotations.NotNull;
 import org.yaml.snakeyaml.LoaderOptions;
 import org.yaml.snakeyaml.Yaml;
 import org.yaml.snakeyaml.constructor.SafeConstructor;
@@ -883,7 +884,7 @@ public final class CraftServer implements Server {
 
     @Override
     public boolean hasWhitelist() {
-        return this.getProperties().whiteList.get();
+        return this.playerList.isUsingWhitelist();
     }
 
     // NOTE: Temporary calls through to server.properies until its replaced
@@ -904,13 +905,13 @@ public final class CraftServer implements Server {
 
     @Override
     public long getConnectionThrottle() {
-        // Spigot Start - Automatically set connection throttle for bungee configurations
+        // Spigot start - Automatically set connection throttle for bungee configurations
         if (org.spigotmc.SpigotConfig.bungee || io.papermc.paper.configuration.GlobalConfiguration.get().proxies.velocity.enabled) { // Paper - Add Velocity IP Forwarding Support
             return -1;
         } else {
             return this.configuration.getInt("settings.connection-throttle");
         }
-        // Spigot End
+        // Spigot end
     }
 
     @Override
@@ -1288,7 +1289,7 @@ public final class CraftServer implements Server {
         Preconditions.checkArgument(creator != null, "WorldCreator cannot be null");
 
         String name = creator.name();
-        ChunkGenerator generator = creator.generator();
+        ChunkGenerator chunkGenerator = creator.generator();
         BiomeProvider biomeProvider = creator.biomeProvider();
         File folder = new File(this.getWorldContainer(), name);
         World world = this.getWorld(name);
@@ -1307,151 +1308,170 @@ public final class CraftServer implements Server {
             Preconditions.checkArgument(folder.isDirectory(), "File (%s) exists and isn't a folder", name);
         }
 
-        if (generator == null) {
-            generator = this.getGenerator(name);
+        if (chunkGenerator == null) {
+            chunkGenerator = this.getGenerator(name);
         }
 
         if (biomeProvider == null) {
             biomeProvider = this.getBiomeProvider(name);
         }
 
-        ResourceKey<LevelStem> actualDimension;
-        switch (creator.environment()) {
-            case NORMAL:
-                actualDimension = LevelStem.OVERWORLD;
-                break;
-            case NETHER:
-                actualDimension = LevelStem.NETHER;
-                break;
-            case THE_END:
-                actualDimension = LevelStem.END;
-                break;
-            default:
-                throw new IllegalArgumentException("Illegal dimension (" + creator.environment() + ")");
-        }
+        ResourceKey<LevelStem> actualDimension = switch (creator.environment()) {
+            case NORMAL -> LevelStem.OVERWORLD;
+            case NETHER -> LevelStem.NETHER;
+            case THE_END -> LevelStem.END;
+            default -> throw new IllegalArgumentException("Illegal dimension (" + creator.environment() + ")");
+        };
 
-        LevelStorageSource.LevelStorageAccess worldSession;
+        LevelStorageSource.LevelStorageAccess levelStorageAccess;
         try {
-            worldSession = LevelStorageSource.createDefault(this.getWorldContainer().toPath()).validateAndCreateAccess(name, actualDimension);
+            levelStorageAccess = LevelStorageSource.createDefault(this.getWorldContainer().toPath()).validateAndCreateAccess(name, actualDimension);
         } catch (IOException | ContentValidationException ex) {
             throw new RuntimeException(ex);
         }
 
-        Dynamic<?> dynamic;
-        if (worldSession.hasWorldData()) {
-            net.minecraft.world.level.storage.LevelSummary worldinfo;
-
+        Dynamic<?> dataTag;
+        if (levelStorageAccess.hasWorldData()) {
+            net.minecraft.world.level.storage.LevelSummary summary;
             try {
-                dynamic = worldSession.getDataTag();
-                worldinfo = worldSession.getSummary(dynamic);
-            } catch (NbtException | ReportedNbtException | IOException ioexception) {
-                LevelStorageSource.LevelDirectory convertable_b = worldSession.getLevelDirectory();
-
-                MinecraftServer.LOGGER.warn("Failed to load world data from {}", convertable_b.dataFile(), ioexception);
+                dataTag = levelStorageAccess.getDataTag();
+                summary = levelStorageAccess.getSummary(dataTag);
+            } catch (NbtException | ReportedNbtException | IOException e) {
+                LevelStorageSource.LevelDirectory levelDirectory = levelStorageAccess.getLevelDirectory();
+                MinecraftServer.LOGGER.warn("Failed to load world data from {}", levelDirectory.dataFile(), e);
                 MinecraftServer.LOGGER.info("Attempting to use fallback");
 
                 try {
-                    dynamic = worldSession.getDataTagFallback();
-                    worldinfo = worldSession.getSummary(dynamic);
-                } catch (NbtException | ReportedNbtException | IOException ioexception1) {
-                    MinecraftServer.LOGGER.error("Failed to load world data from {}", convertable_b.oldDataFile(), ioexception1);
-                    MinecraftServer.LOGGER.error("Failed to load world data from {} and {}. World files may be corrupted. Shutting down.", convertable_b.dataFile(), convertable_b.oldDataFile());
+                    dataTag = levelStorageAccess.getDataTagFallback();
+                    summary = levelStorageAccess.getSummary(dataTag);
+                } catch (NbtException | ReportedNbtException | IOException e1) {
+                    MinecraftServer.LOGGER.error("Failed to load world data from {}", levelDirectory.oldDataFile(), e1);
+                    MinecraftServer.LOGGER.error(
+                        "Failed to load world data from {} and {}. World files may be corrupted. Shutting down.",
+                        levelDirectory.dataFile(),
+                        levelDirectory.oldDataFile()
+                    );
                     return null;
                 }
 
-                worldSession.restoreLevelDataFromOld();
+                levelStorageAccess.restoreLevelDataFromOld();
             }
 
-            if (worldinfo.requiresManualConversion()) {
+            if (summary.requiresManualConversion()) {
                 MinecraftServer.LOGGER.info("This world must be opened in an older version (like 1.6.4) to be safely converted");
                 return null;
             }
 
-            if (!worldinfo.isCompatible()) {
+            if (!summary.isCompatible()) {
                 MinecraftServer.LOGGER.info("This world was created by an incompatible version.");
                 return null;
             }
         } else {
-            dynamic = null;
+            dataTag = null;
         }
 
         boolean hardcore = creator.hardcore();
 
-        PrimaryLevelData worlddata;
-        WorldLoader.DataLoadContext worldloader_a = this.console.worldLoader;
-        RegistryAccess.Frozen iregistrycustom_dimension = worldloader_a.datapackDimensions();
-        net.minecraft.core.Registry<LevelStem> iregistry = iregistrycustom_dimension.lookupOrThrow(Registries.LEVEL_STEM);
-        if (dynamic != null) {
-            LevelDataAndDimensions leveldataanddimensions = LevelStorageSource.getLevelDataAndDimensions(dynamic, worldloader_a.dataConfiguration(), iregistry, worldloader_a.datapackWorldgen());
-
-            worlddata = (PrimaryLevelData) leveldataanddimensions.worldData();
-            iregistrycustom_dimension = leveldataanddimensions.dimensions().dimensionsRegistryAccess();
+        PrimaryLevelData primaryLevelData;
+        WorldLoader.DataLoadContext context = this.console.worldLoader;
+        RegistryAccess.Frozen registryAccess = context.datapackDimensions();
+        net.minecraft.core.Registry<LevelStem> contextLevelStemRegistry = registryAccess.lookupOrThrow(Registries.LEVEL_STEM);
+        if (dataTag != null) {
+            LevelDataAndDimensions levelDataAndDimensions = LevelStorageSource.getLevelDataAndDimensions(
+                dataTag, context.dataConfiguration(), contextLevelStemRegistry, context.datapackWorldgen()
+            );
+            primaryLevelData = (PrimaryLevelData) levelDataAndDimensions.worldData();
+            registryAccess = levelDataAndDimensions.dimensions().dimensionsRegistryAccess();
         } else {
-            LevelSettings worldsettings;
-            WorldOptions worldoptions = new WorldOptions(creator.seed(), creator.generateStructures(), false);
-            WorldDimensions worlddimensions;
+            LevelSettings levelSettings;
+            WorldOptions worldOptions = new WorldOptions(creator.seed(), creator.generateStructures(), false);
+            WorldDimensions worldDimensions;
 
             DedicatedServerProperties.WorldDimensionData properties = new DedicatedServerProperties.WorldDimensionData(GsonHelper.parse((creator.generatorSettings().isEmpty()) ? "{}" : creator.generatorSettings()), creator.type().name().toLowerCase(Locale.ROOT));
+            levelSettings = new LevelSettings(
+                name,
+                GameType.byId(this.getDefaultGameMode().getValue()),
+                hardcore, Difficulty.EASY,
+                false,
+                new GameRules(context.dataConfiguration().enabledFeatures()),
+                context.dataConfiguration())
+            ;
+            worldDimensions = properties.create(context.datapackWorldgen());
 
-            worldsettings = new LevelSettings(name, GameType.byId(this.getDefaultGameMode().getValue()), hardcore, Difficulty.EASY, false, new GameRules(worldloader_a.dataConfiguration().enabledFeatures()), worldloader_a.dataConfiguration());
-            worlddimensions = properties.create(worldloader_a.datapackWorldgen());
-
-            WorldDimensions.Complete worlddimensions_b = worlddimensions.bake(iregistry);
-            Lifecycle lifecycle = worlddimensions_b.lifecycle().add(worldloader_a.datapackWorldgen().allRegistriesLifecycle());
+            WorldDimensions.Complete complete = worldDimensions.bake(contextLevelStemRegistry);
+            Lifecycle lifecycle = complete.lifecycle().add(context.datapackWorldgen().allRegistriesLifecycle());
 
-            worlddata = new PrimaryLevelData(worldsettings, worldoptions, worlddimensions_b.specialWorldProperty(), lifecycle);
-            iregistrycustom_dimension = worlddimensions_b.dimensionsRegistryAccess();
+            primaryLevelData = new PrimaryLevelData(levelSettings, worldOptions, complete.specialWorldProperty(), lifecycle);
+            registryAccess = complete.dimensionsRegistryAccess();
         }
-        iregistry = iregistrycustom_dimension.lookupOrThrow(Registries.LEVEL_STEM);
-        worlddata.customDimensions = iregistry;
-        worlddata.checkName(name);
-        worlddata.setModdedInfo(this.console.getServerModName(), this.console.getModdedStatus().shouldReportAsModified());
+
+        contextLevelStemRegistry = registryAccess.lookupOrThrow(Registries.LEVEL_STEM);
+        primaryLevelData.customDimensions = contextLevelStemRegistry;
+        primaryLevelData.checkName(name);
+        primaryLevelData.setModdedInfo(this.console.getServerModName(), this.console.getModdedStatus().shouldReportAsModified());
 
         if (this.console.options.has("forceUpgrade")) {
-            net.minecraft.server.Main.forceUpgrade(worldSession, DataFixers.getDataFixer(), this.console.options.has("eraseCache"), () -> true, iregistrycustom_dimension, this.console.options.has("recreateRegionFiles"));
+            net.minecraft.server.Main.forceUpgrade(levelStorageAccess, DataFixers.getDataFixer(), this.console.options.has("eraseCache"), () -> true, registryAccess, this.console.options.has("recreateRegionFiles"));
         }
 
-        long j = BiomeManager.obfuscateSeed(worlddata.worldGenOptions().seed()); // Paper - use world seed
-        List<CustomSpawner> list = ImmutableList.of(new PhantomSpawner(), new PatrolSpawner(), new CatSpawner(), new VillageSiege(), new WanderingTraderSpawner(worlddata));
-        LevelStem worlddimension = iregistry.getValue(actualDimension);
+        long i = BiomeManager.obfuscateSeed(primaryLevelData.worldGenOptions().seed());
+        List<CustomSpawner> list = ImmutableList.of(
+            new PhantomSpawner(), new PatrolSpawner(), new CatSpawner(), new VillageSiege(), new WanderingTraderSpawner(primaryLevelData)
+        );
+        LevelStem customStem = contextLevelStemRegistry.getValue(actualDimension);
 
-        WorldInfo worldInfo = new CraftWorldInfo(worlddata, worldSession, creator.environment(), worlddimension.type().value(), worlddimension.generator(), this.getHandle().getServer().registryAccess()); // Paper - Expose vanilla BiomeProvider from WorldInfo
-        if (biomeProvider == null && generator != null) {
-            biomeProvider = generator.getDefaultBiomeProvider(worldInfo);
+        WorldInfo worldInfo = new CraftWorldInfo(primaryLevelData, levelStorageAccess, creator.environment(), customStem.type().value(), customStem.generator(), this.getHandle().getServer().registryAccess()); // Paper - Expose vanilla BiomeProvider from WorldInfo
+        if (biomeProvider == null && chunkGenerator != null) {
+            biomeProvider = chunkGenerator.getDefaultBiomeProvider(worldInfo);
         }
 
-        ResourceKey<net.minecraft.world.level.Level> worldKey;
+        ResourceKey<net.minecraft.world.level.Level> dimensionKey;
         String levelName = this.getServer().getProperties().levelName;
         if (name.equals(levelName + "_nether")) {
-            worldKey = net.minecraft.world.level.Level.NETHER;
+            dimensionKey = net.minecraft.world.level.Level.NETHER;
         } else if (name.equals(levelName + "_the_end")) {
-            worldKey = net.minecraft.world.level.Level.END;
+            dimensionKey = net.minecraft.world.level.Level.END;
         } else {
-            worldKey = ResourceKey.create(Registries.DIMENSION, ResourceLocation.fromNamespaceAndPath(creator.key().namespace(), creator.key().value()));
+            dimensionKey = ResourceKey.create(Registries.DIMENSION, ResourceLocation.fromNamespaceAndPath(creator.key().namespace(), creator.key().value()));
         }
 
         // If set to not keep spawn in memory (changed from default) then adjust rule accordingly
         if (creator.keepSpawnLoaded() == net.kyori.adventure.util.TriState.FALSE) { // Paper
-            worlddata.getGameRules().getRule(GameRules.RULE_SPAWN_CHUNK_RADIUS).set(0, null);
-        }
-        ServerLevel internal = (ServerLevel) new ServerLevel(this.console, this.console.executor, worldSession, worlddata, worldKey, worlddimension, this.getServer().progressListenerFactory.create(worlddata.getGameRules().getInt(GameRules.RULE_SPAWN_CHUNK_RADIUS)),
-                worlddata.isDebugWorld(), j, creator.environment() == Environment.NORMAL ? list : ImmutableList.of(), true, this.console.overworld().getRandomSequences(), creator.environment(), generator, biomeProvider);
+            primaryLevelData.getGameRules().getRule(GameRules.RULE_SPAWN_CHUNK_RADIUS).set(0, null);
+        }
+
+        ServerLevel serverLevel = new ServerLevel(
+            this.console,
+            this.console.executor,
+            levelStorageAccess,
+            primaryLevelData,
+            dimensionKey,
+            customStem,
+            this.getServer().progressListenerFactory.create(primaryLevelData.getGameRules().getInt(GameRules.RULE_SPAWN_CHUNK_RADIUS)),
+            primaryLevelData.isDebugWorld(),
+            i,
+            creator.environment() == Environment.NORMAL ? list : ImmutableList.of(),
+            true,
+            this.console.overworld().getRandomSequences(),
+            creator.environment(),
+            chunkGenerator, biomeProvider
+        );
 
         if (!(this.worlds.containsKey(name.toLowerCase(Locale.ROOT)))) {
             return null;
         }
 
-        this.console.addLevel(internal); // Paper - Put world into worldlist before initing the world; move up
-        this.console.initWorld(internal, worlddata, worlddata, worlddata.worldGenOptions());
+        this.console.addLevel(serverLevel); // Paper - Put world into worldlist before initing the world; move up
+        this.console.initWorld(serverLevel, primaryLevelData, primaryLevelData, primaryLevelData.worldGenOptions());
 
-        internal.setSpawnSettings(true);
+        serverLevel.setSpawnSettings(true);
         // Paper - Put world into worldlist before initing the world; move up
 
-        this.getServer().prepareLevels(internal.getChunkSource().chunkMap.progressListener, internal);
-        // Paper - rewrite chunk system
+        this.getServer().prepareLevels(serverLevel.getChunkSource().chunkMap.progressListener, serverLevel);
+        io.papermc.paper.FeatureHooks.tickEntityManager(serverLevel); // SPIGOT-6526: Load pending entities so they are available to the API // Paper - chunk system
 
-        this.pluginManager.callEvent(new WorldLoadEvent(internal.getWorld()));
-        return internal.getWorld();
+        this.pluginManager.callEvent(new WorldLoadEvent(serverLevel.getWorld()));
+        return serverLevel.getWorld();
     }
 
     @Override
@@ -1493,8 +1513,8 @@ public final class CraftServer implements Server {
             }
 
             handle.getChunkSource().close(save);
-            // Paper - rewrite chunk system
-            handle.convertable.close();
+            io.papermc.paper.FeatureHooks.closeEntityManager(handle, save); // SPIGOT-6722: close entityManager // Paper - chunk system
+            handle.levelStorageAccess.close();
         } catch (Exception ex) {
             this.getLogger().log(Level.SEVERE, null, ex);
         }
@@ -2131,7 +2151,7 @@ public final class CraftServer implements Server {
         if (result == null) {
             GameProfile profile = null;
             // Only fetch an online UUID in online mode
-            if (this.getOnlineMode() || io.papermc.paper.configuration.GlobalConfiguration.get().proxies.isProxyOnlineMode()) { // Paper - Add setting for proxy online mode status
+            if (io.papermc.paper.configuration.GlobalConfiguration.get().proxies.isProxyOnlineMode()) { // Paper - Add setting for proxy online mode status
                 // This is potentially blocking :(
                 profile = this.console.getProfileCache().get(name).orElse(null);
             }
@@ -2466,6 +2486,11 @@ public final class CraftServer implements Server {
         return new CraftMerchantCustom(title == null ? InventoryType.MERCHANT.getDefaultTitle() : title);
     }
 
+    @Override
+    public @NotNull Merchant createMerchant() {
+        return new CraftMerchantCustom(net.kyori.adventure.text.Component.empty());
+    }
+
     @Override
     public int getMaxChainedNeighborUpdates() {
         return this.getServer().getMaxChainedNeighborUpdates();
@@ -2585,12 +2610,11 @@ public final class CraftServer implements Server {
     }
 
     public List<String> tabCompleteCommand(Player player, String message, ServerLevel world, Vec3 pos) {
-        // Spigot Start
-        if ( (org.spigotmc.SpigotConfig.tabComplete < 0 || message.length() <= org.spigotmc.SpigotConfig.tabComplete) && !message.contains( " " ) )
-        {
+        // Spigot start
+        if ((org.spigotmc.SpigotConfig.tabComplete < 0 || message.length() <= org.spigotmc.SpigotConfig.tabComplete) && !message.contains(" ")) {
             return ImmutableList.of();
         }
-        // Spigot End
+        // Spigot end
 
         List<String> completions = null;
         try {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftSound.java b/src/main/java/org/bukkit/craftbukkit/CraftSound.java
index e24d784674f99bbcd0d9c21bc2629a9a97f5ea9b..9cfbe2390ab19ca73a8c3510c465b837be339b12 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftSound.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftSound.java
@@ -1,22 +1,17 @@
 package org.bukkit.craftbukkit;
 
-import com.google.common.base.Preconditions;
-import java.util.Locale;
+import io.papermc.paper.util.OldEnumHolderable;
 import net.minecraft.core.Holder;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.sounds.SoundEvent;
-import org.bukkit.NamespacedKey;
-import org.bukkit.Registry;
 import org.bukkit.Sound;
-import org.bukkit.craftbukkit.util.Handleable;
-import org.jetbrains.annotations.NotNull;
 
-public class CraftSound implements Sound, Handleable<SoundEvent> {
+public class CraftSound extends OldEnumHolderable<Sound, SoundEvent> implements Sound {
 
     private static int count = 0;
 
     public static Sound minecraftToBukkit(SoundEvent minecraft) {
-        return CraftRegistry.minecraftToBukkit(minecraft, Registries.SOUND_EVENT, Registry.SOUNDS);
+        return CraftRegistry.minecraftToBukkit(minecraft, Registries.SOUND_EVENT);
     }
 
     public static SoundEvent bukkitToMinecraft(Sound bukkit) {
@@ -24,88 +19,11 @@ public class CraftSound implements Sound, Handleable<SoundEvent> {
     }
 
     public static Holder<SoundEvent> bukkitToMinecraftHolder(Sound bukkit) {
-        Preconditions.checkArgument(bukkit != null);
-
-        net.minecraft.core.Registry<SoundEvent> registry = CraftRegistry.getMinecraftRegistry(Registries.SOUND_EVENT);
-
-        if (registry.wrapAsHolder(CraftSound.bukkitToMinecraft(bukkit)) instanceof Holder.Reference<SoundEvent> holder) {
-            return holder;
-        }
-
-        throw new IllegalArgumentException("No Reference holder found for " + bukkit
-                + ", this can happen if a plugin creates its own sound effect with out properly registering it.");
-    }
-
-    private final NamespacedKey key;
-    private final SoundEvent soundEffect;
-    private final String name;
-    private final int ordinal;
-
-    public CraftSound(NamespacedKey key, SoundEvent soundEffect) {
-        this.key = key;
-        this.soundEffect = soundEffect;
-        // For backwards compatibility, minecraft values will stile return the uppercase name without the namespace,
-        // in case plugins use for example the name as key in a config file to receive sound specific values.
-        // Custom sounds will return the key with namespace. For a plugin this should look than like a new sound
-        // (which can always be added in new minecraft versions and the plugin should therefore handle it accordingly).
-        if (NamespacedKey.MINECRAFT.equals(key.getNamespace())) {
-            this.name = key.getKey().toUpperCase(Locale.ROOT).replace('.', '_');
-        } else {
-            this.name = key.toString();
-        }
-        this.ordinal = CraftSound.count++;
-    }
-
-    @Override
-    public SoundEvent getHandle() {
-        return this.soundEffect;
-    }
-
-    @NotNull
-    @Override
-    public NamespacedKey getKey() {
-        if (true) return java.util.Objects.requireNonNull(org.bukkit.Registry.SOUNDS.getKey(this), () -> this + " doesn't have a key"); // Paper
-        return this.key;
-    }
-
-    @Override
-    public int compareTo(@NotNull Sound sound) {
-        return this.ordinal - sound.ordinal();
-    }
-
-    @NotNull
-    @Override
-    public String name() {
-        return this.name;
-    }
-
-    @Override
-    public int ordinal() {
-        return this.ordinal;
-    }
-
-    @Override
-    public String toString() {
-        // For backwards compatibility
-        return this.name();
-    }
-
-    @Override
-    public boolean equals(Object other) {
-        if (this == other) {
-            return true;
-        }
-
-        if (!(other instanceof CraftSound otherSound)) {
-            return false;
-        }
-
-        return this.getKey().equals(otherSound.getKey());
+        return CraftRegistry.bukkitToMinecraftHolder(bukkit, Registries.SOUND_EVENT);
     }
 
-    @Override
-    public int hashCode() {
-        return this.getKey().hashCode();
+    public CraftSound(Holder<SoundEvent> soundEffect) {
+        super(soundEffect, count++);
     }
 
     // Paper start
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 92d9f0ea8f7810ae20d3996f49aefa539b4bcb69..ba32db69c95b325a781cb2dff4200e4464a11baf 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -6,7 +6,8 @@ import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.mojang.datafixers.util.Pair;
 import io.papermc.paper.FeatureHooks;
-import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
+import io.papermc.paper.registry.RegistryAccess;
+import io.papermc.paper.registry.RegistryKey;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
 import java.io.File;
@@ -21,7 +22,6 @@ import java.util.Objects;
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
-import java.util.concurrent.ExecutionException;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
@@ -32,7 +32,6 @@ import net.minecraft.core.particles.ParticleTypes;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.Tag;
-import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
 import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
 import net.minecraft.network.protocol.game.ClientboundSetTimePacket;
 import net.minecraft.network.protocol.game.ClientboundSoundEntityPacket;
@@ -77,7 +76,6 @@ import org.bukkit.Chunk;
 import org.bukkit.ChunkSnapshot;
 import org.bukkit.Difficulty;
 import org.bukkit.Effect;
-import org.bukkit.FeatureFlag;
 import org.bukkit.FluidCollisionMode;
 import org.bukkit.GameRule;
 import org.bukkit.Instrument;
@@ -130,7 +128,6 @@ import org.bukkit.entity.TippedArrow;
 import org.bukkit.entity.Trident;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
 import org.bukkit.event.weather.LightningStrikeEvent;
-import org.bukkit.event.world.SpawnChangeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
 import org.bukkit.generator.BiomeProvider;
 import org.bukkit.generator.BlockPopulator;
@@ -221,7 +218,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     public int getTileEntityCount() {
         // We don't use the full world tile entity list, so we must iterate chunks
         int size = 0;
-        for (ChunkHolder playerchunk : ca.spottedleaf.moonrise.common.util.ChunkSystem.getVisibleChunkHolders(this.world)) {
+        for (ChunkHolder playerchunk : ca.spottedleaf.moonrise.common.PlatformHooks.get().getVisibleChunkHolders(this.world)) {
             net.minecraft.world.level.chunk.LevelChunk chunk = playerchunk.getTickingChunk();
             if (chunk == null) {
                 continue;
@@ -410,7 +407,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
             return chunk instanceof ImposterProtoChunk || chunk instanceof net.minecraft.world.level.chunk.LevelChunk;
         }
         final java.util.concurrent.CompletableFuture<ChunkAccess> future = new java.util.concurrent.CompletableFuture<>();
-        ca.spottedleaf.moonrise.common.util.ChunkSystem.scheduleChunkLoad(
+        ca.spottedleaf.moonrise.common.PlatformHooks.get().scheduleChunkLoad(
             this.world, x, z, false, ChunkStatus.EMPTY, true, ca.spottedleaf.concurrentutil.util.Priority.NORMAL, future::complete
         );
         world.getChunkSource().mainThreadProcessor.managedBlock(future::isDone);
@@ -425,7 +422,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public Chunk[] getLoadedChunks() {
-        List<ChunkHolder> chunks = ca.spottedleaf.moonrise.common.util.ChunkSystem.getVisibleChunkHolders(this.world); // Paper
+        List<ChunkHolder> chunks = ca.spottedleaf.moonrise.common.PlatformHooks.get().getVisibleChunkHolders(this.world); // Paper
         return chunks.stream().map(ChunkHolder::getFullChunkNow).filter(Objects::nonNull).map(CraftChunk::new).toArray(Chunk[]::new);
     }
 
@@ -518,6 +515,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
                 FeatureHooks.sendChunkRefreshPackets(playersInRange, chunk);
         // Paper - chunk system
+
         return true;
     }
 
@@ -591,10 +589,9 @@ public class CraftWorld extends CraftRegionAccessor implements World {
         Preconditions.checkArgument(plugin != null, "null plugin");
         Preconditions.checkArgument(plugin.isEnabled(), "plugin is not enabled");
 
-        DistanceManager chunkDistanceManager = this.world.getChunkSource().chunkMap.distanceManager;
-
-        if (chunkDistanceManager.addRegionTicketAtDistance(TicketType.PLUGIN_TICKET, new ChunkPos(x, z), 2, plugin)) { // keep in-line with force loading, add at level 31
-            this.getChunkAt(x, z); // ensure loaded
+        final DistanceManager distanceManager = this.world.getChunkSource().chunkMap.distanceManager;
+        if (distanceManager.addPluginRegionTicket(new ChunkPos(x, z), plugin)) {
+            this.getChunkAt(x, z); // ensure it's loaded
             return true;
         }
 
@@ -605,8 +602,8 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     public boolean removePluginChunkTicket(int x, int z, Plugin plugin) {
         Preconditions.checkNotNull(plugin, "null plugin");
 
-        DistanceManager chunkDistanceManager = this.world.getChunkSource().chunkMap.distanceManager;
-        return chunkDistanceManager.removeRegionTicketAtDistance(TicketType.PLUGIN_TICKET, new ChunkPos(x, z), 2, plugin); // keep in-line with force loading, remove at level 31
+        final DistanceManager distanceManager = this.world.getChunkSource().chunkMap.distanceManager;
+        return distanceManager.removePluginRegionTicket(new ChunkPos(x, z), plugin);
     }
 
     @Override
@@ -619,35 +616,12 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public Collection<Plugin> getPluginChunkTickets(int x, int z) {
-        DistanceManager chunkDistanceManager = this.world.getChunkSource().chunkMap.distanceManager;
-
-        return chunkDistanceManager.moonrise$getChunkHolderManager().getPluginChunkTickets(x, z); // Paper - rewrite chunk system
+        return FeatureHooks.getPluginChunkTickets(this.world, x, z); // Paper - chunk system
     }
 
     @Override
     public Map<Plugin, Collection<Chunk>> getPluginChunkTickets() {
-        Map<Plugin, ImmutableList.Builder<Chunk>> ret = new HashMap<>();
-        DistanceManager chunkDistanceManager = this.world.getChunkSource().chunkMap.distanceManager;
-
-        for (Long2ObjectMap.Entry<SortedArraySet<Ticket<?>>> chunkTickets : chunkDistanceManager.moonrise$getChunkHolderManager().getTicketsCopy().long2ObjectEntrySet()) {  // Paper - rewrite chunk system
-            long chunkKey = chunkTickets.getLongKey();
-            SortedArraySet<Ticket<?>> tickets = chunkTickets.getValue();
-
-            Chunk chunk = null;
-            for (Ticket<?> ticket : tickets) {
-                if (ticket.getType() != TicketType.PLUGIN_TICKET) {
-                    continue;
-                }
-
-                if (chunk == null) {
-                    chunk = this.getChunkAt(ChunkPos.getX(chunkKey), ChunkPos.getZ(chunkKey));
-                }
-
-                ret.computeIfAbsent((Plugin) ticket.key, (key) -> ImmutableList.builder()).add(chunk);
-            }
-        }
-
-        return ret.entrySet().stream().collect(ImmutableMap.toImmutableMap(Map.Entry::getKey, (entry) -> entry.getValue().build()));
+        return FeatureHooks.getPluginChunkTickets(this.world); // Paper - chunk system
     }
 
     @NotNull
@@ -882,7 +856,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
             CraftPlayer cp = (CraftPlayer) p;
             if (cp.getHandle().connection == null) continue;
 
-            cp.getHandle().connection.send(new ClientboundSetTimePacket(cp.getHandle().level().getGameTime(), cp.getHandle().getPlayerTime(), cp.getHandle().serverLevel().getGameRules().getBoolean(GameRules.RULE_DAYLIGHT)));
+            cp.getHandle().connection.send(new ClientboundSetTimePacket(cp.getHandle().level().getGameTime(), cp.getHandle().getPlayerTime(), cp.getHandle().relativeTime && cp.getHandle().serverLevel().getGameRules().getBoolean(GameRules.RULE_DAYLIGHT)));
         }
     }
 
@@ -1332,12 +1306,12 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public int getViewDistance() {
-        return this.getHandle().moonrise$getPlayerChunkLoader().getAPIViewDistance(); // Paper - rewrite chunk system
+        return FeatureHooks.getViewDistance(this.world); // Paper - chunk system
     }
 
     @Override
     public int getSimulationDistance() {
-        return this.getHandle().moonrise$getPlayerChunkLoader().getAPITickDistance(); // Paper - rewrite chunk system
+        return FeatureHooks.getSimulationDistance(this.world); // Paper - chunk system
     }
 
     public BlockMetadataStore getBlockMetadata() {
@@ -1621,7 +1595,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public File getWorldFolder() {
-        return this.world.convertable.getLevelPath(LevelResource.ROOT).toFile().getParentFile();
+        return this.world.levelStorageAccess.getLevelPath(LevelResource.ROOT).toFile().getParentFile();
     }
 
     @Override
@@ -2210,7 +2184,8 @@ public class CraftWorld extends CraftRegionAccessor implements World {
                 receivers == null ? this.getHandle().players() : receivers.stream().map(player -> ((CraftPlayer) player).getHandle()).collect(java.util.stream.Collectors.toList()), // Paper -  Particle API
                 sender != null ? ((CraftPlayer) sender).getHandle() : null, // Sender // Paper - Particle API
                 CraftParticle.createParticleParam(particle, data), // Particle
-                false, force,
+                force,
+                false,
                 x, y, z, // Position
                 count,  // Count
                 offsetX, offsetY, offsetZ, // Random offset
@@ -2269,7 +2244,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public StructureSearchResult locateNearestStructure(Location origin, StructureType structureType, int radius, boolean findUnexplored) {
         List<Structure> structures = new ArrayList<>();
-        for (Structure structure : Registry.STRUCTURE) {
+        for (Structure structure : RegistryAccess.registryAccess().getRegistry(RegistryKey.STRUCTURE)) {
             if (structure.getStructureType() == structureType) {
                 structures.add(structure);
             }
@@ -2443,7 +2418,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public void getChunkAtAsync(int x, int z, boolean gen, boolean urgent, @NotNull Consumer<? super Chunk> cb) {
         warnUnsafeChunk("getting a faraway chunk async", x, z); // Paper
-        ca.spottedleaf.moonrise.common.util.ChunkSystem.scheduleChunkLoad(
+        ca.spottedleaf.moonrise.common.PlatformHooks.get().scheduleChunkLoad(
             this.getHandle(), x, z, gen, ChunkStatus.FULL, true,
             urgent ? ca.spottedleaf.concurrentutil.util.Priority.HIGHER : ca.spottedleaf.concurrentutil.util.Priority.NORMAL,
             (ChunkAccess chunk) -> {
@@ -2468,28 +2443,22 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setViewDistance(final int viewDistance) {
-        if (viewDistance < 2 || viewDistance > 32) {
-            throw new IllegalArgumentException("View distance " + viewDistance + " is out of range of [2, 32]");
-        }
-        this.getHandle().chunkSource.chunkMap.setServerViewDistance(viewDistance);
+        FeatureHooks.setViewDistance(this.world, viewDistance); // Paper - chunk system
     }
 
     @Override
     public void setSimulationDistance(final int simulationDistance) {
-        if (simulationDistance < 2 || simulationDistance > 32) {
-            throw new IllegalArgumentException("Simulation distance " + simulationDistance + " is out of range of [2, 32]");
-        }
-        this.getHandle().chunkSource.setSimulationDistance(simulationDistance); // Paper - rewrite chunk system
+        FeatureHooks.setSimulationDistance(this.world, simulationDistance); // Paper - chunk system
     }
 
     @Override
     public int getSendViewDistance() {
-        return this.getHandle().moonrise$getPlayerChunkLoader().getAPISendViewDistance(); // Paper - rewrite chunk system
+        return FeatureHooks.getSendViewDistance(this.world); // Paper - chunk system
     }
 
     @Override
     public void setSendViewDistance(final int viewDistance) {
-        this.getHandle().chunkSource.setSendViewDistance(viewDistance); // Paper - rewrite chunk system
+        FeatureHooks.setSendViewDistance(this.world, viewDistance); // Paper - chunk system
     }
 
     // Paper start - implement pointers
diff --git a/src/main/java/org/bukkit/craftbukkit/Main.java b/src/main/java/org/bukkit/craftbukkit/Main.java
index 1c2439ffc1e407ff69286817d22f127470ce07ba..ecb0fcd1f3b3f3d7751eded3cdf0977c1889c9ed 100644
--- a/src/main/java/org/bukkit/craftbukkit/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/Main.java
@@ -149,13 +149,13 @@ public class Main {
 
                 this.acceptsAll(Main.asList("initSettings"), "Only create configuration files and then exit"); // SPIGOT-5761: Add initSettings option
 
-                // Spigot Start
+                // Spigot start
                 this.acceptsAll(Main.asList("S", "spigot-settings"), "File for spigot settings")
                         .withRequiredArg()
                         .ofType(File.class)
                         .defaultsTo(new File("spigot.yml"))
                         .describedAs("Yml file");
-                // Spigot End
+                // Spigot end
 
                 // Paper start
                 acceptsAll(asList("paper-dir", "paper-settings-directory"), "Directory for Paper settings")
diff --git a/src/main/java/org/bukkit/craftbukkit/attribute/CraftAttribute.java b/src/main/java/org/bukkit/craftbukkit/attribute/CraftAttribute.java
index 0d04f0a34d1d1894845b720a407f7190ea78d514..1e7ea738fb852930fbf985bbfb20fa5f4d25ff2d 100644
--- a/src/main/java/org/bukkit/craftbukkit/attribute/CraftAttribute.java
+++ b/src/main/java/org/bukkit/craftbukkit/attribute/CraftAttribute.java
@@ -1,6 +1,7 @@
 package org.bukkit.craftbukkit.attribute;
 
 import com.google.common.base.Preconditions;
+import io.papermc.paper.registry.RegistryKey;
 import java.util.Locale;
 import net.minecraft.core.Holder;
 import net.minecraft.core.registries.Registries;
@@ -18,7 +19,7 @@ public class CraftAttribute implements Attribute, Handleable<net.minecraft.world
     private static int count = 0;
 
     public static Attribute minecraftToBukkit(net.minecraft.world.entity.ai.attributes.Attribute minecraft) {
-        return CraftRegistry.minecraftToBukkit(minecraft, Registries.ATTRIBUTE, Registry.ATTRIBUTE);
+        return CraftRegistry.minecraftToBukkit(minecraft, Registries.ATTRIBUTE);
     }
 
     public static Attribute minecraftHolderToBukkit(Holder<net.minecraft.world.entity.ai.attributes.Attribute> minecraft) {
@@ -36,7 +37,7 @@ public class CraftAttribute implements Attribute, Handleable<net.minecraft.world
         if (key == null) return null; // Paper - Fixup NamespacedKey handling
 
         // Now also convert from when keys where saved
-        return CraftRegistry.get(Registry.ATTRIBUTE, key, ApiVersion.CURRENT);
+        return CraftRegistry.get(RegistryKey.ATTRIBUTE, key, ApiVersion.CURRENT);
     }
 
     public static net.minecraft.world.entity.ai.attributes.Attribute bukkitToMinecraft(Attribute bukkit) {
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBanner.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBanner.java
index bb2d1dddca6bfe719b28df136e80a7c5a339a5ce..58175ec71d7a6c2599b80cf8adc1cebd3440e139 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBanner.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBanner.java
@@ -1,6 +1,7 @@
 package org.bukkit.craftbukkit.block;
 
 import com.google.common.base.Preconditions;
+import io.papermc.paper.registry.RegistryKey;
 import java.util.ArrayList;
 import java.util.List;
 import net.minecraft.world.level.block.AbstractBannerBlock;
@@ -39,7 +40,7 @@ public class CraftBanner extends CraftBlockEntityState<BannerBlockEntity> implem
             for (int i = 0; i < banner.getPatterns().layers().size(); i++) {
                 BannerPatternLayers.Layer p = banner.getPatterns().layers().get(i);
                 // Paper start - fix upstream not handling inlined banner pattern
-                java.util.Optional<org.bukkit.block.banner.PatternType> type = org.bukkit.craftbukkit.CraftRegistry.unwrapAndConvertHolder(org.bukkit.Registry.BANNER_PATTERN, p.pattern());
+                java.util.Optional<org.bukkit.block.banner.PatternType> type = org.bukkit.craftbukkit.CraftRegistry.unwrapAndConvertHolder(RegistryKey.BANNER_PATTERN, p.pattern());
                 if (type.isEmpty()) continue;
                 this.patterns.add(new Pattern(DyeColor.getByWoolData((byte) p.color().getId()), type.get()));
                 // Paper end - fix upstream not handling inlined banner pattern
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBiome.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBiome.java
index 4e535481cfc8aacf220ab7ddce6a0f2e3568c648..55c99297a66f54d4d19857b14d0be43dd89b36be 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBiome.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBiome.java
@@ -4,7 +4,6 @@ import java.util.Locale;
 import net.minecraft.core.Holder;
 import net.minecraft.core.registries.Registries;
 import org.bukkit.NamespacedKey;
-import org.bukkit.Registry;
 import org.bukkit.block.Biome;
 import org.bukkit.craftbukkit.CraftRegistry;
 import org.bukkit.craftbukkit.util.Handleable;
@@ -15,7 +14,7 @@ public class CraftBiome implements Biome, Handleable<net.minecraft.world.level.b
     private static int count = 0;
 
     public static Biome minecraftToBukkit(net.minecraft.world.level.biome.Biome minecraft) {
-        return CraftRegistry.minecraftToBukkit(minecraft, Registries.BIOME, Registry.BIOME);
+        return CraftRegistry.minecraftToBukkit(minecraft, Registries.BIOME);
     }
 
     public static Biome minecraftHolderToBukkit(Holder<net.minecraft.world.level.biome.Biome> minecraft) {
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockType.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockType.java
index 978e602c38d66c1ac219ffdfe82f9fc777a6ad26..6827c30a22c502ecfba859ef52cb0d83ea2fae1d 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockType.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockType.java
@@ -3,7 +3,9 @@ package org.bukkit.craftbukkit.block;
 import com.google.common.base.Preconditions;
 import java.lang.reflect.Method;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.function.Consumer;
+import com.google.common.collect.ImmutableList;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.world.InteractionHand;
@@ -49,7 +51,7 @@ public class CraftBlockType<B extends BlockData> implements BlockType.Typed<B>,
     }
 
     public static BlockType minecraftToBukkitNew(Block minecraft) {
-        return CraftRegistry.minecraftToBukkit(minecraft, Registries.BLOCK, Registry.BLOCK);
+        return CraftRegistry.minecraftToBukkit(minecraft, Registries.BLOCK);
     }
 
     public static Block bukkitToMinecraftNew(BlockType bukkit) {
@@ -147,6 +149,16 @@ public class CraftBlockType<B extends BlockData> implements BlockType.Typed<B>,
         return this.createBlockData((String) null);
     }
 
+    @Override
+    public @NotNull Collection<B> createBlockDataStates() {
+        final ImmutableList<BlockState> possibleStates = this.block.getStateDefinition().getPossibleStates();
+        final ImmutableList.Builder<B> builder = ImmutableList.builderWithExpectedSize(possibleStates.size());
+        for (final BlockState possibleState : possibleStates) {
+            builder.add(this.blockDataClass.cast(possibleState.createCraftBlockData()));
+        }
+        return builder.build();
+    }
+
     @Override
     public B createBlockData(Consumer<? super B> consumer) {
         B data = this.createBlockData();
diff --git a/src/main/java/org/bukkit/craftbukkit/block/banner/CraftPatternType.java b/src/main/java/org/bukkit/craftbukkit/block/banner/CraftPatternType.java
index 3addb382d00434bab9151c9edddc8999b986653c..5865892ad8d290c17e82a874bd22389bfc7c2385 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/banner/CraftPatternType.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/banner/CraftPatternType.java
@@ -1,26 +1,22 @@
 package org.bukkit.craftbukkit.block.banner;
 
-import com.google.common.base.Preconditions;
-import java.util.Locale;
+import io.papermc.paper.util.OldEnumHolderable;
 import net.minecraft.core.Holder;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.world.level.block.entity.BannerPattern;
-import org.bukkit.NamespacedKey;
-import org.bukkit.Registry;
 import org.bukkit.block.banner.PatternType;
 import org.bukkit.craftbukkit.CraftRegistry;
-import org.bukkit.craftbukkit.util.Handleable;
 
-public class CraftPatternType implements PatternType, Handleable<BannerPattern> {
+public class CraftPatternType extends OldEnumHolderable<PatternType, BannerPattern> implements PatternType {
 
     private static int count = 0;
 
     public static PatternType minecraftToBukkit(BannerPattern minecraft) {
-        return CraftRegistry.minecraftToBukkit(minecraft, Registries.BANNER_PATTERN, Registry.BANNER_PATTERN);
+        return CraftRegistry.minecraftToBukkit(minecraft, Registries.BANNER_PATTERN);
     }
 
     public static PatternType minecraftHolderToBukkit(Holder<BannerPattern> minecraft) {
-        return CraftPatternType.minecraftToBukkit(minecraft.value());
+        return CraftRegistry.minecraftHolderToBukkit(minecraft, Registries.BANNER_PATTERN);
     }
 
     public static BannerPattern bukkitToMinecraft(PatternType bukkit) {
@@ -28,86 +24,11 @@ public class CraftPatternType implements PatternType, Handleable<BannerPattern>
     }
 
     public static Holder<BannerPattern> bukkitToMinecraftHolder(PatternType bukkit) {
-        Preconditions.checkArgument(bukkit != null);
-
-        net.minecraft.core.Registry<BannerPattern> registry = CraftRegistry.getMinecraftRegistry(Registries.BANNER_PATTERN);
-
-        if (registry.wrapAsHolder(CraftPatternType.bukkitToMinecraft(bukkit)) instanceof Holder.Reference<BannerPattern> holder) {
-            return holder;
-        }
-
-        throw new IllegalArgumentException("No Reference holder found for " + bukkit
-                + ", this can happen if a plugin creates its own banner pattern without properly registering it.");
-    }
-
-    private final NamespacedKey key;
-    private final BannerPattern bannerPatternType;
-    private final String name;
-    private final int ordinal;
-
-    public CraftPatternType(NamespacedKey key, BannerPattern bannerPatternType) {
-        this.key = key;
-        this.bannerPatternType = bannerPatternType;
-        // For backwards compatibility, minecraft values will stile return the uppercase name without the namespace,
-        // in case plugins use for example the name as key in a config file to receive pattern type specific values.
-        // Custom pattern types will return the key with namespace. For a plugin this should look than like a new pattern type
-        // (which can always be added in new minecraft versions and the plugin should therefore handle it accordingly).
-        if (NamespacedKey.MINECRAFT.equals(key.getNamespace())) {
-            this.name = key.getKey().toUpperCase(Locale.ROOT);
-        } else {
-            this.name = key.toString();
-        }
-        this.ordinal = CraftPatternType.count++;
-    }
-
-    @Override
-    public BannerPattern getHandle() {
-        return this.bannerPatternType;
-    }
-
-    @Override
-    public NamespacedKey getKey() {
-        if (true) return java.util.Objects.requireNonNull(org.bukkit.Registry.BANNER_PATTERN.getKey(this), () -> this + " doesn't have a key"); // Paper
-        return this.key;
-    }
-
-    @Override
-    public int compareTo(PatternType patternType) {
-        return this.ordinal - patternType.ordinal();
+        return CraftRegistry.bukkitToMinecraftHolder(bukkit, Registries.BANNER_PATTERN);
     }
 
-    @Override
-    public String name() {
-        return this.name;
-    }
-
-    @Override
-    public int ordinal() {
-        return this.ordinal;
-    }
-
-    @Override
-    public String toString() {
-        // For backwards compatibility
-        return this.name();
-    }
-
-    @Override
-    public boolean equals(Object other) {
-        if (this == other) {
-            return true;
-        }
-
-        if (!(other instanceof CraftPatternType)) {
-            return false;
-        }
-
-        return this.getKey().equals(((PatternType) other).getKey());
-    }
-
-    @Override
-    public int hashCode() {
-        return this.getKey().hashCode();
+    public CraftPatternType(Holder<BannerPattern> bannerPatternType) {
+       super(bannerPatternType, count++);
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/damage/CraftDamageType.java b/src/main/java/org/bukkit/craftbukkit/damage/CraftDamageType.java
index d486412429a9e9f8eba4e892222cf0c83ba79687..3350775859f216bb30cf08d445798ec93b824780 100644
--- a/src/main/java/org/bukkit/craftbukkit/damage/CraftDamageType.java
+++ b/src/main/java/org/bukkit/craftbukkit/damage/CraftDamageType.java
@@ -4,7 +4,6 @@ import com.google.common.base.Preconditions;
 import net.minecraft.core.Holder;
 import net.minecraft.core.registries.Registries;
 import org.bukkit.NamespacedKey;
-import org.bukkit.Registry;
 import org.bukkit.craftbukkit.CraftRegistry;
 import org.bukkit.craftbukkit.util.Handleable;
 import org.bukkit.damage.DamageEffect;
@@ -120,6 +119,6 @@ public class CraftDamageType implements DamageType, Handleable<net.minecraft.wor
     }
 
     public static DamageType minecraftToBukkit(net.minecraft.world.damagesource.DamageType minecraftDamageType) {
-        return CraftRegistry.minecraftToBukkit(minecraftDamageType, Registries.DAMAGE_TYPE, Registry.DAMAGE_TYPE);
+        return CraftRegistry.minecraftToBukkit(minecraftDamageType, Registries.DAMAGE_TYPE);
     }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/enchantments/CraftEnchantment.java b/src/main/java/org/bukkit/craftbukkit/enchantments/CraftEnchantment.java
index 34934f0dbe66ee200cd99c002c53645660041548..48fa34517b6e523ef9c303922d060b3d5a8df248 100644
--- a/src/main/java/org/bukkit/craftbukkit/enchantments/CraftEnchantment.java
+++ b/src/main/java/org/bukkit/craftbukkit/enchantments/CraftEnchantment.java
@@ -1,11 +1,12 @@
 package org.bukkit.craftbukkit.enchantments;
 
 import com.google.common.base.Preconditions;
+import io.papermc.paper.registry.RegistryKey;
+import io.papermc.paper.util.Holderable;
 import java.util.Locale;
 import net.minecraft.Util;
 import net.minecraft.core.Holder;
 import net.minecraft.core.registries.Registries;
-import net.minecraft.network.chat.contents.TranslatableContents;
 import net.minecraft.tags.EnchantmentTags;
 import org.bukkit.NamespacedKey;
 import org.bukkit.Registry;
@@ -13,16 +14,15 @@ import org.bukkit.craftbukkit.CraftRegistry;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.craftbukkit.legacy.FieldRename;
 import org.bukkit.craftbukkit.util.ApiVersion;
-import org.bukkit.craftbukkit.util.Handleable;
 import org.bukkit.enchantments.Enchantment;
 import org.bukkit.enchantments.EnchantmentTarget;
 import org.bukkit.enchantments.EnchantmentWrapper;
 import org.bukkit.inventory.ItemStack;
 
-public class CraftEnchantment extends Enchantment implements Handleable<net.minecraft.world.item.enchantment.Enchantment> {
+public class CraftEnchantment extends Enchantment implements Holderable<net.minecraft.world.item.enchantment.Enchantment> {
 
     public static Enchantment minecraftToBukkit(net.minecraft.world.item.enchantment.Enchantment minecraft) {
-        return CraftRegistry.minecraftToBukkit(minecraft, Registries.ENCHANTMENT, Registry.ENCHANTMENT);
+        return CraftRegistry.minecraftToBukkit(minecraft, Registries.ENCHANTMENT);
     }
 
     public static Enchantment minecraftHolderToBukkit(Holder<net.minecraft.world.item.enchantment.Enchantment> minecraft) {
@@ -53,25 +53,23 @@ public class CraftEnchantment extends Enchantment implements Handleable<net.mine
         NamespacedKey key = NamespacedKey.fromString(string);
 
         // Now also convert from when keys where saved
-        return CraftRegistry.get(Registry.ENCHANTMENT, key, ApiVersion.CURRENT);
+        return CraftRegistry.get(RegistryKey.ENCHANTMENT, key, ApiVersion.CURRENT);
     }
 
-    private final NamespacedKey key;
     private final Holder<net.minecraft.world.item.enchantment.Enchantment> handle;
 
-    public CraftEnchantment(NamespacedKey key, net.minecraft.world.item.enchantment.Enchantment handle) {
-        this.key = key;
-        this.handle = CraftRegistry.getMinecraftRegistry(Registries.ENCHANTMENT).wrapAsHolder(handle);
+    public CraftEnchantment(Holder<net.minecraft.world.item.enchantment.Enchantment> holder) {
+        this.handle = holder;
     }
 
     @Override
-    public net.minecraft.world.item.enchantment.Enchantment getHandle() {
-        return this.handle.value();
+    public Holder<net.minecraft.world.item.enchantment.Enchantment> getHolder() {
+        return this.handle;
     }
 
     @Override
     public NamespacedKey getKey() {
-        return this.key;
+        return Holderable.super.getKey();
     }
 
     @Override
@@ -251,24 +249,16 @@ public class CraftEnchantment extends Enchantment implements Handleable<net.mine
 
     @Override
     public boolean equals(Object other) {
-        if (this == other) {
-            return true;
-        }
-
-        if (!(other instanceof CraftEnchantment)) {
-            return false;
-        }
-
-        return this.getKey().equals(((Enchantment) other).getKey());
+        return Holderable.super.implEquals(other);
     }
 
     @Override
     public int hashCode() {
-        return this.getKey().hashCode();
+        return Holderable.super.implHashCode();
     }
 
     @Override
     public String toString() {
-        return "CraftEnchantment[" + this.getKey() + "]";
+        return Holderable.super.implToString();
     }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/AbstractProjectile.java b/src/main/java/org/bukkit/craftbukkit/entity/AbstractProjectile.java
index 591af9d0d2fdc9953415979fc97a4a00afd85885..e8d82054d17ef1859eb57f3871043b3fe3de22b9 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/AbstractProjectile.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/AbstractProjectile.java
@@ -40,7 +40,7 @@ public abstract class AbstractProjectile extends CraftEntity implements Projecti
 
     @Override
     public boolean canHitEntity(org.bukkit.entity.Entity entity) {
-        return this.getHandle().canHitEntity(((CraftEntity) entity).getHandle());
+        return this.getHandle().canHitEntityPublic(((CraftEntity) entity).getHandle());
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftAbstractArrow.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftAbstractArrow.java
index d0c30fd12aa9866900fe72b97d10c257479cf010..af2c1ad8cd878f0048f326699ac4462b86e7a4be 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftAbstractArrow.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftAbstractArrow.java
@@ -150,7 +150,7 @@ public class CraftAbstractArrow extends AbstractProjectile implements AbstractAr
     @Override
     public void setItemStack(final ItemStack stack) {
         Preconditions.checkArgument(stack != null, "ItemStack cannot be null");
-        this.getHandle().setPickupItemStack(CraftItemStack.asNMSCopy(stack));
+        this.getHandle().setPickupItemStackPublic(CraftItemStack.asNMSCopy(stack));
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftCat.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftCat.java
index 88e876da7df64b68a5b71fd1deab75b59c5a64e3..1a09082fcde81e3834c98903bda47aef90391870 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftCat.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftCat.java
@@ -7,7 +7,6 @@ import net.minecraft.core.registries.Registries;
 import net.minecraft.world.entity.animal.CatVariant;
 import org.bukkit.DyeColor;
 import org.bukkit.NamespacedKey;
-import org.bukkit.Registry;
 import org.bukkit.craftbukkit.CraftRegistry;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.util.Handleable;
@@ -55,7 +54,7 @@ public class CraftCat extends CraftTameableAnimal implements Cat {
         private static int count = 0;
 
         public static Type minecraftToBukkit(CatVariant minecraft) {
-            return CraftRegistry.minecraftToBukkit(minecraft, Registries.CAT_VARIANT, Registry.CAT_VARIANT);
+            return CraftRegistry.minecraftToBukkit(minecraft, Registries.CAT_VARIANT);
         }
 
         public static Type minecraftHolderToBukkit(Holder<CatVariant> minecraft) {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEnderDragon.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEnderDragon.java
index 7b7b89e67d53ed70efae714192c5fa32977f3d9c..1ef0ec7ed3b13c25d76c03c7013c8e2eaba4d66a 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEnderDragon.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEnderDragon.java
@@ -23,7 +23,7 @@ public class CraftEnderDragon extends CraftMob implements EnderDragon, CraftEnem
     public Set<ComplexEntityPart> getParts() {
         Builder<ComplexEntityPart> builder = ImmutableSet.builder();
 
-        for (EnderDragonPart part : this.getHandle().subEntities) {
+        for (EnderDragonPart part : this.getHandle().getSubEntities()) {
             builder.add((ComplexEntityPart) part.getBukkitEntity());
         }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index b25b10c24a379097233e61bcc10add841b6a7115..6d81a19741868983c54aff6c2c4c0e2bf690ba0d 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -5,9 +5,11 @@ import com.google.common.base.Preconditions;
 import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 import java.util.UUID;
+import io.papermc.paper.entity.LookAnchor;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.Tag;
 import net.minecraft.network.chat.Component;
@@ -45,6 +47,7 @@ import org.bukkit.entity.EntityType;
 import org.bukkit.entity.Player;
 import org.bukkit.entity.Pose;
 import org.bukkit.entity.SpawnCategory;
+import org.bukkit.event.entity.CreatureSpawnEvent;
 import org.bukkit.event.entity.EntityDamageEvent;
 import org.bukkit.event.entity.EntityRemoveEvent;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
@@ -193,8 +196,8 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
 
     @Override
     public boolean isOnGround() {
-        if (this.entity instanceof AbstractArrow) {
-            return ((AbstractArrow) this.entity).isInGround();
+        if (this.entity instanceof AbstractArrow abstractArrow) {
+            return abstractArrow.isInGround();
         }
         return this.entity.onGround();
     }
@@ -241,9 +244,9 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         Preconditions.checkArgument(location != null, "location cannot be null");
         location.checkFinite();
         // Paper start - Teleport passenger API
-        Set<io.papermc.paper.entity.TeleportFlag> flagSet = Set.of(flags);
+        Set<io.papermc.paper.entity.TeleportFlag> flagSet = new HashSet<>(List.of(flags)); // Wrap into list while multiple old flags link to the same new one
         boolean dismount = !flagSet.contains(io.papermc.paper.entity.TeleportFlag.EntityState.RETAIN_VEHICLE);
-        boolean ignorePassengers = flagSet.contains(io.papermc.paper.entity.TeleportFlag.EntityState.RETAIN_PASSENGERS);
+        boolean retainPassengers = flagSet.contains(io.papermc.paper.entity.TeleportFlag.EntityState.RETAIN_PASSENGERS);
         // Don't allow teleporting between worlds while keeping passengers
         if (flagSet.contains(io.papermc.paper.entity.TeleportFlag.EntityState.RETAIN_PASSENGERS) && this.entity.isVehicle() && location.getWorld() != this.getWorld()) {
             return false;
@@ -255,7 +258,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         }
         // Paper end
 
-        if ((!ignorePassengers && this.entity.isVehicle()) || this.entity.isRemoved()) { // Paper - Teleport passenger API
+        if ((!retainPassengers && this.entity.isVehicle()) || this.entity.isRemoved()) { // Paper - Teleport passenger API
             return false;
         }
 
@@ -286,6 +289,9 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         // SPIGOT-619: Force sync head rotation also
         this.entity.setYHeadRot(location.getYaw());
 
+        // Ensure passengers of entity are teleported
+        if (retainPassengers && this.entity.isVehicle()) this.entity.teleportPassengers();
+
         return true;
     }
 
@@ -299,6 +305,25 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         return this.teleport(destination.getLocation(), cause);
     }
 
+    @Override
+    public void lookAt(double x, double y, double z, LookAnchor entityAnchor) {
+        this.getHandle().lookAt(toNmsAnchor(entityAnchor), new net.minecraft.world.phys.Vec3(x, y, z));
+    }
+
+    public static net.minecraft.commands.arguments.EntityAnchorArgument.Anchor toNmsAnchor(LookAnchor nmsAnchor) {
+        return switch (nmsAnchor) {
+            case EYES -> net.minecraft.commands.arguments.EntityAnchorArgument.Anchor.EYES;
+            case FEET -> net.minecraft.commands.arguments.EntityAnchorArgument.Anchor.FEET;
+        };
+    }
+
+    public static LookAnchor toApiAnchor(net.minecraft.commands.arguments.EntityAnchorArgument.Anchor playerAnchor) {
+        return switch (playerAnchor) {
+            case EYES -> LookAnchor.EYES;
+            case FEET -> LookAnchor.FEET;
+        };
+    }
+
     @Override
     public List<org.bukkit.entity.Entity> getNearbyEntities(double x, double y, double z) {
         Preconditions.checkState(!this.entity.generation, "Cannot get nearby entities during world generation");
@@ -417,7 +442,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
 
     @Override
     public org.bukkit.entity.Entity getPassenger() {
-        return this.isEmpty() ? null : this.getHandle().passengers.get(0).getBukkitEntity();
+        return this.isEmpty() ? null : this.getHandle().getPassengers().getFirst().getBukkitEntity();
     }
 
     @Override
@@ -433,7 +458,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
 
     @Override
     public List<org.bukkit.entity.Entity> getPassengers() {
-        return Lists.newArrayList(Lists.transform(this.getHandle().passengers, (Function<Entity, org.bukkit.entity.Entity>) input -> input.getBukkitEntity()));
+        return Lists.newArrayList(Lists.transform(this.getHandle().getPassengers(), (Function<Entity, org.bukkit.entity.Entity>) Entity::getBukkitEntity));
     }
 
     @Override
@@ -852,12 +877,12 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
 
     @Override
     public int getPortalCooldown() {
-        return this.getHandle().portalCooldown;
+        return this.getHandle().getPortalCooldown();
     }
 
     @Override
     public void setPortalCooldown(int cooldown) {
-        this.getHandle().portalCooldown = cooldown;
+        this.getHandle().setPortalCooldown(cooldown);
     }
 
     @Override
@@ -935,7 +960,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
     @Override
     public String getAsString() {
         CompoundTag tag = new CompoundTag();
-        if (!this.getHandle().saveAsPassenger(tag, false)) {
+        if (!this.getHandle().saveAsPassenger(tag, false, false, false)) {
             return null;
         }
 
@@ -968,7 +993,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
 
     private Entity copy(net.minecraft.world.level.Level level) {
         CompoundTag compoundTag = new CompoundTag();
-        this.getHandle().saveAsPassenger(compoundTag, false);
+        this.getHandle().saveAsPassenger(compoundTag, false, true, true);
 
         return net.minecraft.world.entity.EntityType.loadEntityRecursive(compoundTag, level, EntitySpawnReason.LOAD, java.util.function.Function.identity());
     }
@@ -1204,17 +1229,19 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
     }
     // Paper end - tracked players API
 
-    // Paper start - raw entity serialization API
     @Override
-    public boolean spawnAt(Location location, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason reason) {
+    public boolean spawnAt(Location location, CreatureSpawnEvent.SpawnReason reason) {
         Preconditions.checkNotNull(location, "location cannot be null");
         Preconditions.checkNotNull(reason, "reason cannot be null");
         this.entity.setLevel(((CraftWorld) location.getWorld()).getHandle());
         this.entity.setPos(location.getX(), location.getY(), location.getZ());
         this.entity.setRot(location.getYaw(), location.getPitch());
-        return !this.entity.valid && this.entity.level().addFreshEntity(this.entity, reason);
+        final boolean spawned = !this.entity.valid && this.entity.level().addFreshEntity(this.entity, reason);
+        if (!spawned) return false; // Do not attempt to spawn rest if root was not spawned in
+        // Like net.minecraft.world.level.ServerLevelAccessor.addFreshEntityWithPassengers(net.minecraft.world.entity.Entity, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason)
+        this.entity.getIndirectPassengers().forEach(e -> e.level().addFreshEntity(e, reason));
+        return true;
     }
-    // Paper end - raw entity serialization API
 
     // Paper start - entity powdered snow API
     @Override
@@ -1252,12 +1279,12 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
 
     // Paper start - missing entity api
     @Override
-    public boolean isInvisible() {  // Paper - moved up from LivingEntity
+    public boolean isInvisible() { // Paper - moved up from LivingEntity
         return this.getHandle().isInvisible();
     }
 
     @Override
-    public void setInvisible(boolean invisible) {  // Paper - moved up from LivingEntity
+    public void setInvisible(boolean invisible) { // Paper - moved up from LivingEntity
         this.getHandle().persistentInvisibility = invisible;
         this.getHandle().setSharedFlag(Entity.FLAG_INVISIBLE, invisible);
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntitySnapshot.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntitySnapshot.java
index 6642bdc117d54aa2560518d4e08438a88e6fb3a1..cb8d7fe3a07bbb68e663bfc13970c05b1f78c987 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntitySnapshot.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntitySnapshot.java
@@ -66,7 +66,7 @@ public class CraftEntitySnapshot implements EntitySnapshot {
 
     public static CraftEntitySnapshot create(CraftEntity entity) {
         CompoundTag tag = new CompoundTag();
-        if (!entity.getHandle().saveAsPassenger(tag, false)) {
+        if (!entity.getHandle().saveAsPassenger(tag, false, false, false)) {
             return null;
         }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntityType.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntityType.java
index d230cbc26f61d8ac5880825aca4dfab197c20401..47db4546242974a40f7fc1e34f237fd1f06d5f37 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntityType.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntityType.java
@@ -1,6 +1,7 @@
 package org.bukkit.craftbukkit.entity;
 
 import com.google.common.base.Preconditions;
+import io.papermc.paper.registry.RegistryKey;
 import java.util.Locale;
 import net.minecraft.core.Holder;
 import net.minecraft.core.registries.Registries;
@@ -61,6 +62,6 @@ public class CraftEntityType {
         NamespacedKey key = NamespacedKey.fromString(string);
 
         // Now also convert from when keys where saved
-        return CraftRegistry.get(Registry.ENTITY_TYPE, key, ApiVersion.CURRENT);
+        return CraftRegistry.get(RegistryKey.ENTITY_TYPE, key, ApiVersion.CURRENT);
     }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftFrog.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftFrog.java
index ebf09c27e02a19d31c777b70a38376e4d01e5ee7..58cacdc8f37420be6fac280a5fd295d1da40dba8 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftFrog.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftFrog.java
@@ -7,7 +7,6 @@ import net.minecraft.core.registries.Registries;
 import net.minecraft.world.entity.animal.FrogVariant;
 import net.minecraft.world.entity.animal.frog.Frog;
 import org.bukkit.NamespacedKey;
-import org.bukkit.Registry;
 import org.bukkit.craftbukkit.CraftRegistry;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.util.Handleable;
@@ -59,7 +58,7 @@ public class CraftFrog extends CraftAnimals implements org.bukkit.entity.Frog {
         private static int count = 0;
 
         public static Variant minecraftToBukkit(FrogVariant minecraft) {
-            return CraftRegistry.minecraftToBukkit(minecraft, Registries.FROG_VARIANT, Registry.FROG_VARIANT);
+            return CraftRegistry.minecraftToBukkit(minecraft, Registries.FROG_VARIANT);
         }
 
         public static Variant minecraftHolderToBukkit(Holder<FrogVariant> minecraft) {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
index e345cdbfab44a0f5da80d738798dbb4424b7ab5c..a396157548a5b3c3e86206c35789bb40346c701c 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
@@ -7,6 +7,7 @@ import java.util.Arrays;
 import java.util.Collection;
 import java.util.Optional;
 import java.util.Set;
+import java.util.function.Consumer;
 import net.minecraft.core.BlockPos;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.chat.Component;
@@ -19,10 +20,12 @@ import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntitySpawnReason;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.HumanoidArm;
+import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.entity.projectile.FireworkRocketEntity;
 import net.minecraft.world.inventory.AbstractContainerMenu;
 import net.minecraft.world.inventory.MenuType;
+import net.minecraft.world.inventory.MerchantMenu;
 import net.minecraft.world.item.ItemCooldowns;
 import net.minecraft.world.item.crafting.RecipeHolder;
 import net.minecraft.world.item.crafting.RecipeManager;
@@ -48,13 +51,16 @@ import org.bukkit.craftbukkit.inventory.CraftInventoryView;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.craftbukkit.inventory.CraftMerchantCustom;
 import org.bukkit.craftbukkit.inventory.CraftRecipe;
+import org.bukkit.craftbukkit.inventory.util.CraftMenus;
 import org.bukkit.craftbukkit.util.CraftChatMessage;
 import org.bukkit.craftbukkit.util.CraftLocation;
 import org.bukkit.entity.Firework;
 import org.bukkit.entity.HumanEntity;
+import org.bukkit.entity.Item;
 import org.bukkit.entity.Villager;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
 import org.bukkit.inventory.EntityEquipment;
+import org.bukkit.inventory.EquipmentSlot;
 import org.bukkit.inventory.Inventory;
 import org.bukkit.inventory.InventoryView;
 import org.bukkit.inventory.ItemStack;
@@ -66,6 +72,8 @@ import org.bukkit.permissions.Permission;
 import org.bukkit.permissions.PermissionAttachment;
 import org.bukkit.permissions.PermissionAttachmentInfo;
 import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 
 public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
     private CraftInventoryPlayer inventory;
@@ -146,7 +154,7 @@ public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
 
     // Paper start - Potential bed api
     @Override
-    public Location getPotentialBedLocation() {
+    public Location getPotentialRespawnLocation() {
         ServerPlayer handle = (ServerPlayer) getHandle();
         BlockPos bed = handle.getRespawnPosition();
         if (bed == null) {
@@ -462,6 +470,11 @@ public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
 
         // Now open the window
         MenuType<?> windowType = CraftContainer.getNotchInventoryType(inventory.getTopInventory());
+        // we can open these now, delegate for now
+        if (windowType == MenuType.MERCHANT) {
+            CraftMenus.openMerchantMenu(player, (MerchantMenu) container);
+            return;
+        }
 
         //String title = inventory.getTitle(); // Paper - comment
         net.kyori.adventure.text.Component adventure$title = inventory.title(); // Paper
@@ -801,6 +814,47 @@ public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
         // Paper end - Fix HumanEntity#drop not updating the client inv
     }
 
+    @Override
+    @Nullable
+    public Item dropItem(final int slot, final int amount, final boolean throwRandomly, final @Nullable Consumer<Item> entityOperation) {
+        Preconditions.checkArgument(slot >= 0 && slot < this.inventory.getSize(), "Slot %s is not a valid inventory slot.", slot);
+
+        return internalDropItemFromInventory(this.inventory.getItem(slot), amount, throwRandomly, entityOperation);
+    }
+
+    @Override
+    @Nullable
+    public Item dropItem(final @NotNull EquipmentSlot slot, final int amount, final boolean throwRandomly, final @Nullable Consumer<Item> entityOperation) {
+        return internalDropItemFromInventory(this.inventory.getItem(slot), amount, throwRandomly, entityOperation);
+    }
+
+    @Nullable
+    private Item internalDropItemFromInventory(final ItemStack originalItemStack, final int amount, final boolean throwRandomly, final @Nullable Consumer<Item> entityOperation) {
+        if (originalItemStack == null || originalItemStack.isEmpty() || amount <= 0) return null;
+
+        final net.minecraft.world.item.ItemStack nmsItemStack = CraftItemStack.unwrap(originalItemStack);
+        final net.minecraft.world.item.ItemStack dropContent = nmsItemStack.split(amount);
+
+        // This will return the itemstack back to its original amount in case events fail
+        final ItemEntity droppedEntity = this.getHandle().drop(dropContent, throwRandomly, true, true, entityOperation);
+        return droppedEntity == null ? null : (Item) droppedEntity.getBukkitEntity();
+    }
+
+    @Override
+    @Nullable
+    public Item dropItem(final ItemStack itemStack, final boolean throwRandomly, final @Nullable Consumer<Item> entityOperation) {
+        // This method implementation differs from the previous dropItem implementations, as it does not source
+        // its itemstack from the players inventory. As such, we cannot reuse #internalDropItemFromInventory.
+        Preconditions.checkArgument(itemStack != null, "Cannot drop a null itemstack");
+        if (itemStack.isEmpty()) return null;
+
+        final net.minecraft.world.item.ItemStack nmsItemStack = CraftItemStack.asNMSCopy(itemStack);
+
+        // Do *not* call the event here, the item is not in the player inventory, they are not dropping it / do not need recovering logic (which would be a dupe).
+        final ItemEntity droppedEntity = this.getHandle().drop(nmsItemStack, throwRandomly, true, false, entityOperation);
+        return droppedEntity == null ? null : (Item) droppedEntity.getBukkitEntity();
+    }
+
     @Override
     public float getExhaustion() {
         return this.getHandle().getFoodData().exhaustionLevel;
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftItem.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftItem.java
index 30d62ee4d5cd2ddacb8783b5bbbf475d592b3e02..7a3d982b133f8cdaeb936cf40f92565f0f7f6dd0 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftItem.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftItem.java
@@ -10,8 +10,8 @@ import org.bukkit.inventory.ItemStack;
 public class CraftItem extends CraftEntity implements Item {
 
     // Paper start
-    private final static int NO_AGE_TIME = (int) Short.MIN_VALUE;
-    private final static int NO_PICKUP_TIME = (int) Short.MAX_VALUE;
+    private final static int NO_AGE_TIME = Short.MIN_VALUE;
+    private final static int NO_PICKUP_TIME = Short.MAX_VALUE;
     // Paper end
 
     public CraftItem(CraftServer server, ItemEntity entity) {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPainting.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPainting.java
index b1b139b773b37e6ec2afea85c500387d6ba9800e..bcac1359c667ef1ee46384f9c7a5adf4010d2b08 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPainting.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPainting.java
@@ -16,7 +16,7 @@ public class CraftPainting extends CraftHanging implements Painting {
 
     @Override
     public Art getArt() {
-        return org.bukkit.craftbukkit.CraftRegistry.unwrapAndConvertHolder(org.bukkit.Registry.ART, this.getHandle().getVariant()).orElseThrow(() -> new IllegalStateException("Inlined painting variants are not supported yet in the API!")); // Paper
+        return CraftArt.minecraftHolderToBukkit(this.getHandle().getVariant());
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPhantom.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPhantom.java
index 83e77c6d287d8e239d2f55f3e9f19ef74946be7c..429200b0b06cc0f71db03924228240b8b5f22a55 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPhantom.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPhantom.java
@@ -32,17 +32,17 @@ public class CraftPhantom extends CraftFlying implements Phantom, CraftEnemy {
     // Paper start
     @Override
     public java.util.UUID getSpawningEntity() {
-        return getHandle().getSpawningEntity();
+        return this.getHandle().spawningEntity;
     }
 
     @Override
     public boolean shouldBurnInDay() {
-        return getHandle().shouldBurnInDay();
+        return this.getHandle().shouldBurnInDay;
     }
 
     @Override
     public void setShouldBurnInDay(boolean shouldBurnInDay) {
-        getHandle().setShouldBurnInDay(shouldBurnInDay);
+        this.getHandle().shouldBurnInDay = shouldBurnInDay;
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPig.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPig.java
index 8016c810aeaf6ee953bca549bc1e7f9a85f860fc..fd4f13e8ea000eb38efd77bfb197855db8816744 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPig.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPig.java
@@ -45,7 +45,7 @@ public class CraftPig extends CraftAnimals implements Pig {
         }
 
         int max = this.getHandle().steering.boostTimeTotal();
-        Preconditions.checkArgument(ticks >= 0 && ticks <= max, "boost ticks must not exceed 0 or %d (inclusive)", max);
+        Preconditions.checkArgument(ticks >= 0 && ticks <= max, "boost ticks must not exceed 0 or %s (inclusive)", max);
 
         this.getHandle().steering.boostTime = ticks;
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 6a647cab8b2e476987931486e290703b8726f2c7..f80f89a79faa1e5ea55bc27e91b1450ae38a6667 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -7,6 +7,7 @@ import com.mojang.authlib.GameProfile;
 import com.mojang.datafixers.util.Pair;
 import io.netty.buffer.Unpooled;
 import io.papermc.paper.FeatureHooks;
+import io.papermc.paper.entity.LookAnchor;
 import it.unimi.dsi.fastutil.shorts.ShortArraySet;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
 import java.io.ByteArrayOutputStream;
@@ -23,6 +24,7 @@ import java.util.Collection;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.LinkedList;
 import java.util.List;
@@ -543,7 +545,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public String getDisplayName() {
-        if(true) return io.papermc.paper.adventure.DisplayNames.getLegacy(this); // Paper
+        if (true) return io.papermc.paper.adventure.DisplayNames.getLegacy(this); // Paper
         return this.getHandle().displayName;
     }
 
@@ -1377,29 +1379,10 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     }
 
     @Override
-    public void lookAt(@NotNull org.bukkit.entity.Entity entity, @NotNull io.papermc.paper.entity.LookAnchor playerAnchor, @NotNull io.papermc.paper.entity.LookAnchor entityAnchor) {
+    public void lookAt(@NotNull org.bukkit.entity.Entity entity, @NotNull LookAnchor playerAnchor, @NotNull LookAnchor entityAnchor) {
         this.getHandle().lookAt(toNmsAnchor(playerAnchor), ((CraftEntity) entity).getHandle(), toNmsAnchor(entityAnchor));
     }
 
-    @Override
-    public void lookAt(double x, double y, double z, @NotNull io.papermc.paper.entity.LookAnchor playerAnchor) {
-        this.getHandle().lookAt(toNmsAnchor(playerAnchor), new net.minecraft.world.phys.Vec3(x, y, z));
-    }
-
-    public static net.minecraft.commands.arguments.EntityAnchorArgument.Anchor toNmsAnchor(io.papermc.paper.entity.LookAnchor nmsAnchor) {
-        return switch (nmsAnchor) {
-            case EYES -> net.minecraft.commands.arguments.EntityAnchorArgument.Anchor.EYES;
-            case FEET -> net.minecraft.commands.arguments.EntityAnchorArgument.Anchor.FEET;
-        };
-    }
-
-    public static io.papermc.paper.entity.LookAnchor toApiAnchor(net.minecraft.commands.arguments.EntityAnchorArgument.Anchor playerAnchor) {
-        return switch (playerAnchor) {
-            case EYES -> io.papermc.paper.entity.LookAnchor.EYES;
-            case FEET -> io.papermc.paper.entity.LookAnchor.FEET;
-        };
-    }
-
     public static net.minecraft.world.entity.Relative deltaRelativeToNMS(io.papermc.paper.entity.TeleportFlag.Relative apiFlag) {
         return switch (apiFlag) {
             case VELOCITY_X -> net.minecraft.world.entity.Relative.DELTA_X;
@@ -1896,7 +1879,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
                 handle.serverLevel(), itemstack, amount
             );
             int i = Math.min(possibleDurabilityFromXp, itemstack.getDamageValue());
-            final int consumedExperience = i * amount / possibleDurabilityFromXp; // Paper - taken from ExperienceOrb#repairPlayerItems
+            final int consumedExperience = i > 0 ? i * amount / possibleDurabilityFromXp : possibleDurabilityFromXp; // Paper - taken from ExperienceOrb#repairPlayerItems + prevent division by 0
             org.bukkit.event.player.PlayerItemMendEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerItemMendEvent(handle, orb, itemstack, stackEntry.get().inSlot(), i, consumedExperience);
             i = event.getRepairAmount();
             orb.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DESPAWN);
@@ -2876,9 +2859,11 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         if (!this.scaledHealth && !force) {
             return;
         }
-        for (AttributeInstance genericInstance : collection) {
+        Iterator<AttributeInstance> iterator = collection.iterator();
+        while (iterator.hasNext()) {
+            AttributeInstance genericInstance = iterator.next();
             if (genericInstance.getAttribute() == Attributes.MAX_HEALTH) {
-                collection.remove(genericInstance);
+                iterator.remove();
                 break;
             }
         }
@@ -3001,7 +2986,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra, T data, boolean force) {
-        ClientboundLevelParticlesPacket packetplayoutworldparticles = new ClientboundLevelParticlesPacket(CraftParticle.createParticleParam(particle, data), false, force, x, y, z, (float) offsetX, (float) offsetY, (float) offsetZ, (float) extra, count); // Paper - fix x/y/z precision loss
+        ClientboundLevelParticlesPacket packetplayoutworldparticles = new ClientboundLevelParticlesPacket(CraftParticle.createParticleParam(particle, data), force, false, x, y, z, (float) offsetX, (float) offsetY, (float) offsetZ, (float) extra, count); // Paper - fix x/y/z precision loss
         this.getHandle().connection.send(packetplayoutworldparticles);
     }
 
@@ -3522,38 +3507,32 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public int getViewDistance() {
-        return ca.spottedleaf.moonrise.common.util.ChunkSystem.getViewDistance(this.getHandle());
+        return ca.spottedleaf.moonrise.common.PlatformHooks.get().getViewDistance(this.getHandle());
     }
 
     @Override
     public void setViewDistance(final int viewDistance) {
-        // Paper - rewrite chunk system - TODO do this better
-        ((ca.spottedleaf.moonrise.patches.chunk_system.player.ChunkSystemServerPlayer)this.getHandle())
-            .moonrise$getViewDistanceHolder().setLoadViewDistance(viewDistance + 1);
+        FeatureHooks.setViewDistance(this.getHandle(), viewDistance); // Paper - chunk system
     }
 
     @Override
     public int getSimulationDistance() {
-        return ca.spottedleaf.moonrise.common.util.ChunkSystem.getTickViewDistance(this.getHandle());
+        return ca.spottedleaf.moonrise.common.PlatformHooks.get().getTickViewDistance(this.getHandle());
     }
 
     @Override
     public void setSimulationDistance(final int simulationDistance) {
-        // Paper - rewrite chunk system - TODO do this better
-        ((ca.spottedleaf.moonrise.patches.chunk_system.player.ChunkSystemServerPlayer)this.getHandle())
-            .moonrise$getViewDistanceHolder().setTickViewDistance(simulationDistance);
+        FeatureHooks.setSimulationDistance(this.getHandle(), simulationDistance); // Paper - chunk system
     }
 
     @Override
     public int getSendViewDistance() {
-        return ca.spottedleaf.moonrise.common.util.ChunkSystem.getSendViewDistance(this.getHandle());
+        return ca.spottedleaf.moonrise.common.PlatformHooks.get().getSendViewDistance(this.getHandle());
     }
 
     @Override
     public void setSendViewDistance(final int viewDistance) {
-        // Paper - rewrite chunk system - TODO do this better
-        ((ca.spottedleaf.moonrise.patches.chunk_system.player.ChunkSystemServerPlayer)this.getHandle())
-            .moonrise$getViewDistanceHolder().setSendViewDistance(viewDistance);
+        FeatureHooks.setSendViewDistance(this.getHandle(), viewDistance); // Paper - chunk system
     }
 
     // Paper start - entity effect API
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftStrider.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftStrider.java
index 9472a6f9c9584048abf1f8d11ab6254b7c7a287d..74fac97231d4d89d1b941a1b5295afc2dafc6007 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftStrider.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftStrider.java
@@ -55,7 +55,7 @@ public class CraftStrider extends CraftAnimals implements Strider {
         }
 
         int max = this.getHandle().steering.boostTimeTotal();
-        Preconditions.checkArgument(ticks >= 0 && ticks <= max, "boost ticks must not exceed 0 or %d (inclusive)", max);
+        Preconditions.checkArgument(ticks >= 0 && ticks <= max, "boost ticks must not exceed 0 or %s (inclusive)", max);
 
         this.getHandle().steering.boostTime = ticks;
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftTurtle.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftTurtle.java
index d44e6f4bb682d18c1497eee9fb2802f2bda6e840..00e59cdc8c0b954eed84c611e91d00dfd5676ec1 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftTurtle.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftTurtle.java
@@ -29,7 +29,6 @@ public class CraftTurtle extends CraftAnimals implements Turtle {
         return this.getHandle().isLayingEgg();
     }
 
-    // Paper start
     @Override
     public org.bukkit.Location getHome() {
         return io.papermc.paper.util.MCUtil.toLocation(this.getHandle().level(), this.getHandle().getHomePos());
@@ -45,14 +44,8 @@ public class CraftTurtle extends CraftAnimals implements Turtle {
         return this.getHandle().isGoingHome();
     }
 
-    @Override
-    public boolean isDigging() {
-        return this.getHandle().isLayingEgg();
-    }
-
     @Override
     public void setHasEgg(boolean hasEgg) {
         this.getHandle().setHasEgg(hasEgg);
     }
-    // Paper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftVillager.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftVillager.java
index 8e895d6f84f7d84b219f2424909dd42e5f08dec4..aaddce10e1d41531939d1e7f3d717b458ec1b7ab 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftVillager.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftVillager.java
@@ -11,7 +11,6 @@ import net.minecraft.world.level.block.BedBlock;
 import net.minecraft.world.level.block.state.BlockState;
 import org.bukkit.Location;
 import org.bukkit.NamespacedKey;
-import org.bukkit.Registry;
 import org.bukkit.craftbukkit.CraftRegistry;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.util.CraftLocation;
@@ -23,7 +22,6 @@ import org.bukkit.event.entity.EntityTransformEvent;
 
 // Paper start
 import com.destroystokyo.paper.entity.villager.Reputation;
-import com.google.common.collect.Maps;
 import java.util.Map;
 import java.util.UUID;
 // Paper end
@@ -177,7 +175,7 @@ public class CraftVillager extends CraftAbstractVillager implements Villager {
         private static int count = 0;
 
         public static Type minecraftToBukkit(VillagerType minecraft) {
-            return CraftRegistry.minecraftToBukkit(minecraft, Registries.VILLAGER_TYPE, Registry.VILLAGER_TYPE);
+            return CraftRegistry.minecraftToBukkit(minecraft, Registries.VILLAGER_TYPE);
         }
 
         public static VillagerType bukkitToMinecraft(Type bukkit) {
@@ -258,7 +256,7 @@ public class CraftVillager extends CraftAbstractVillager implements Villager {
         private static int count = 0;
 
         public static Profession minecraftToBukkit(VillagerProfession minecraft) {
-            return CraftRegistry.minecraftToBukkit(minecraft, Registries.VILLAGER_PROFESSION, Registry.VILLAGER_PROFESSION);
+            return CraftRegistry.minecraftToBukkit(minecraft, Registries.VILLAGER_PROFESSION);
         }
 
         public static VillagerProfession bukkitToMinecraft(Profession bukkit) {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftWolf.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftWolf.java
index ecd33b4add46acbe4e4f8879c0601220423d66ca..c1b7f1281fbd41e765d2c1881763ca25b20e924d 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftWolf.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftWolf.java
@@ -6,7 +6,6 @@ import net.minecraft.core.registries.Registries;
 import net.minecraft.world.entity.animal.WolfVariant;
 import org.bukkit.DyeColor;
 import org.bukkit.NamespacedKey;
-import org.bukkit.Registry;
 import org.bukkit.craftbukkit.CraftRegistry;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.util.Handleable;
@@ -81,7 +80,7 @@ public class CraftWolf extends CraftTameableAnimal implements Wolf {
     public static class CraftVariant implements Variant, Handleable<WolfVariant> {
 
         public static Variant minecraftToBukkit(WolfVariant minecraft) {
-            return CraftRegistry.minecraftToBukkit(minecraft, Registries.WOLF_VARIANT, Registry.WOLF_VARIANT);
+            return CraftRegistry.minecraftToBukkit(minecraft, Registries.WOLF_VARIANT);
         }
 
         public static Variant minecraftHolderToBukkit(Holder<WolfVariant> minecraft) {
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index e37aaf77f94b97b736cc20ef070cefdff0400188..d7a52220e9525502163f5ee6afbadf2baaae6190 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -1430,6 +1430,7 @@ public class CraftEventFactory {
     }
     public static com.mojang.datafixers.util.Pair<net.kyori.adventure.text.@org.jetbrains.annotations.Nullable Component, @org.jetbrains.annotations.Nullable AbstractContainerMenu> callInventoryOpenEventWithTitle(ServerPlayer player, AbstractContainerMenu container, boolean cancelled) {
         // Paper end - Add titleOverride to InventoryOpenEvent
+        container.startOpen(); // delegate start open logic to before InventoryOpenEvent is fired
         if (player.containerMenu != player.inventoryMenu) { // fire INVENTORY_CLOSE if one already open
             player.connection.handleContainerClose(new ServerboundContainerClosePacket(player.containerMenu.containerId), InventoryCloseEvent.Reason.OPEN_NEW); // Paper - Inventory close reason
         }
diff --git a/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java b/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
index c025a4ff42257a4e84f0f9574b84f6987ef8ac11..c60c05b9e426f56ed3e812abb9aae9ef52bd20e8 100644
--- a/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
+++ b/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
@@ -264,7 +264,7 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
             return ichunkaccess1;
         };
 
-        return future == null ? CompletableFuture.supplyAsync(() -> function.apply(chunk), Runnable::run) : future.thenApply(function); // Paper - rewrite chunk system
+        return future == null ? CompletableFuture.supplyAsync(() -> function.apply(chunk), io.papermc.paper.FeatureHooks.getWorldgenExecutor()) : future.thenApply(function); // Paper - chunk system
     }
 
     @Override
@@ -291,13 +291,13 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
     }
 
     @Override
-    public void applyBiomeDecoration(WorldGenLevel world, ChunkAccess chunk, StructureManager structureAccessor) {
+    public void applyBiomeDecoration(WorldGenLevel level, ChunkAccess chunk, StructureManager structureManager) {
         WorldgenRandom random = CustomChunkGenerator.getSeededRandom();
         int x = chunk.getPos().x;
         int z = chunk.getPos().z;
 
-        random.setSeed(Mth.getSeed(x, "should-decoration".hashCode(), z) ^ world.getSeed());
-        super.applyBiomeDecoration(world, chunk, structureAccessor, this.generator.shouldGenerateDecorations(this.world.getWorld(), new RandomSourceWrapper.RandomWrapper(random), x, z));
+        random.setSeed(Mth.getSeed(x, "should-decoration".hashCode(), z) ^ level.getSeed());
+        super.applyBiomeDecoration(level, chunk, structureManager, this.generator.shouldGenerateDecorations(this.world.getWorld(), new RandomSourceWrapper.RandomWrapper(random), x, z));
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/generator/structure/CraftStructure.java b/src/main/java/org/bukkit/craftbukkit/generator/structure/CraftStructure.java
index 7ef679fdd2c0e44f357967e51606cdbef2d2cdb3..75f589e8353cc605e396b9a14d7881abd0f6bfbd 100644
--- a/src/main/java/org/bukkit/craftbukkit/generator/structure/CraftStructure.java
+++ b/src/main/java/org/bukkit/craftbukkit/generator/structure/CraftStructure.java
@@ -4,7 +4,6 @@ import com.google.common.base.Suppliers;
 import java.util.function.Supplier;
 import net.minecraft.core.registries.Registries;
 import org.bukkit.NamespacedKey;
-import org.bukkit.Registry;
 import org.bukkit.craftbukkit.CraftRegistry;
 import org.bukkit.craftbukkit.util.Handleable;
 import org.bukkit.generator.structure.Structure;
@@ -13,7 +12,7 @@ import org.bukkit.generator.structure.StructureType;
 public class CraftStructure extends Structure implements Handleable<net.minecraft.world.level.levelgen.structure.Structure> {
 
     public static Structure minecraftToBukkit(net.minecraft.world.level.levelgen.structure.Structure minecraft) {
-        return CraftRegistry.minecraftToBukkit(minecraft, Registries.STRUCTURE, Registry.STRUCTURE);
+        return CraftRegistry.minecraftToBukkit(minecraft, Registries.STRUCTURE);
     }
 
     public static net.minecraft.world.level.levelgen.structure.Structure bukkitToMinecraft(Structure bukkit) {
@@ -42,7 +41,6 @@ public class CraftStructure extends Structure implements Handleable<net.minecraf
 
     @Override
     public NamespacedKey getKey() {
-        if (true) return java.util.Objects.requireNonNull(org.bukkit.Registry.STRUCTURE.getKey(this), () -> this + " doesn't have a key"); // Paper
         return this.key;
     }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/generator/structure/CraftStructureType.java b/src/main/java/org/bukkit/craftbukkit/generator/structure/CraftStructureType.java
index 7199847c7d43c5dccbc864351729fa13b9279692..cd2d04c1b26136427f351a995862c50ea62f43a9 100644
--- a/src/main/java/org/bukkit/craftbukkit/generator/structure/CraftStructureType.java
+++ b/src/main/java/org/bukkit/craftbukkit/generator/structure/CraftStructureType.java
@@ -2,7 +2,6 @@ package org.bukkit.craftbukkit.generator.structure;
 
 import net.minecraft.core.registries.Registries;
 import org.bukkit.NamespacedKey;
-import org.bukkit.Registry;
 import org.bukkit.craftbukkit.CraftRegistry;
 import org.bukkit.craftbukkit.util.Handleable;
 import org.bukkit.generator.structure.StructureType;
@@ -10,7 +9,7 @@ import org.bukkit.generator.structure.StructureType;
 public class CraftStructureType extends StructureType implements Handleable<net.minecraft.world.level.levelgen.structure.StructureType<?>> {
 
     public static StructureType minecraftToBukkit(net.minecraft.world.level.levelgen.structure.StructureType<?> minecraft) {
-        return CraftRegistry.minecraftToBukkit(minecraft, Registries.STRUCTURE_TYPE, Registry.STRUCTURE_TYPE);
+        return CraftRegistry.minecraftToBukkit(minecraft, Registries.STRUCTURE_TYPE);
     }
 
     public static net.minecraft.world.level.levelgen.structure.StructureType<?> bukkitToMinecraft(StructureType bukkit) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftBlockInventoryHolder.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftBlockInventoryHolder.java
index 7129eb5f5cea39992b4c690cb421004004a952ea..1407ff1034e566d6e29cf441b7895f47eb998e9e 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftBlockInventoryHolder.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftBlockInventoryHolder.java
@@ -13,9 +13,9 @@ public class CraftBlockInventoryHolder implements BlockInventoryHolder {
     private final Block block;
     private final Inventory inventory;
 
-    public CraftBlockInventoryHolder(LevelAccessor world, BlockPos pos, Container inv) {
-        this.block = CraftBlock.at(world, pos);
-        this.inventory = new CraftInventory(inv);
+    public CraftBlockInventoryHolder(LevelAccessor levelAccessor, BlockPos pos, Container container) {
+        this.block = CraftBlock.at(levelAccessor, pos);
+        this.inventory = new CraftInventory(container);
     }
     // Paper start - Add missing InventoryHolders
     public CraftBlockInventoryHolder(net.minecraft.world.inventory.ContainerLevelAccess levelAccess, Inventory inventory) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftContainer.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftContainer.java
index 6d3f9d5dab6c9a2860ae31cae24310aa2d62da7c..1ce328bed5cf3d087a3f7dc9236153381d758493 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftContainer.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftContainer.java
@@ -132,7 +132,7 @@ public class CraftContainer extends AbstractContainerMenu {
                 if (menu == null) {
                     return net.minecraft.world.inventory.MenuType.GENERIC_9x3;
                 } else {
-                    return ((CraftMenuType<?>) menu).getHandle();
+                    return ((CraftMenuType<?, ?>) menu).getHandle();
                 }
         }
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryCustom.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryCustom.java
index da1c1fe0faf6819b15a81d6ad53370948e5f984f..393e44cd3ed8d9f43b0ab42dbf2f9e82e8512dbd 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryCustom.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryCustom.java
@@ -194,13 +194,13 @@ public class CraftInventoryCustom extends CraftInventory {
         }
 
         @Override
-        public void onOpen(CraftHumanEntity who) {
-            this.viewers.add(who);
+        public void onOpen(CraftHumanEntity player) {
+            this.viewers.add(player);
         }
 
         @Override
-        public void onClose(CraftHumanEntity who) {
-            this.viewers.remove(who);
+        public void onClose(CraftHumanEntity player) {
+            this.viewers.remove(player);
         }
 
         @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryDoubleChest.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryDoubleChest.java
index c3e2c9e2c3cbec2eda38096b6482bac1a0ea1dce..67f9ec03c44791808a98b14c1bc1d622eec31308 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryDoubleChest.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryDoubleChest.java
@@ -16,10 +16,10 @@ public class CraftInventoryDoubleChest extends CraftInventory implements DoubleC
     private final CraftInventory right;
 
     public CraftInventoryDoubleChest(ChestBlock.DoubleInventory block) {
-        super(block.inventorylargechest);
+        super(block.container);
         this.tile = block;
-        this.left = new CraftInventory(block.inventorylargechest.container1);
-        this.right = new CraftInventory(block.inventorylargechest.container2);
+        this.left = new CraftInventory(block.container.container1);
+        this.right = new CraftInventory(block.container.container2);
     }
 
     public CraftInventoryDoubleChest(CompoundContainer largeChest) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
index 78975412da0f0c2b802bfce6d30d56b26d8023e2..3799973696eabbdc992bee4ff24175fc28ec8d7c 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
@@ -5,6 +5,8 @@ import com.google.common.collect.ImmutableMap;
 import java.util.Collections;
 import java.util.Map;
 import java.util.Optional;
+import io.papermc.paper.adventure.PaperAdventure;
+import net.kyori.adventure.text.Component;
 import net.minecraft.advancements.critereon.ItemPredicate;
 import net.minecraft.advancements.critereon.MinMaxBounds;
 import net.minecraft.core.Holder;
@@ -25,6 +27,7 @@ import org.bukkit.enchantments.Enchantment;
 import org.bukkit.inventory.ItemStack;
 import org.bukkit.inventory.meta.ItemMeta;
 import org.bukkit.material.MaterialData;
+import org.jetbrains.annotations.NotNull;
 
 @DelegateDeserialization(ItemStack.class)
 public final class CraftItemStack extends ItemStack {
@@ -467,6 +470,11 @@ public final class CraftItemStack extends ItemStack {
         return true;
     }
 
+    @Override
+    public @NotNull Component effectiveName() {
+        return this.handle == null ? Component.empty() : PaperAdventure.asAdventure(this.handle.getStyledHoverName());
+    }
+
     @Override
     public boolean isSimilar(ItemStack stack) {
         if (stack == null) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemType.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemType.java
index b0da057ce5124cb60b6249e13d7a5771601af937..24ff46293304c2859963863b01157136a146f598 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemType.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemType.java
@@ -51,7 +51,7 @@ public class CraftItemType<M extends ItemMeta> implements ItemType.Typed<M>, Han
     }
 
     public static ItemType minecraftToBukkitNew(Item minecraft) {
-        return CraftRegistry.minecraftToBukkit(minecraft, Registries.ITEM, Registry.ITEM);
+        return CraftRegistry.minecraftToBukkit(minecraft, Registries.ITEM);
     }
 
     public static Item bukkitToMinecraftNew(ItemType bukkit) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMenuType.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMenuType.java
index fbde94b72063da69cc1a1f7934e069c6c8c0f804..4c6cf43cee404385d2d0ae26784ef04f3476ee47 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMenuType.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMenuType.java
@@ -8,21 +8,21 @@ import net.minecraft.core.registries.Registries;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.inventory.AbstractContainerMenu;
 import org.bukkit.NamespacedKey;
-import org.bukkit.Registry;
 import org.bukkit.craftbukkit.CraftRegistry;
 import org.bukkit.craftbukkit.entity.CraftHumanEntity;
 import org.bukkit.craftbukkit.inventory.util.CraftMenus;
-import org.bukkit.craftbukkit.util.CraftChatMessage;
 import org.bukkit.craftbukkit.util.Handleable;
 import org.bukkit.entity.HumanEntity;
 import org.bukkit.inventory.InventoryView;
 import org.bukkit.inventory.MenuType;
+import org.bukkit.inventory.view.builder.InventoryViewBuilder;
+import org.jetbrains.annotations.NotNull;
 
-public class CraftMenuType<V extends InventoryView> implements MenuType.Typed<V>, Handleable<net.minecraft.world.inventory.MenuType<?>>, io.papermc.paper.world.flag.PaperFeatureDependent { // Paper - make FeatureDependant
+public class CraftMenuType<V extends InventoryView, B extends InventoryViewBuilder<V>> implements MenuType.Typed<V, B>, Handleable<net.minecraft.world.inventory.MenuType<?>>, io.papermc.paper.world.flag.PaperFeatureDependent { // Paper - make FeatureDependant
 
     private final NamespacedKey key;
     private final net.minecraft.world.inventory.MenuType<?> handle;
-    private final Supplier<CraftMenus.MenuTypeData<V>> typeData;
+    private final Supplier<CraftMenus.MenuTypeData<V, B>> typeData;
 
     public CraftMenuType(NamespacedKey key, net.minecraft.world.inventory.MenuType<?> handle) {
         this.key = key;
@@ -38,33 +38,28 @@ public class CraftMenuType<V extends InventoryView> implements MenuType.Typed<V>
     @Override
     public V create(final HumanEntity player, final String title) {
     // Paper start - adventure
-        return create(player, net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(title));
+        return builder().title(net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(title)).build(player);
     }
     @Override
     public V create(final HumanEntity player, final net.kyori.adventure.text.Component title) {
     // Paper end - adventure
-        Preconditions.checkArgument(player != null, "The given player must not be null");
-        Preconditions.checkArgument(title != null, "The given title must not be null");
-        Preconditions.checkArgument(player instanceof CraftHumanEntity, "The given player must be a CraftHumanEntity");
-        final CraftHumanEntity craftHuman = (CraftHumanEntity) player;
-        Preconditions.checkArgument(craftHuman.getHandle() instanceof ServerPlayer, "The given player must be an EntityPlayer");
-        final ServerPlayer serverPlayer = (ServerPlayer) craftHuman.getHandle();
+        return builder().title(title).build(player);
+    }
 
-        final AbstractContainerMenu container = this.typeData.get().menuBuilder().build(serverPlayer, this.handle);
-        container.setTitle(io.papermc.paper.adventure.PaperAdventure.asVanilla(title)); // Paper - adventure
-        container.checkReachable = false;
-        return (V) container.getBukkitView();
+    @Override
+    public B builder() {
+        return typeData.get().viewBuilder().get();
     }
 
     @Override
-    public Typed<InventoryView> typed() {
+    public Typed<InventoryView, InventoryViewBuilder<InventoryView>> typed() {
         return this.typed(InventoryView.class);
     }
 
     @Override
-    public <V extends InventoryView> Typed<V> typed(Class<V> clazz) {
+    public <V extends InventoryView, B extends InventoryViewBuilder<V>> Typed<V, B> typed(Class<V> clazz) {
         if (clazz.isAssignableFrom(this.typeData.get().viewClass())) {
-            return (Typed<V>) this;
+            return (Typed<V, B>) this;
         }
 
         throw new IllegalArgumentException("Cannot type InventoryView " + this.key.toString() + " to InventoryView type " + clazz.getSimpleName());
@@ -85,7 +80,7 @@ public class CraftMenuType<V extends InventoryView> implements MenuType.Typed<V>
     }
 
     public static MenuType minecraftToBukkit(net.minecraft.world.inventory.MenuType<?> minecraft) {
-        return CraftRegistry.minecraftToBukkit(minecraft, Registries.MENU, Registry.MENU);
+        return CraftRegistry.minecraftToBukkit(minecraft, Registries.MENU);
     }
 
     public static MenuType minecraftHolderToBukkit(Holder<net.minecraft.world.inventory.MenuType<?>> minecraft) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBanner.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBanner.java
index fdc0c1d73bb523f003e4169589f1002375b9c88c..30cc01cf1a0370fe2956f8a19dd843ef99899133 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBanner.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBanner.java
@@ -3,6 +3,7 @@ package org.bukkit.craftbukkit.inventory;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
+import io.papermc.paper.registry.RegistryKey;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
@@ -42,7 +43,7 @@ public class CraftMetaBanner extends CraftMetaItem implements BannerMeta {
             for (int i = 0; i < Math.min(patterns.size(), 20); i++) {
                 BannerPatternLayers.Layer p = patterns.get(i);
                 DyeColor color = DyeColor.getByWoolData((byte) p.color().getId());
-                PatternType pattern = org.bukkit.craftbukkit.CraftRegistry.unwrapAndConvertHolder(org.bukkit.Registry.BANNER_PATTERN, p.pattern()).orElse(null); // Paper - fix upstream not handling inlined banner pattern
+                PatternType pattern = org.bukkit.craftbukkit.CraftRegistry.unwrapAndConvertHolder(RegistryKey.BANNER_PATTERN, p.pattern()).orElse(null); // Paper - fix upstream not handling inlined banner pattern
 
                 if (color != null && pattern != null) {
                     this.patterns.add(new Pattern(color, pattern));
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
index 01ea7cdedd622ff6b023f56d3b91d03e7fcbc1a3..eb7d90cfa99f6e1a13058db76b60c874b7f7a649 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
@@ -2361,7 +2361,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
 
         for (Object object : addFrom) {
             // Paper start - support components
-            if(object instanceof net.md_5.bungee.api.chat.BaseComponent[] baseComponentArr) {
+            if (object instanceof net.md_5.bungee.api.chat.BaseComponent[] baseComponentArr) {
                 addTo.add(CraftChatMessage.fromJSON(net.md_5.bungee.chat.ComponentSerializer.toString(baseComponentArr)));
             } else
             // Paper end
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/trim/CraftTrimMaterial.java b/src/main/java/org/bukkit/craftbukkit/inventory/trim/CraftTrimMaterial.java
index afee459c4d2d0945bdc99c2ab46f9dcf6dac8798..5595be33b76e22cd7dd6dd0109f25772bf7649c1 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/trim/CraftTrimMaterial.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/trim/CraftTrimMaterial.java
@@ -1,24 +1,25 @@
 package org.bukkit.craftbukkit.inventory.trim;
 
 import com.google.common.base.Preconditions;
+import io.papermc.paper.registry.RegistryKey;
+import io.papermc.paper.util.Holderable;
 import net.minecraft.core.Holder;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.network.chat.contents.TranslatableContents;
 import org.bukkit.NamespacedKey;
 import org.bukkit.Registry;
 import org.bukkit.craftbukkit.CraftRegistry;
-import org.bukkit.craftbukkit.util.Handleable;
 import org.bukkit.inventory.meta.trim.TrimMaterial;
 import org.jetbrains.annotations.NotNull;
 
 public class CraftTrimMaterial implements TrimMaterial, io.papermc.paper.util.Holderable<net.minecraft.world.item.equipment.trim.TrimMaterial> { // Paper - switch to Holder
 
     public static TrimMaterial minecraftToBukkit(net.minecraft.world.item.equipment.trim.TrimMaterial minecraft) {
-        return CraftRegistry.minecraftToBukkit(minecraft, Registries.TRIM_MATERIAL, Registry.TRIM_MATERIAL);
+        return CraftRegistry.minecraftToBukkit(minecraft, Registries.TRIM_MATERIAL);
     }
 
     public static TrimMaterial minecraftHolderToBukkit(Holder<net.minecraft.world.item.equipment.trim.TrimMaterial> minecraft) {
-        return CraftRegistry.minecraftHolderToBukkit(minecraft, Registry.TRIM_MATERIAL); // Paper - switch to Holder
+        return CraftRegistry.minecraftHolderToBukkit(minecraft, Registries.TRIM_MATERIAL); // Paper - switch to Holder
     }
 
     public static net.minecraft.world.item.equipment.trim.TrimMaterial bukkitToMinecraft(TrimMaterial bukkit) {
@@ -29,22 +30,19 @@ public class CraftTrimMaterial implements TrimMaterial, io.papermc.paper.util.Ho
         return CraftRegistry.bukkitToMinecraftHolder(bukkit, Registries.TRIM_MATERIAL); // Paper - switch to Holder
     }
 
-    private final NamespacedKey key;
-    private final net.minecraft.world.item.equipment.trim.TrimMaterial handle;
-
     // Paper start - switch to Holder
     private final Holder<net.minecraft.world.item.equipment.trim.TrimMaterial> holder;
 
     public static Object bukkitToObject(TrimMaterial bukkit) {
         Preconditions.checkArgument(bukkit != null);
 
-        return ((CraftTrimMaterial) bukkit).toBukkitSerializationObject(net.minecraft.world.item.equipment.trim.TrimMaterial.CODEC); // Paper - switch to Holder
+        return ((CraftTrimMaterial) bukkit).toBukkitSerializationObject(net.minecraft.world.item.equipment.trim.TrimMaterial.DIRECT_CODEC); // Paper - switch to Holder
     }
 
     public static TrimMaterial objectToBukkit(Object object) {
         Preconditions.checkArgument(object != null);
 
-        return io.papermc.paper.util.Holderable.fromBukkitSerializationObject(object, net.minecraft.world.item.equipment.trim.TrimMaterial.CODEC, Registry.TRIM_MATERIAL); // Paper - switch to Holder
+        return io.papermc.paper.util.Holderable.fromBukkitSerializationObject(object, net.minecraft.world.item.equipment.trim.TrimMaterial.CODEC, RegistryKey.TRIM_MATERIAL); // Paper - switch to Holder
     }
 
     @Override
@@ -63,8 +61,6 @@ public class CraftTrimMaterial implements TrimMaterial, io.papermc.paper.util.Ho
     }
 
     public CraftTrimMaterial(final Holder<net.minecraft.world.item.equipment.trim.TrimMaterial> holder) {
-        this.key = holder.unwrapKey().map(io.papermc.paper.util.MCUtil::fromResourceKey).orElse(null);
-        this.handle = holder.value();
         this.holder = holder;
         // Paper end - switch to Holder
     }
@@ -77,21 +73,20 @@ public class CraftTrimMaterial implements TrimMaterial, io.papermc.paper.util.Ho
     @Override
     @NotNull
     public NamespacedKey getKey() {
-        if (true) return java.util.Objects.requireNonNull(org.bukkit.Registry.TRIM_MATERIAL.getKey(this), () -> this + " doesn't have a key"); // Paper
-        return this.key;
+        return Holderable.super.getKey();
     }
 
     @NotNull
     @Override
     public String getTranslationKey() {
-        if (!(this.handle.description().getContents() instanceof TranslatableContents)) throw new UnsupportedOperationException("Description isn't translatable!"); // Paper
-        return ((TranslatableContents) this.handle.description().getContents()).getKey();
+        if (!(this.getHandle().description().getContents() instanceof TranslatableContents)) throw new UnsupportedOperationException("Description isn't translatable!"); // Paper
+        return ((TranslatableContents) this.getHandle().description().getContents()).getKey();
     }
 
     // Paper start - adventure
     @Override
     public net.kyori.adventure.text.Component description() {
-        return io.papermc.paper.adventure.PaperAdventure.asAdventure(this.handle.description());
+        return io.papermc.paper.adventure.PaperAdventure.asAdventure(this.getHandle().description());
     }
     // Paper end - adventure
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/trim/CraftTrimPattern.java b/src/main/java/org/bukkit/craftbukkit/inventory/trim/CraftTrimPattern.java
index da951bd7e470d8b2bc69eea9b66815fa4fa445aa..031361c750f7dcc997ec4aa297cae5d61015aaff 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/trim/CraftTrimPattern.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/trim/CraftTrimPattern.java
@@ -1,24 +1,25 @@
 package org.bukkit.craftbukkit.inventory.trim;
 
 import com.google.common.base.Preconditions;
+import io.papermc.paper.registry.RegistryKey;
+import io.papermc.paper.util.Holderable;
 import net.minecraft.core.Holder;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.network.chat.contents.TranslatableContents;
 import org.bukkit.NamespacedKey;
 import org.bukkit.Registry;
 import org.bukkit.craftbukkit.CraftRegistry;
-import org.bukkit.craftbukkit.util.Handleable;
 import org.bukkit.inventory.meta.trim.TrimPattern;
 import org.jetbrains.annotations.NotNull;
 
 public class CraftTrimPattern implements TrimPattern, io.papermc.paper.util.Holderable<net.minecraft.world.item.equipment.trim.TrimPattern> { // Paper - switch to Holder
 
     public static TrimPattern minecraftToBukkit(net.minecraft.world.item.equipment.trim.TrimPattern minecraft) {
-        return CraftRegistry.minecraftToBukkit(minecraft, Registries.TRIM_PATTERN, Registry.TRIM_PATTERN);
+        return CraftRegistry.minecraftToBukkit(minecraft, Registries.TRIM_PATTERN);
     }
 
     public static TrimPattern minecraftHolderToBukkit(Holder<net.minecraft.world.item.equipment.trim.TrimPattern> minecraft) {
-        return CraftRegistry.minecraftHolderToBukkit(minecraft, Registry.TRIM_PATTERN); // Paper - switch to Holder
+        return CraftRegistry.minecraftHolderToBukkit(minecraft, Registries.TRIM_PATTERN); // Paper - switch to Holder
     }
 
     public static net.minecraft.world.item.equipment.trim.TrimPattern bukkitToMinecraft(TrimPattern bukkit) {
@@ -29,22 +30,19 @@ public class CraftTrimPattern implements TrimPattern, io.papermc.paper.util.Hold
         return CraftRegistry.bukkitToMinecraftHolder(bukkit, Registries.TRIM_PATTERN); // Paper - switch to Holder
     }
 
-    private final NamespacedKey key;
-    private final net.minecraft.world.item.equipment.trim.TrimPattern handle;
-
     // Paper start - switch to Holder
     private final Holder<net.minecraft.world.item.equipment.trim.TrimPattern> holder; // Paper - switch to Holder
 
     public static Object bukkitToObject(TrimPattern bukkit) {
         Preconditions.checkArgument(bukkit != null);
 
-        return ((CraftTrimPattern) bukkit).toBukkitSerializationObject(net.minecraft.world.item.equipment.trim.TrimPattern.CODEC); // Paper - switch to Holder
+        return ((CraftTrimPattern) bukkit).toBukkitSerializationObject(net.minecraft.world.item.equipment.trim.TrimPattern.DIRECT_CODEC); // Paper - switch to Holder
     }
 
     public static TrimPattern objectToBukkit(Object object) {
         Preconditions.checkArgument(object != null);
 
-        return io.papermc.paper.util.Holderable.fromBukkitSerializationObject(object, net.minecraft.world.item.equipment.trim.TrimPattern.CODEC, Registry.TRIM_PATTERN); // Paper - switch to Holder
+        return io.papermc.paper.util.Holderable.fromBukkitSerializationObject(object, net.minecraft.world.item.equipment.trim.TrimPattern.CODEC, RegistryKey.TRIM_PATTERN); // Paper - switch to Holder
     }
 
     @Override
@@ -63,8 +61,6 @@ public class CraftTrimPattern implements TrimPattern, io.papermc.paper.util.Hold
     }
 
     public CraftTrimPattern(Holder<net.minecraft.world.item.equipment.trim.TrimPattern> handle) {
-        this.key = handle.unwrapKey().map(io.papermc.paper.util.MCUtil::fromResourceKey).orElse(null);
-        this.handle = handle.value();
         this.holder = handle;
         // Paper end - switch to Holder
     }
@@ -77,21 +73,20 @@ public class CraftTrimPattern implements TrimPattern, io.papermc.paper.util.Hold
     @Override
     @NotNull
     public NamespacedKey getKey() {
-        if (true) return java.util.Objects.requireNonNull(org.bukkit.Registry.TRIM_PATTERN.getKey(this), () -> this + " doesn't have a key"); // Paper
-        return this.key;
+        return Holderable.super.getKey();
     }
 
     @NotNull
     @Override
     public String getTranslationKey() {
-        if (!(this.handle.description().getContents() instanceof TranslatableContents)) throw new UnsupportedOperationException("Description isn't translatable!"); // Paper
-        return ((TranslatableContents) this.handle.description().getContents()).getKey();
+        if (!(this.getHandle().description().getContents() instanceof TranslatableContents)) throw new UnsupportedOperationException("Description isn't translatable!"); // Paper
+        return ((TranslatableContents) this.getHandle().description().getContents()).getKey();
     }
 
     // Paper start - adventure
     @Override
     public net.kyori.adventure.text.Component description() {
-        return io.papermc.paper.adventure.PaperAdventure.asAdventure(this.handle.description());
+        return io.papermc.paper.adventure.PaperAdventure.asAdventure(this.getHandle().description());
     }
     // Paper end - adventure
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/util/CraftMenus.java b/src/main/java/org/bukkit/craftbukkit/inventory/util/CraftMenus.java
index 66e93f8444d0f9c3a4acad898a3bd40dc433db41..84c35792c4c372f735e87e70e164258a7a6c8981 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/util/CraftMenus.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/util/CraftMenus.java
@@ -1,16 +1,18 @@
 package org.bukkit.craftbukkit.inventory.util;
 
-import static org.bukkit.craftbukkit.inventory.util.CraftMenuBuilder.*;
-
-import net.minecraft.network.chat.Component;
-import net.minecraft.world.SimpleMenuProvider;
+import net.minecraft.network.protocol.game.ClientboundOpenScreenPacket;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.npc.Villager;
 import net.minecraft.world.inventory.AnvilMenu;
 import net.minecraft.world.inventory.CartographyTableMenu;
 import net.minecraft.world.inventory.CraftingMenu;
 import net.minecraft.world.inventory.EnchantmentMenu;
 import net.minecraft.world.inventory.GrindstoneMenu;
+import net.minecraft.world.inventory.MerchantMenu;
 import net.minecraft.world.inventory.SmithingMenu;
 import net.minecraft.world.inventory.StonecutterMenu;
+import net.minecraft.world.item.trading.Merchant;
+import net.minecraft.world.item.trading.MerchantOffers;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.entity.BeaconBlockEntity;
 import net.minecraft.world.level.block.entity.BlastFurnaceBlockEntity;
@@ -20,8 +22,15 @@ import net.minecraft.world.level.block.entity.DispenserBlockEntity;
 import net.minecraft.world.level.block.entity.FurnaceBlockEntity;
 import net.minecraft.world.level.block.entity.HopperBlockEntity;
 import net.minecraft.world.level.block.entity.LecternBlockEntity;
+import net.minecraft.world.level.block.entity.ShulkerBoxBlockEntity;
 import net.minecraft.world.level.block.entity.SmokerBlockEntity;
 import org.bukkit.craftbukkit.inventory.CraftMenuType;
+import org.bukkit.craftbukkit.inventory.CraftMerchant;
+import org.bukkit.craftbukkit.inventory.view.builder.CraftAccessLocationInventoryViewBuilder;
+import org.bukkit.craftbukkit.inventory.view.builder.CraftBlockEntityInventoryViewBuilder;
+import org.bukkit.craftbukkit.inventory.view.builder.CraftDoubleChestInventoryViewBuilder;
+import org.bukkit.craftbukkit.inventory.view.builder.CraftMerchantInventoryViewBuilder;
+import org.bukkit.craftbukkit.inventory.view.builder.CraftStandardInventoryViewBuilder;
 import org.bukkit.inventory.InventoryView;
 import org.bukkit.inventory.MenuType;
 import org.bukkit.inventory.view.AnvilView;
@@ -34,83 +43,120 @@ import org.bukkit.inventory.view.LecternView;
 import org.bukkit.inventory.view.LoomView;
 import org.bukkit.inventory.view.MerchantView;
 import org.bukkit.inventory.view.StonecutterView;
+import org.bukkit.inventory.view.builder.InventoryViewBuilder;
+import org.jspecify.annotations.NullMarked;
+
+import java.util.function.Supplier;
 
+@NullMarked
 public final class CraftMenus {
 
-    public record MenuTypeData<V extends InventoryView>(Class<V> viewClass, CraftMenuBuilder menuBuilder) {
+    public record MenuTypeData<V extends InventoryView, B extends InventoryViewBuilder<V>>(Class<V> viewClass, Supplier<B> viewBuilder) {
     }
 
-    private static final CraftMenuBuilder STANDARD = (player, menuType) -> menuType.create(player.nextContainerCounter(), player.getInventory());
+    // This is a temporary measure that will likely be removed with the rewrite of HumanEntity#open[] methods
+    public static void openMerchantMenu(final ServerPlayer player, final MerchantMenu merchant) {
+        final Merchant minecraftMerchant = ((CraftMerchant) merchant.getBukkitView().getMerchant()).getMerchant();
+        int level = 1;
+        if (minecraftMerchant instanceof final Villager villager) {
+            level = villager.getVillagerData().getLevel();
+        }
+
+        if (minecraftMerchant.getTradingPlayer() != null) { // merchant's can only have one trader
+            minecraftMerchant.getTradingPlayer().closeContainer();
+        }
+
+        minecraftMerchant.setTradingPlayer(player);
+
+        player.connection.send(new ClientboundOpenScreenPacket(merchant.containerId, net.minecraft.world.inventory.MenuType.MERCHANT, merchant.getTitle()));
+        player.containerMenu = merchant;
+        player.initMenu(merchant);
+        // Copy IMerchant#openTradingScreen
+        MerchantOffers merchantrecipelist = minecraftMerchant.getOffers();
 
-    public static <V extends InventoryView> MenuTypeData<V> getMenuTypeData(CraftMenuType<?> menuType) {
+        if (!merchantrecipelist.isEmpty()) {
+            player.sendMerchantOffers(merchant.containerId, merchantrecipelist, level, minecraftMerchant.getVillagerXp(), minecraftMerchant.showProgressBar(), minecraftMerchant.canRestock());
+        }
+        // End Copy IMerchant#openTradingScreen
+    }
+
+    public static <V extends InventoryView, B extends InventoryViewBuilder<V>> MenuTypeData<V, B> getMenuTypeData(final CraftMenuType<?, ?> menuType) {
+        final net.minecraft.world.inventory.MenuType<?> handle = menuType.getHandle();
+        // this sucks horribly but it should work for now
+        if (menuType == MenuType.GENERIC_9X6) {
+            return asType(new MenuTypeData<>(InventoryView.class, () -> new CraftDoubleChestInventoryViewBuilder<>(handle)));
+        }
+        if (menuType == MenuType.GENERIC_9X3) {
+            return asType(new MenuTypeData<>(InventoryView.class, () -> new CraftBlockEntityInventoryViewBuilder<>(handle, Blocks.CHEST, null)));
+        }
         // this isn't ideal as both dispenser and dropper are 3x3, InventoryType can't currently handle generic 3x3s with size 9
         // this needs to be removed when inventory creation is overhauled
         if (menuType == MenuType.GENERIC_3X3) {
-            return CraftMenus.asType(new MenuTypeData<>(InventoryView.class, tileEntity(DispenserBlockEntity::new, Blocks.DISPENSER)));
+            return asType(new MenuTypeData<>(InventoryView.class, () -> new CraftBlockEntityInventoryViewBuilder<>(handle, Blocks.DISPENSER, DispenserBlockEntity::new)));
         }
         if (menuType == MenuType.CRAFTER_3X3) {
-            return CraftMenus.asType(new MenuTypeData<>(CrafterView.class, tileEntity(CrafterBlockEntity::new, Blocks.CRAFTER)));
+            return asType(new MenuTypeData<>(CrafterView.class, () -> new CraftBlockEntityInventoryViewBuilder<>(handle, Blocks.CRAFTER, CrafterBlockEntity::new)));
         }
         if (menuType == MenuType.ANVIL) {
-            return CraftMenus.asType(new MenuTypeData<>(AnvilView.class, worldAccess(AnvilMenu::new)));
+            return asType(new MenuTypeData<>(AnvilView.class, () -> new CraftAccessLocationInventoryViewBuilder<>(handle, AnvilMenu::new)));
         }
         if (menuType == MenuType.BEACON) {
-            return CraftMenus.asType(new MenuTypeData<>(BeaconView.class, tileEntity(BeaconBlockEntity::new, Blocks.BEACON)));
+            return asType(new MenuTypeData<>(BeaconView.class, () -> new CraftBlockEntityInventoryViewBuilder<>(handle, Blocks.BEACON, BeaconBlockEntity::new)));
         }
         if (menuType == MenuType.BLAST_FURNACE) {
-            return CraftMenus.asType(new MenuTypeData<>(FurnaceView.class, tileEntity(BlastFurnaceBlockEntity::new, Blocks.BLAST_FURNACE)));
+            return asType(new MenuTypeData<>(FurnaceView.class, () -> new CraftBlockEntityInventoryViewBuilder<>(handle, Blocks.BLAST_FURNACE, BlastFurnaceBlockEntity::new)));
         }
         if (menuType == MenuType.BREWING_STAND) {
-            return CraftMenus.asType(new MenuTypeData<>(BrewingStandView.class, tileEntity(BrewingStandBlockEntity::new, Blocks.BREWING_STAND)));
+            return asType(new MenuTypeData<>(BrewingStandView.class, () -> new CraftBlockEntityInventoryViewBuilder<>(handle, Blocks.BREWING_STAND, BrewingStandBlockEntity::new)));
         }
         if (menuType == MenuType.CRAFTING) {
-            return CraftMenus.asType(new MenuTypeData<>(InventoryView.class, worldAccess(CraftingMenu::new)));
+            return asType(new MenuTypeData<>(InventoryView.class, () -> new CraftAccessLocationInventoryViewBuilder<>(handle, CraftingMenu::new)));
         }
         if (menuType == MenuType.ENCHANTMENT) {
-            return CraftMenus.asType(new MenuTypeData<>(EnchantmentView.class, (player, type) -> {
-                return new SimpleMenuProvider((syncId, inventory, human) -> {
-                    return worldAccess(EnchantmentMenu::new).build(player, type);
-                }, Component.empty()).createMenu(player.nextContainerCounter(), player.getInventory(), player);
-            }));
+            return asType(new MenuTypeData<>(EnchantmentView.class, () -> new CraftAccessLocationInventoryViewBuilder<>(handle, EnchantmentMenu::new)));
         }
         if (menuType == MenuType.FURNACE) {
-            return CraftMenus.asType(new MenuTypeData<>(FurnaceView.class, tileEntity(FurnaceBlockEntity::new, Blocks.FURNACE)));
+            return asType(new MenuTypeData<>(FurnaceView.class, () -> new CraftBlockEntityInventoryViewBuilder<>(handle, Blocks.FURNACE, FurnaceBlockEntity::new)));
         }
         if (menuType == MenuType.GRINDSTONE) {
-            return CraftMenus.asType(new MenuTypeData<>(InventoryView.class, worldAccess(GrindstoneMenu::new)));
+            return asType(new MenuTypeData<>(InventoryView.class, () -> new CraftAccessLocationInventoryViewBuilder<>(handle, GrindstoneMenu::new)));
         }
         // We really don't need to be creating a tile entity for hopper but currently InventoryType doesn't have capacity
         // to understand otherwise
         if (menuType == MenuType.HOPPER) {
-            return CraftMenus.asType(new MenuTypeData<>(InventoryView.class, tileEntity(HopperBlockEntity::new, Blocks.HOPPER)));
+            return asType(new MenuTypeData<>(InventoryView.class, () -> new CraftBlockEntityInventoryViewBuilder<>(handle, Blocks.HOPPER, HopperBlockEntity::new)));
         }
         // We also don't need to create a tile entity for lectern, but again InventoryType isn't smart enough to know any better
         if (menuType == MenuType.LECTERN) {
-            return CraftMenus.asType(new MenuTypeData<>(LecternView.class, tileEntity(LecternBlockEntity::new, Blocks.LECTERN)));
+            return asType(new MenuTypeData<>(LecternView.class, () -> new CraftBlockEntityInventoryViewBuilder<>(handle, Blocks.LECTERN, LecternBlockEntity::new)));
         }
         if (menuType == MenuType.LOOM) {
-            return CraftMenus.asType(new MenuTypeData<>(LoomView.class, CraftMenus.STANDARD));
+            return asType(new MenuTypeData<>(LoomView.class, () -> new CraftStandardInventoryViewBuilder<>(handle)));
         }
         if (menuType == MenuType.MERCHANT) {
-            return CraftMenus.asType(new MenuTypeData<>(MerchantView.class, CraftMenus.STANDARD));
+            return asType(new MenuTypeData<>(MerchantView.class, () -> new CraftMerchantInventoryViewBuilder<>(handle)));
+        }
+        if (menuType == MenuType.SHULKER_BOX) {
+            return asType(new MenuTypeData<>(InventoryView.class, () -> new CraftBlockEntityInventoryViewBuilder<>(handle, Blocks.SHULKER_BOX, ShulkerBoxBlockEntity::new)));
         }
         if (menuType == MenuType.SMITHING) {
-            return CraftMenus.asType(new MenuTypeData<>(InventoryView.class, worldAccess(SmithingMenu::new)));
+            return asType(new MenuTypeData<>(InventoryView.class, () -> new CraftAccessLocationInventoryViewBuilder<>(handle, SmithingMenu::new)));
         }
         if (menuType == MenuType.SMOKER) {
-            return CraftMenus.asType(new MenuTypeData<>(FurnaceView.class, tileEntity(SmokerBlockEntity::new, Blocks.SMOKER)));
+            return asType(new MenuTypeData<>(FurnaceView.class, () -> new CraftBlockEntityInventoryViewBuilder<>(handle, Blocks.SMOKER, SmokerBlockEntity::new)));
         }
         if (menuType == MenuType.CARTOGRAPHY_TABLE) {
-            return CraftMenus.asType(new MenuTypeData<>(InventoryView.class, worldAccess(CartographyTableMenu::new)));
+            return asType(new MenuTypeData<>(InventoryView.class, () -> new CraftAccessLocationInventoryViewBuilder<>(handle, CartographyTableMenu::new)));
         }
         if (menuType == MenuType.STONECUTTER) {
-            return CraftMenus.asType(new MenuTypeData<>(StonecutterView.class, worldAccess(StonecutterMenu::new)));
+            return asType(new MenuTypeData<>(StonecutterView.class, () -> new CraftAccessLocationInventoryViewBuilder<>(handle, StonecutterMenu::new)));
         }
 
-        return CraftMenus.asType(new MenuTypeData<>(InventoryView.class, CraftMenus.STANDARD));
+        return asType(new MenuTypeData<>(InventoryView.class, () -> new CraftStandardInventoryViewBuilder<>(handle)));
     }
 
-    private static <V extends InventoryView> MenuTypeData<V> asType(MenuTypeData<?> data) {
-        return (MenuTypeData<V>) data;
+    @SuppressWarnings("unchecked")
+    private static <V extends InventoryView, B extends InventoryViewBuilder<V>> MenuTypeData<V, B> asType(final MenuTypeData<?, ?> data) {
+        return (MenuTypeData<V, B>) data;
     }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/view/CraftEnchantmentView.java b/src/main/java/org/bukkit/craftbukkit/inventory/view/CraftEnchantmentView.java
index abe709ab9002b30a996e46779843969c984c9be9..37a02aa2530f71938d204ac4381105473c6ebadf 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/view/CraftEnchantmentView.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/view/CraftEnchantmentView.java
@@ -47,7 +47,7 @@ public class CraftEnchantmentView extends CraftInventoryView<EnchantmentMenu, En
 
     @Override
     public void setOffers(@NotNull final EnchantmentOffer[] offers) {
-        Preconditions.checkArgument(offers.length != 3, "There must be 3 offers given");
+        Preconditions.checkArgument(offers.length == 3, "There must be 3 offers given");
         IdMap<Holder<Enchantment>> registry = CraftRegistry.getMinecraftRegistry().lookupOrThrow(Registries.ENCHANTMENT).asHolderIdMap();
         for (int i = 0; i < offers.length; i++) {
             final EnchantmentOffer offer = offers[i];
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/view/builder/CraftAbstractInventoryViewBuilder.java b/src/main/java/org/bukkit/craftbukkit/inventory/view/builder/CraftAbstractInventoryViewBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..185ad0fc16580136d99a6ecb9e58900ef708be34
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/view/builder/CraftAbstractInventoryViewBuilder.java
@@ -0,0 +1,48 @@
+package org.bukkit.craftbukkit.inventory.view.builder;
+
+import com.google.common.base.Preconditions;
+import io.papermc.paper.adventure.PaperAdventure;
+import net.kyori.adventure.text.Component;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.inventory.AbstractContainerMenu;
+import net.minecraft.world.inventory.MenuType;
+import org.bukkit.craftbukkit.entity.CraftHumanEntity;
+import org.bukkit.entity.HumanEntity;
+import org.bukkit.inventory.InventoryView;
+import org.bukkit.inventory.view.builder.InventoryViewBuilder;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
+
+public abstract class CraftAbstractInventoryViewBuilder<V extends InventoryView> implements InventoryViewBuilder<V> {
+
+    protected final MenuType<?> handle;
+
+    protected boolean checkReachable = false;
+    protected @MonotonicNonNull Component title = null;
+
+    public CraftAbstractInventoryViewBuilder(final MenuType<?> handle) {
+        this.handle = handle;
+    }
+
+    @Override
+    public InventoryViewBuilder<V> title(final Component title) {
+        this.title = title;
+        return this;
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public V build(final HumanEntity player) {
+        Preconditions.checkArgument(player != null, "The given player must not be null");
+        Preconditions.checkArgument(this.title != null, "The given title must not be null");
+        Preconditions.checkArgument(player instanceof CraftHumanEntity, "The given player must be a CraftHumanEntity");
+        final CraftHumanEntity craftHuman = (CraftHumanEntity) player;
+        Preconditions.checkArgument(craftHuman.getHandle() instanceof ServerPlayer, "The given player must be an EntityPlayer");
+        final ServerPlayer serverPlayer = (ServerPlayer) craftHuman.getHandle();
+        final AbstractContainerMenu container = buildContainer(serverPlayer);
+        container.checkReachable = this.checkReachable;
+        container.setTitle(PaperAdventure.asVanilla(this.title));
+        return (V) container.getBukkitView();
+    }
+
+    protected abstract AbstractContainerMenu buildContainer(ServerPlayer player);
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/view/builder/CraftAbstractLocationInventoryViewBuilder.java b/src/main/java/org/bukkit/craftbukkit/inventory/view/builder/CraftAbstractLocationInventoryViewBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..7a894ca078065fe06625121ae32105357ebda70f
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/view/builder/CraftAbstractLocationInventoryViewBuilder.java
@@ -0,0 +1,48 @@
+package org.bukkit.craftbukkit.inventory.view.builder;
+
+import com.google.common.base.Preconditions;
+import net.kyori.adventure.text.Component;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.inventory.MenuType;
+import net.minecraft.world.level.Level;
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.util.CraftLocation;
+import org.bukkit.inventory.InventoryView;
+import org.bukkit.inventory.view.builder.LocationInventoryViewBuilder;
+import org.jspecify.annotations.Nullable;
+
+public abstract class CraftAbstractLocationInventoryViewBuilder<V extends InventoryView> extends CraftAbstractInventoryViewBuilder<V> implements LocationInventoryViewBuilder<V> {
+
+    protected @Nullable Level world;
+    protected @Nullable BlockPos position;
+
+    public CraftAbstractLocationInventoryViewBuilder(final MenuType<?> handle) {
+        super(handle);
+    }
+
+    @Override
+    public LocationInventoryViewBuilder<V> title(final Component title) {
+        return (LocationInventoryViewBuilder<V>) super.title(title);
+    }
+
+    @Override
+    public LocationInventoryViewBuilder<V> copy() {
+        throw new UnsupportedOperationException("copy is not implemented on CraftAbstractLocationInventoryViewBuilder");
+    }
+
+    @Override
+    public LocationInventoryViewBuilder<V> checkReachable(final boolean checkReachable) {
+        super.checkReachable = checkReachable;
+        return this;
+    }
+
+    @Override
+    public LocationInventoryViewBuilder<V> location(final Location location) {
+        Preconditions.checkArgument(location != null, "The provided location must not be null");
+        Preconditions.checkArgument(location.getWorld() != null, "The provided location must be associated with a world");
+        this.world = ((CraftWorld) location.getWorld()).getHandle();
+        this.position = CraftLocation.toBlockPosition(location);
+        return this;
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/view/builder/CraftAccessLocationInventoryViewBuilder.java b/src/main/java/org/bukkit/craftbukkit/inventory/view/builder/CraftAccessLocationInventoryViewBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..096f3ebf8167cb60f20373d9e3b0c765f88664f7
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/view/builder/CraftAccessLocationInventoryViewBuilder.java
@@ -0,0 +1,45 @@
+package org.bukkit.craftbukkit.inventory.view.builder;
+
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.inventory.AbstractContainerMenu;
+import net.minecraft.world.inventory.ContainerLevelAccess;
+import net.minecraft.world.inventory.MenuType;
+import org.bukkit.inventory.InventoryView;
+import org.bukkit.inventory.view.builder.LocationInventoryViewBuilder;
+
+public class CraftAccessLocationInventoryViewBuilder<V extends InventoryView> extends CraftAbstractLocationInventoryViewBuilder<V> {
+
+    private final CraftAccessContainerObjectBuilder containerBuilder;
+
+    public CraftAccessLocationInventoryViewBuilder(final MenuType<?> handle, final CraftAccessContainerObjectBuilder containerBuilder) {
+        super(handle);
+        this.containerBuilder = containerBuilder;
+    }
+
+    @Override
+    protected AbstractContainerMenu buildContainer(final ServerPlayer player) {
+        final ContainerLevelAccess access;
+        if (super.position == null) {
+            access = ContainerLevelAccess.create(player.level(), player.blockPosition());
+        } else {
+            access = ContainerLevelAccess.create(super.world, super.position);
+        }
+
+        return this.containerBuilder.build(player.nextContainerCounter(), player.getInventory(), access);
+    }
+
+    @Override
+    public LocationInventoryViewBuilder<V> copy() {
+        final CraftAccessLocationInventoryViewBuilder<V> copy = new CraftAccessLocationInventoryViewBuilder<>(this.handle, this.containerBuilder);
+        copy.world = super.world;
+        copy.position = super.position;
+        copy.checkReachable = super.checkReachable;
+        copy.title = title;
+        return copy;
+    }
+
+    public interface CraftAccessContainerObjectBuilder {
+        AbstractContainerMenu build(final int syncId, final Inventory inventory, ContainerLevelAccess access);
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/view/builder/CraftBlockEntityInventoryViewBuilder.java b/src/main/java/org/bukkit/craftbukkit/inventory/view/builder/CraftBlockEntityInventoryViewBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..262581444013afca7daa5d52bbb06b7d1eff4e92
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/view/builder/CraftBlockEntityInventoryViewBuilder.java
@@ -0,0 +1,74 @@
+package org.bukkit.craftbukkit.inventory.view.builder;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.MenuProvider;
+import net.minecraft.world.inventory.AbstractContainerMenu;
+import net.minecraft.world.inventory.MenuConstructor;
+import net.minecraft.world.inventory.MenuType;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.state.BlockState;
+import org.bukkit.inventory.InventoryView;
+import org.bukkit.inventory.view.builder.LocationInventoryViewBuilder;
+import org.jspecify.annotations.Nullable;
+
+public class CraftBlockEntityInventoryViewBuilder<V extends InventoryView> extends CraftAbstractLocationInventoryViewBuilder<V> {
+
+    private final Block block;
+    private final @Nullable CraftTileInventoryBuilder builder;
+
+    public CraftBlockEntityInventoryViewBuilder(final MenuType<?> handle, final Block block, final @Nullable CraftTileInventoryBuilder builder) {
+        super(handle);
+        this.block = block;
+        this.builder = builder;
+    }
+
+    @Override
+    protected AbstractContainerMenu buildContainer(final ServerPlayer player) {
+        if (this.world == null) {
+            this.world = player.level();
+        }
+
+        if (this.position == null) {
+            this.position = player.blockPosition();
+        }
+
+        final BlockEntity entity = this.world.getBlockEntity(position);
+        if (!(entity instanceof final MenuConstructor container)) {
+            return buildFakeTile(player);
+        }
+
+        final AbstractContainerMenu atBlock = container.createMenu(player.nextContainerCounter(), player.getInventory(), player);
+        if (atBlock.getType() != super.handle) {
+            return buildFakeTile(player);
+        }
+
+        return atBlock;
+    }
+
+    private AbstractContainerMenu buildFakeTile(final ServerPlayer player) {
+        if (this.builder == null) {
+            return handle.create(player.nextContainerCounter(), player.getInventory());
+        }
+        final MenuProvider inventory = this.builder.build(this.position, this.block.defaultBlockState());
+        if (inventory instanceof final BlockEntity tile) {
+            tile.setLevel(this.world);
+        }
+        return inventory.createMenu(player.nextContainerCounter(), player.getInventory(), player);
+    }
+
+    @Override
+    public LocationInventoryViewBuilder<V> copy() {
+        final CraftBlockEntityInventoryViewBuilder<V> copy = new CraftBlockEntityInventoryViewBuilder<>(super.handle, this.block, this.builder);
+        copy.world = this.world;
+        copy.position = this.position;
+        copy.checkReachable = super.checkReachable;
+        copy.title = title;
+        return copy;
+    }
+
+    public interface CraftTileInventoryBuilder {
+        MenuProvider build(BlockPos blockPosition, BlockState blockData);
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/view/builder/CraftDoubleChestInventoryViewBuilder.java b/src/main/java/org/bukkit/craftbukkit/inventory/view/builder/CraftDoubleChestInventoryViewBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..331e3797a5dedb00691a6a367403a500a71788b7
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/view/builder/CraftDoubleChestInventoryViewBuilder.java
@@ -0,0 +1,48 @@
+package org.bukkit.craftbukkit.inventory.view.builder;
+
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.MenuProvider;
+import net.minecraft.world.inventory.AbstractContainerMenu;
+import net.minecraft.world.inventory.MenuType;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.ChestBlock;
+import net.minecraft.world.level.block.DoubleBlockCombiner;
+import net.minecraft.world.level.block.entity.ChestBlockEntity;
+import org.bukkit.inventory.InventoryView;
+import org.bukkit.inventory.view.builder.LocationInventoryViewBuilder;
+
+public class CraftDoubleChestInventoryViewBuilder<V extends InventoryView> extends CraftAbstractLocationInventoryViewBuilder<V> {
+
+    public CraftDoubleChestInventoryViewBuilder(final MenuType<?> handle) {
+        super(handle);
+    }
+
+    @Override
+    protected AbstractContainerMenu buildContainer(final ServerPlayer player) {
+        if (super.world == null) {
+            return handle.create(player.nextContainerCounter(), player.getInventory());
+        }
+
+        final ChestBlock chest = (ChestBlock) Blocks.CHEST;
+        final DoubleBlockCombiner.NeighborCombineResult<? extends ChestBlockEntity> result = chest.combine(super.world.getBlockState(super.position), super.world, super.position, false);
+        if (result instanceof DoubleBlockCombiner.NeighborCombineResult.Single<? extends ChestBlockEntity>) {
+            return handle.create(player.nextContainerCounter(), player.getInventory());
+        }
+
+        final MenuProvider combined = result.apply(ChestBlock.MENU_PROVIDER_COMBINER).orElse(null);
+        if (combined == null) {
+            return handle.create(player.nextContainerCounter(), player.getInventory());
+        }
+        return combined.createMenu(player.nextContainerCounter(), player.getInventory(), player);
+    }
+
+    @Override
+    public LocationInventoryViewBuilder<V> copy() {
+        final CraftDoubleChestInventoryViewBuilder<V> copy = new CraftDoubleChestInventoryViewBuilder<>(super.handle);
+        copy.world = this.world;
+        copy.position = this.position;
+        copy.checkReachable = super.checkReachable;
+        copy.title = title;
+        return copy;
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/view/builder/CraftMerchantInventoryViewBuilder.java b/src/main/java/org/bukkit/craftbukkit/inventory/view/builder/CraftMerchantInventoryViewBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..7f7518aa73c66063e28b5b2d947f8c2352203284
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/view/builder/CraftMerchantInventoryViewBuilder.java
@@ -0,0 +1,78 @@
+package org.bukkit.craftbukkit.inventory.view.builder;
+
+import com.google.common.base.Preconditions;
+import io.papermc.paper.adventure.PaperAdventure;
+import net.kyori.adventure.text.Component;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.inventory.AbstractContainerMenu;
+import net.minecraft.world.inventory.MenuType;
+import net.minecraft.world.inventory.MerchantMenu;
+import org.bukkit.craftbukkit.entity.CraftHumanEntity;
+import org.bukkit.craftbukkit.inventory.CraftMerchant;
+import org.bukkit.craftbukkit.inventory.CraftMerchantCustom;
+import org.bukkit.entity.HumanEntity;
+import org.bukkit.inventory.InventoryView;
+import org.bukkit.inventory.Merchant;
+import org.bukkit.inventory.view.builder.MerchantInventoryViewBuilder;
+import org.jspecify.annotations.Nullable;
+
+public class CraftMerchantInventoryViewBuilder<V extends InventoryView> extends CraftAbstractInventoryViewBuilder<V> implements MerchantInventoryViewBuilder<V> {
+
+    private net.minecraft.world.item.trading.@Nullable Merchant merchant;
+
+    public CraftMerchantInventoryViewBuilder(final MenuType<?> handle) {
+        super(handle);
+    }
+
+    @Override
+    public MerchantInventoryViewBuilder<V> title(final Component title) {
+        return (MerchantInventoryViewBuilder<V>) super.title(title);
+    }
+
+    @Override
+    public MerchantInventoryViewBuilder<V> merchant(final Merchant merchant) {
+        this.merchant = ((CraftMerchant) merchant).getMerchant();
+        return this;
+    }
+
+    @Override
+    public MerchantInventoryViewBuilder<V> checkReachable(final boolean checkReachable) {
+        super.checkReachable = checkReachable;
+        return this;
+    }
+
+    @Override
+    public V build(final HumanEntity player) {
+        Preconditions.checkArgument(player != null, "The given player must not be null");
+        Preconditions.checkArgument(this.title != null, "The given title must not be null");
+        Preconditions.checkArgument(player instanceof CraftHumanEntity, "The given player must be a CraftHumanEntity");
+        final CraftHumanEntity craftHuman = (CraftHumanEntity) player;
+        Preconditions.checkArgument(craftHuman.getHandle() instanceof ServerPlayer, "The given player must be an EntityPlayer");
+        final ServerPlayer serverPlayer = (ServerPlayer) craftHuman.getHandle();
+
+        final MerchantMenu container;
+        if (this.merchant == null) {
+            container = new MerchantMenu(serverPlayer.nextContainerCounter(), serverPlayer.getInventory(), new CraftMerchantCustom(title).getMerchant());
+        } else {
+            container = new MerchantMenu(serverPlayer.nextContainerCounter(), serverPlayer.getInventory(), this.merchant);
+        }
+
+        container.checkReachable = super.checkReachable;
+        container.setTitle(PaperAdventure.asVanilla(this.title));
+        return (V) container.getBukkitView();
+    }
+
+    @Override
+    protected AbstractContainerMenu buildContainer(final ServerPlayer player) {
+        throw new UnsupportedOperationException("buildContainer is not supported for CraftMerchantInventoryViewBuilder");
+    }
+
+    @Override
+    public MerchantInventoryViewBuilder<V> copy() {
+        final CraftMerchantInventoryViewBuilder<V> copy = new CraftMerchantInventoryViewBuilder<>(super.handle);
+        copy.checkReachable = super.checkReachable;
+        copy.merchant = this.merchant;
+        copy.title = title;
+        return copy;
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/view/builder/CraftStandardInventoryViewBuilder.java b/src/main/java/org/bukkit/craftbukkit/inventory/view/builder/CraftStandardInventoryViewBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..e528facbe0ae6e977082ae3ad1a985c4b9006ba5
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/view/builder/CraftStandardInventoryViewBuilder.java
@@ -0,0 +1,26 @@
+package org.bukkit.craftbukkit.inventory.view.builder;
+
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.inventory.AbstractContainerMenu;
+import net.minecraft.world.inventory.MenuType;
+import org.bukkit.inventory.InventoryView;
+import org.bukkit.inventory.view.builder.InventoryViewBuilder;
+
+public class CraftStandardInventoryViewBuilder<V extends InventoryView> extends CraftAbstractInventoryViewBuilder<V> {
+
+    public CraftStandardInventoryViewBuilder(final MenuType<?> handle) {
+        super(handle);
+    }
+
+    @Override
+    protected AbstractContainerMenu buildContainer(final ServerPlayer player) {
+        return super.handle.create(player.nextContainerCounter(), player.getInventory());
+    }
+
+    @Override
+    public InventoryViewBuilder<V> copy() {
+        final CraftStandardInventoryViewBuilder<V> copy = new CraftStandardInventoryViewBuilder<>(handle);
+        copy.title = this.title;
+        return copy;
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/view/builder/package-info.java b/src/main/java/org/bukkit/craftbukkit/inventory/view/builder/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..157ce9fd7532bbd849eab13815e007901c88c1ca
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/view/builder/package-info.java
@@ -0,0 +1,4 @@
+@NullMarked
+package org.bukkit.craftbukkit.inventory.view.builder;
+
+import org.jspecify.annotations.NullMarked;
diff --git a/src/main/java/org/bukkit/craftbukkit/legacy/FieldRename.java b/src/main/java/org/bukkit/craftbukkit/legacy/FieldRename.java
index fe29c08270854d37a4b111f66ebf261260200f28..23cbe3b6f4c7d10f9d5651a09145977a53e3d80e 100644
--- a/src/main/java/org/bukkit/craftbukkit/legacy/FieldRename.java
+++ b/src/main/java/org/bukkit/craftbukkit/legacy/FieldRename.java
@@ -282,6 +282,7 @@ public class FieldRename {
             .change("PONDER", "PONDER_GOAT_HORN")
             .change("SING", "SING_GOAT_HORN")
             .change("SEEK", "SEEK_GOAT_HORN")
+            .change("FEEL", "FEEL_GOAT_HORN")
             .change("ADMIRE", "ADMIRE_GOAT_HORN")
             .change("CALL", "CALL_GOAT_HORN")
             .change("YEARN", "YEARN_GOAT_HORN")
diff --git a/src/main/java/org/bukkit/craftbukkit/legacy/enums/EnumEvil.java b/src/main/java/org/bukkit/craftbukkit/legacy/enums/EnumEvil.java
index faba7efbda184a37e0a58dac9b248fb69087b568..1376703cde16ceff370613ce98efb74a7fe5f1db 100644
--- a/src/main/java/org/bukkit/craftbukkit/legacy/enums/EnumEvil.java
+++ b/src/main/java/org/bukkit/craftbukkit/legacy/enums/EnumEvil.java
@@ -40,6 +40,7 @@ import org.bukkit.entity.Villager;
 import org.bukkit.map.MapCursor;
 import org.bukkit.util.OldEnum;
 
+@Deprecated
 @NotInBukkit
 @RequireCompatibility("enum-compatibility-mode")
 @RequirePluginVersion(maxInclusive = "1.20.6")
diff --git a/src/main/java/org/bukkit/craftbukkit/map/CraftMapCanvas.java b/src/main/java/org/bukkit/craftbukkit/map/CraftMapCanvas.java
index a5e98571d6d83390761c11e28a0bc3c4415799cd..94c0e6d748cec58ffbefd4b7eeb784beedfa6fb3 100644
--- a/src/main/java/org/bukkit/craftbukkit/map/CraftMapCanvas.java
+++ b/src/main/java/org/bukkit/craftbukkit/map/CraftMapCanvas.java
@@ -3,6 +3,7 @@ package org.bukkit.craftbukkit.map;
 import com.google.common.base.Preconditions;
 import java.awt.Color;
 import java.awt.Image;
+import java.awt.image.BufferedImage;
 import java.util.Arrays;
 import org.bukkit.map.MapCanvas;
 import org.bukkit.map.MapCursorCollection;
@@ -92,22 +93,33 @@ public class CraftMapCanvas implements MapCanvas {
     @Override
     public void drawImage(int x, int y, Image image) {
         // Paper start - Reduce work done by limiting size of image and using System.arraycopy
-        int width = 128 - x;
-        int height = 128 - y;
-        if (image.getHeight(null) < height)
-            height = image.getHeight(null);
+        final int imageWidth = image.getWidth(null);
+        final int imageHeight = image.getHeight(null);
+
+        // The source x value *may* be negative, meaning we'd need to "offset" the source image before drawing it.
+        final int sourceX = Math.max(-x, 0);
+        final int sourceY = Math.max(-y, 0);
+        final int destX = Math.max(x, 0);
+        final int destY = Math.max(y, 0);
+
+        // The effective width/height to draw on the canvas.
+        final int effectiveWidth = Math.min(imageWidth - sourceX, 128 - destX);
+        final int effectiveHeight = Math.min(imageHeight - sourceY, 128 - destY);
+
+        if (effectiveWidth <= 0 || effectiveHeight <= 0)
+            return;
 
         // Create a subimage if the image is larger than the max allowed size
-        java.awt.image.BufferedImage temp;
-        if (image.getWidth(null) >= width && image instanceof java.awt.image.BufferedImage bImage) {
+        BufferedImage temp;
+        if (imageWidth >= effectiveWidth && image instanceof BufferedImage bImage) {
             // If the image is larger than the max allowed size, get a subimage, otherwise use the image as is
-            if (image.getWidth(null) > width || image.getHeight(null) > height) {
-                temp = bImage.getSubimage(0, 0, width, height);
+            if (imageWidth > effectiveWidth || imageHeight > effectiveHeight) {
+                temp = bImage.getSubimage(sourceX, sourceY, effectiveWidth, effectiveHeight);
             } else {
                 temp = bImage;
             }
         } else {
-            temp = new java.awt.image.BufferedImage(width, height, java.awt.image.BufferedImage.TYPE_INT_ARGB);
+            temp = new BufferedImage(effectiveWidth, effectiveHeight, BufferedImage.TYPE_INT_ARGB);
             java.awt.Graphics2D graphics = temp.createGraphics();
             graphics.drawImage(image, 0, 0, null);
             graphics.dispose();
@@ -117,14 +129,20 @@ public class CraftMapCanvas implements MapCanvas {
         
         // Since we now control the size of the image, we can safely use System.arraycopy
         // If x is 0, we can just copy the entire image as width is 128 and height is <=(128-y)
-        if (x == 0) {
-            System.arraycopy(bytes, 0, this.buffer, y * 128, width * height);
-            return;
-        }
+        if (x == 0 && effectiveWidth == 128) { // This only works great if the width is 128, otherwise an empty area appears
+            System.arraycopy(bytes, 0, this.buffer, destY * effectiveWidth, effectiveWidth * effectiveHeight);
+        } else {
+            for (int yToCopy = 0; yToCopy < effectiveHeight; ++yToCopy) {
+                final int src = yToCopy * effectiveWidth;
+                final int dest = (destY + yToCopy) * 128 + destX;
 
-        for (int y2 = 0; y2 < height; ++y2) {
-            System.arraycopy(bytes, 0, this.buffer, (y + y2) * 128 + x, width);
+                System.arraycopy(bytes, src, this.buffer, dest, effectiveWidth);
+            }
         }
+
+        // Mark all colors within the image as dirty
+        this.mapView.worldMap.setColorsDirty(destX, destY);
+        this.mapView.worldMap.setColorsDirty(destX + effectiveWidth - 1, destY + effectiveHeight - 1);
         // Paper end
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/map/CraftMapCursor.java b/src/main/java/org/bukkit/craftbukkit/map/CraftMapCursor.java
index 9c02115aa1fca4ff4f5c5d188a36f53696a8d7b7..a24cd5850dc83f6ff859007541f0bcc95d954d9d 100644
--- a/src/main/java/org/bukkit/craftbukkit/map/CraftMapCursor.java
+++ b/src/main/java/org/bukkit/craftbukkit/map/CraftMapCursor.java
@@ -5,7 +5,6 @@ import net.minecraft.core.Holder;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.world.level.saveddata.maps.MapDecorationType;
 import org.bukkit.NamespacedKey;
-import org.bukkit.Registry;
 import org.bukkit.craftbukkit.CraftRegistry;
 import org.bukkit.craftbukkit.util.Handleable;
 import org.bukkit.map.MapCursor;
@@ -17,7 +16,7 @@ public final class CraftMapCursor {
         private static int count = 0;
 
         public static MapCursor.Type minecraftToBukkit(MapDecorationType minecraft) {
-            return CraftRegistry.minecraftToBukkit(minecraft, Registries.MAP_DECORATION_TYPE, Registry.MAP_DECORATION_TYPE);
+            return CraftRegistry.minecraftToBukkit(minecraft, Registries.MAP_DECORATION_TYPE);
         }
 
         public static MapCursor.Type minecraftHolderToBukkit(Holder<MapDecorationType> minecraft) {
diff --git a/src/main/java/org/bukkit/craftbukkit/map/CraftMapView.java b/src/main/java/org/bukkit/craftbukkit/map/CraftMapView.java
index a15cdf64575841edfe30f2b2c522f8fdfe2caae3..26a402b12f6cd0f38fa8f07371d585694c61269a 100644
--- a/src/main/java/org/bukkit/craftbukkit/map/CraftMapView.java
+++ b/src/main/java/org/bukkit/craftbukkit/map/CraftMapView.java
@@ -5,6 +5,7 @@ import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.WeakHashMap;
 import java.util.logging.Level;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.server.MinecraftServer;
@@ -19,9 +20,9 @@ import org.bukkit.map.MapView;
 
 public final class CraftMapView implements MapView {
 
-    private final Map<CraftPlayer, RenderData> renderCache = new HashMap<CraftPlayer, RenderData>();
-    private final List<MapRenderer> renderers = new ArrayList<MapRenderer>();
-    private final Map<MapRenderer, Map<CraftPlayer, CraftMapCanvas>> canvases = new HashMap<MapRenderer, Map<CraftPlayer, CraftMapCanvas>>();
+    private final Map<CraftPlayer, RenderData> renderCache = new WeakHashMap<>();
+    private final List<MapRenderer> renderers = new ArrayList<>();
+    private final Map<MapRenderer, Map<CraftPlayer, CraftMapCanvas>> canvases = new HashMap<>();
     protected final MapItemSavedData worldMap;
 
     public CraftMapView(MapItemSavedData worldMap) {
@@ -99,7 +100,7 @@ public final class CraftMapView implements MapView {
     public void addRenderer(MapRenderer renderer) {
         if (!this.renderers.contains(renderer)) {
             this.renderers.add(renderer);
-            this.canvases.put(renderer, new HashMap<CraftPlayer, CraftMapCanvas>());
+            this.canvases.put(renderer, new WeakHashMap<>());
             renderer.initialize(this);
         }
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/map/RenderData.java b/src/main/java/org/bukkit/craftbukkit/map/RenderData.java
index 503a31b4efc8920a11bc1db03f81aab6439ceb23..782f5df3801bf85fba00381808564dac4abb0751 100644
--- a/src/main/java/org/bukkit/craftbukkit/map/RenderData.java
+++ b/src/main/java/org/bukkit/craftbukkit/map/RenderData.java
@@ -1,16 +1,11 @@
 package org.bukkit.craftbukkit.map;
 
 import java.util.ArrayList;
+import java.util.List;
 import org.bukkit.map.MapCursor;
 
 public class RenderData {
 
-    public byte[] buffer;
-    public final ArrayList<MapCursor> cursors;
-
-    public RenderData() {
-        this.buffer = new byte[128 * 128];
-        this.cursors = new ArrayList<MapCursor>();
-    }
-
+    public final List<MapCursor> cursors = new ArrayList<>();
+    public byte[] buffer = new byte[128 * 128];
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/potion/CraftPotionEffectType.java b/src/main/java/org/bukkit/craftbukkit/potion/CraftPotionEffectType.java
index 0bcb9df1103050441f8922a688b163dc97c04591..8d9c141ff1756818ba831e8a9ec45716e21c9234 100644
--- a/src/main/java/org/bukkit/craftbukkit/potion/CraftPotionEffectType.java
+++ b/src/main/java/org/bukkit/craftbukkit/potion/CraftPotionEffectType.java
@@ -5,7 +5,6 @@ import net.minecraft.core.registries.Registries;
 import net.minecraft.world.effect.MobEffect;
 import org.bukkit.Color;
 import org.bukkit.NamespacedKey;
-import org.bukkit.Registry;
 import org.bukkit.craftbukkit.CraftRegistry;
 import org.bukkit.craftbukkit.util.Handleable;
 import org.bukkit.potion.PotionEffect;
@@ -20,7 +19,7 @@ public class CraftPotionEffectType extends PotionEffectType implements Handleabl
     }
 
     public static PotionEffectType minecraftToBukkit(MobEffect minecraft) {
-        return CraftRegistry.minecraftToBukkit(minecraft, Registries.MOB_EFFECT, Registry.EFFECT);
+        return CraftRegistry.minecraftToBukkit(minecraft, Registries.MOB_EFFECT);
     }
 
     public static MobEffect bukkitToMinecraft(PotionEffectType bukkit) {
diff --git a/src/main/java/org/bukkit/craftbukkit/potion/CraftPotionType.java b/src/main/java/org/bukkit/craftbukkit/potion/CraftPotionType.java
index f1d8ed4a2b8959873b02d57f6a40323a841f3d7f..24010b74ac1353575c183331d2cc518ee2e4f783 100644
--- a/src/main/java/org/bukkit/craftbukkit/potion/CraftPotionType.java
+++ b/src/main/java/org/bukkit/craftbukkit/potion/CraftPotionType.java
@@ -2,6 +2,7 @@ package org.bukkit.craftbukkit.potion;
 
 import com.google.common.base.Preconditions;
 import com.google.common.base.Suppliers;
+import io.papermc.paper.registry.RegistryKey;
 import java.util.List;
 import java.util.Locale;
 import java.util.function.Supplier;
@@ -72,7 +73,7 @@ public class CraftPotionType implements PotionType.InternalPotionData {
         if (key == null) return null; // Paper - Fixup NamespacedKey handling
 
         // Now also convert from when keys where saved
-        return CraftRegistry.get(Registry.POTION, key, ApiVersion.CURRENT);
+        return CraftRegistry.get(RegistryKey.POTION, key, ApiVersion.CURRENT);
     }
 
     private final NamespacedKey key;
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftAsyncTask.java b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftAsyncTask.java
index e97f6b76ef2fe21c7c2eca8d4a707e5866d70de9..e4e2e42d0ca25df7fe9f2dd4275610e45fcb2c84 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftAsyncTask.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftAsyncTask.java
@@ -28,7 +28,7 @@ class CraftAsyncTask extends CraftTask {
         // Paper start - name threads according to running plugin
         final String nameBefore = thread.getName();
         thread.setName(nameBefore + " - " + this.getOwner().getName());
-        try { synchronized (this.workers) {  // Paper end - name threads according to running plugin
+        try { synchronized (this.workers) { // Paper end - name threads according to running plugin
             if (this.getPeriod() == CraftTask.CANCEL) {
                 // Never continue running after cancelled.
                 // Checking this with the lock is important!
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
index 15892c7769caa15f3d52a1ee2147cf9615aa0e25..bd8005cd3a52532f4cb2e123da473f1490b59dbb 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
@@ -1,5 +1,6 @@
 package org.bukkit.craftbukkit.util;
 
+import ca.spottedleaf.moonrise.common.PlatformHooks;
 import com.google.common.base.Charsets;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Multimap;
@@ -11,38 +12,46 @@ import com.mojang.brigadier.StringReader;
 import com.mojang.brigadier.exceptions.CommandSyntaxException;
 import com.mojang.serialization.Dynamic;
 import com.mojang.serialization.JsonOps;
+import io.papermc.paper.registry.RegistryKey;
 import java.io.File;
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Locale;
 import java.util.Map;
+import java.util.Set;
 import java.util.logging.Level;
-import java.util.logging.Logger;
+import java.util.stream.Stream;
+import io.papermc.paper.entity.EntitySerializationFlag;
 import net.minecraft.SharedConstants;
 import net.minecraft.advancements.AdvancementHolder;
 import net.minecraft.commands.Commands;
 import net.minecraft.commands.arguments.item.ItemParser;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.core.registries.Registries;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
 import net.minecraft.nbt.NbtOps;
 import net.minecraft.nbt.StringTag;
 import net.minecraft.nbt.Tag;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.datafix.DataFixers;
 import net.minecraft.util.datafix.fixes.References;
+import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.alchemy.Potion;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.storage.LevelResource;
 import org.bukkit.Bukkit;
-import org.bukkit.FeatureFlag;
 import org.bukkit.Keyed;
 import org.bukkit.Material;
 import org.bukkit.NamespacedKey;
-import org.bukkit.Registry;
 import org.bukkit.UnsafeValues;
+import org.bukkit.World;
 import org.bukkit.advancement.Advancement;
 import org.bukkit.attribute.Attribute;
 import org.bukkit.attribute.AttributeModifier;
@@ -51,15 +60,15 @@ import org.bukkit.block.data.BlockData;
 // import org.bukkit.craftbukkit.CraftFeatureFlag; // Paper
 import org.bukkit.craftbukkit.CraftRegistry;
 import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.block.CraftBiome;
 import org.bukkit.craftbukkit.block.data.CraftBlockData;
-import org.bukkit.craftbukkit.damage.CraftDamageEffect;
 import org.bukkit.craftbukkit.damage.CraftDamageSourceBuilder;
+import org.bukkit.craftbukkit.entity.CraftEntity;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.craftbukkit.legacy.CraftLegacy;
 import org.bukkit.craftbukkit.legacy.FieldRename;
 import org.bukkit.craftbukkit.potion.CraftPotionType;
-import org.bukkit.damage.DamageEffect;
 import org.bukkit.damage.DamageSource;
 import org.bukkit.damage.DamageType;
 import org.bukkit.enchantments.Enchantment;
@@ -466,12 +475,6 @@ public final class CraftMagicNumbers implements UnsafeValues {
         return new CraftPotionType(namespacedKey, potionRegistry);
     }
 
-    @Override
-    public DamageEffect getDamageEffect(String key) {
-        Preconditions.checkArgument(key != null, "key cannot be null");
-        return CraftDamageEffect.getById(key);
-    }
-
     @Override
     public DamageSource.Builder createDamageSourceBuilder(DamageType damageType) {
         return new CraftDamageSourceBuilder(damageType);
@@ -487,7 +490,7 @@ public final class CraftMagicNumbers implements UnsafeValues {
     }
 
     @Override
-    public <B extends Keyed> B get(Registry<B> registry, NamespacedKey namespacedKey) {
+    public <B extends Keyed> B get(RegistryKey<B> registry, NamespacedKey namespacedKey) {
         // We currently do not have any version-dependent remapping, so we can use current version
         return CraftRegistry.get(registry, namespacedKey, ApiVersion.CURRENT);
     }
@@ -513,7 +516,7 @@ public final class CraftMagicNumbers implements UnsafeValues {
         Preconditions.checkNotNull(item, "null cannot be serialized");
         Preconditions.checkArgument(item.getType() != Material.AIR, "air cannot be serialized");
 
-        return serializeNbtToBytes((net.minecraft.nbt.CompoundTag) (item instanceof CraftItemStack ? ((CraftItemStack) item).handle : CraftItemStack.asNMSCopy(item)).save(MinecraftServer.getServer().registryAccess()));
+        return serializeNbtToBytes((CompoundTag) (item instanceof CraftItemStack ? ((CraftItemStack) item).handle : CraftItemStack.asNMSCopy(item)).save(MinecraftServer.getServer().registryAccess()));
     }
 
     @Override
@@ -521,9 +524,9 @@ public final class CraftMagicNumbers implements UnsafeValues {
         Preconditions.checkNotNull(data, "null cannot be deserialized");
         Preconditions.checkArgument(data.length > 0, "cannot deserialize nothing");
 
-        net.minecraft.nbt.CompoundTag compound = deserializeNbtFromBytes(data);
+        CompoundTag compound = deserializeNbtFromBytes(data);
         final int dataVersion = compound.getInt("DataVersion");
-        compound = ca.spottedleaf.dataconverter.minecraft.MCDataConverter.convertTag(ca.spottedleaf.dataconverter.minecraft.datatypes.MCTypeRegistry.ITEM_STACK, compound, dataVersion, this.getDataVersion()); // Paper - replace data conversion system
+        compound = PlatformHooks.get().convertNBT(References.ITEM_STACK, MinecraftServer.getServer().fixerUpper, compound, dataVersion, this.getDataVersion()); // Paper - possibly use dataconverter
         return CraftItemStack.asCraftMirror(net.minecraft.world.item.ItemStack.parse(MinecraftServer.getServer().registryAccess(), compound).orElseThrow());
     }
 
@@ -552,41 +555,104 @@ public final class CraftMagicNumbers implements UnsafeValues {
 
         final int dataVersion = data.get("DataVersion").getAsInt();
         final int currentVersion = org.bukkit.craftbukkit.util.CraftMagicNumbers.INSTANCE.getDataVersion();
-        data = ca.spottedleaf.dataconverter.minecraft.MCDataConverter.convertJson(
-            ca.spottedleaf.dataconverter.minecraft.datatypes.MCTypeRegistry.ITEM_STACK,
-            data, false, dataVersion, currentVersion
-        );
+        data = (com.google.gson.JsonObject) MinecraftServer.getServer().fixerUpper.update(References.ITEM_STACK, new Dynamic<>(com.mojang.serialization.JsonOps.INSTANCE, data), dataVersion, currentVersion).getValue();
         com.mojang.serialization.DynamicOps<com.google.gson.JsonElement> ops = MinecraftServer.getServer().registryAccess().createSerializationContext(com.mojang.serialization.JsonOps.INSTANCE);
         return CraftItemStack.asCraftMirror(net.minecraft.world.item.ItemStack.CODEC.parse(ops, data).getOrThrow(IllegalArgumentException::new));
     }
 
     @Override
-    public byte[] serializeEntity(org.bukkit.entity.Entity entity) {
+    public byte[] serializeEntity(org.bukkit.entity.Entity entity, EntitySerializationFlag... serializationFlags) {
         Preconditions.checkNotNull(entity, "null cannot be serialized");
-        Preconditions.checkArgument(entity instanceof org.bukkit.craftbukkit.entity.CraftEntity, "only CraftEntities can be serialized");
+        Preconditions.checkArgument(entity instanceof CraftEntity, "Only CraftEntities can be serialized");
+
+        Set<EntitySerializationFlag> flags = Set.of(serializationFlags);
+        final boolean serializePassangers = flags.contains(EntitySerializationFlag.PASSENGERS);
+        final boolean forceSerialization = flags.contains(EntitySerializationFlag.FORCE);
+        final boolean allowPlayerSerialization = flags.contains(EntitySerializationFlag.PLAYER);
+        final boolean allowMiscSerialization = flags.contains(EntitySerializationFlag.MISC);
+        final boolean includeNonSaveable = allowPlayerSerialization || allowMiscSerialization;
+
+        net.minecraft.world.entity.Entity nmsEntity = ((CraftEntity) entity).getHandle();
+        (serializePassangers ? nmsEntity.getSelfAndPassengers() : Stream.of(nmsEntity)).forEach(e -> {
+            // Ensure force flag is not needed
+            Preconditions.checkArgument(
+                (e.getBukkitEntity().isValid() && e.getBukkitEntity().isPersistent()) || forceSerialization,
+                "Cannot serialize invalid or non-persistent entity %s(%s) without the FORCE flag",
+                e.getType().toShortString(),
+                e.getStringUUID()
+            );
 
-        net.minecraft.nbt.CompoundTag compound = new net.minecraft.nbt.CompoundTag();
-        ((org.bukkit.craftbukkit.entity.CraftEntity) entity).getHandle().serializeEntity(compound);
+            if (e instanceof Player) {
+                // Ensure player flag is not needed
+                Preconditions.checkArgument(
+                    allowPlayerSerialization,
+                    "Cannot serialize player(%s) without the PLAYER flag",
+                    e.getStringUUID()
+                );
+            } else {
+                // Ensure player flag is not needed
+                Preconditions.checkArgument(
+                    nmsEntity.getType().canSerialize() || allowMiscSerialization,
+                    "Cannot serialize misc non-saveable entity %s(%s) without the MISC flag",
+                    e.getType().toShortString(),
+                    e.getStringUUID()
+                );
+            }
+        });
+
+        CompoundTag compound = new CompoundTag();
+        if (serializePassangers) {
+            if (!nmsEntity.saveAsPassenger(compound, true, includeNonSaveable, forceSerialization)) {
+                throw new IllegalArgumentException("Couldn't serialize entity");
+            }
+        } else {
+            List<net.minecraft.world.entity.Entity> pass = new ArrayList<>(nmsEntity.getPassengers());
+            nmsEntity.passengers = com.google.common.collect.ImmutableList.of();
+            boolean serialized = nmsEntity.saveAsPassenger(compound, true, includeNonSaveable, forceSerialization);
+            nmsEntity.passengers = com.google.common.collect.ImmutableList.copyOf(pass);
+            if (!serialized) {
+                throw new IllegalArgumentException("Couldn't serialize entity");
+            }
+        }
         return serializeNbtToBytes(compound);
     }
 
     @Override
-    public org.bukkit.entity.Entity deserializeEntity(byte[] data, org.bukkit.World world, boolean preserveUUID) {
+    public org.bukkit.entity.Entity deserializeEntity(byte[] data, World world, boolean preserveUUID, boolean preservePassengers) {
         Preconditions.checkNotNull(data, "null cannot be deserialized");
-        Preconditions.checkArgument(data.length > 0, "cannot deserialize nothing");
+        Preconditions.checkArgument(data.length > 0, "Cannot deserialize empty data");
 
-        net.minecraft.nbt.CompoundTag compound = deserializeNbtFromBytes(data);
+        CompoundTag compound = deserializeNbtFromBytes(data);
         int dataVersion = compound.getInt("DataVersion");
-        compound = ca.spottedleaf.dataconverter.minecraft.MCDataConverter.convertTag(ca.spottedleaf.dataconverter.minecraft.datatypes.MCTypeRegistry.ENTITY, compound, dataVersion, this.getDataVersion());
+        compound = PlatformHooks.get().convertNBT(References.ENTITY, MinecraftServer.getServer().fixerUpper, compound, dataVersion, this.getDataVersion()); // Paper - possibly use dataconverter
+        if (!preservePassengers) {
+            compound.remove("Passengers");
+        }
+        net.minecraft.world.entity.Entity nmsEntity = deserializeEntity(compound, ((CraftWorld) world).getHandle(), preserveUUID);
+        return nmsEntity.getBukkitEntity();
+    }
+
+    private net.minecraft.world.entity.Entity deserializeEntity(CompoundTag compound, ServerLevel world, boolean preserveUUID) {
         if (!preserveUUID) {
-            // Generate a new UUID so we don't have to worry about deserializing the same entity twice
+            // Generate a new UUID, so we don't have to worry about deserializing the same entity twice
             compound.remove("UUID");
         }
-        return net.minecraft.world.entity.EntityType.create(compound, ((org.bukkit.craftbukkit.CraftWorld) world).getHandle(), net.minecraft.world.entity.EntitySpawnReason.LOAD)
-            .orElseThrow(() -> new IllegalArgumentException("An ID was not found for the data. Did you downgrade?")).getBukkitEntity();
+        net.minecraft.world.entity.Entity nmsEntity = net.minecraft.world.entity.EntityType.create(compound, world, net.minecraft.world.entity.EntitySpawnReason.LOAD)
+            .orElseThrow(() -> new IllegalArgumentException("An ID was not found for the data. Did you downgrade?"));
+        if (compound.contains("Passengers", Tag.TAG_LIST)) {
+            ListTag passengersCompound = compound.getList("Passengers", Tag.TAG_COMPOUND);
+            for (Tag tag : passengersCompound) {
+                if (!(tag instanceof CompoundTag serializedPassenger)) {
+                    continue;
+                }
+                net.minecraft.world.entity.Entity passengerEntity = deserializeEntity(serializedPassenger, world, preserveUUID);
+                passengerEntity.startRiding(nmsEntity, true);
+            }
+        }
+        return nmsEntity;
     }
 
-    private byte[] serializeNbtToBytes(net.minecraft.nbt.CompoundTag compound) {
+    private byte[] serializeNbtToBytes(CompoundTag compound) {
         compound.putInt("DataVersion", getDataVersion());
         java.io.ByteArrayOutputStream outputStream = new java.io.ByteArrayOutputStream();
         try {
@@ -600,8 +666,8 @@ public final class CraftMagicNumbers implements UnsafeValues {
         return outputStream.toByteArray();
     }
 
-    private net.minecraft.nbt.CompoundTag deserializeNbtFromBytes(byte[] data) {
-        net.minecraft.nbt.CompoundTag compound;
+    private CompoundTag deserializeNbtFromBytes(byte[] data) {
+        CompoundTag compound;
         try {
             compound = net.minecraft.nbt.NbtIo.readCompressed(
                 new java.io.ByteArrayInputStream(data), net.minecraft.nbt.NbtAccounter.unlimitedHeap()
diff --git a/src/main/java/org/bukkit/craftbukkit/util/DelegatedGeneratorAccess.java b/src/main/java/org/bukkit/craftbukkit/util/DelegatedGeneratorAccess.java
index 37458e8fd5d57acbf90a6bea4e66797cb07f69fa..09e87552159e24603aa9a4f658ab4449d7eaeb0a 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/DelegatedGeneratorAccess.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/DelegatedGeneratorAccess.java
@@ -613,8 +613,8 @@ public abstract class DelegatedGeneratorAccess implements WorldGenLevel {
     }
 
     @Override
-    public BlockHitResult clip(ClipContext raytrace1, BlockPos blockposition) {
-        return this.handle.clip(raytrace1, blockposition);
+    public BlockHitResult clip(ClipContext traverseContext, BlockPos traversePos) {
+        return this.handle.clip(traverseContext, traversePos);
     }
 
     @Override
@@ -810,13 +810,6 @@ public abstract class DelegatedGeneratorAccess implements WorldGenLevel {
     public ChunkAccess getChunkIfLoadedImmediately(final int x, final int z) {
         return this.handle.getChunkIfLoadedImmediately(x, z);
     }
-
-    // Paper start - rewrite chunk system
-    @Override
-    public java.util.List<net.minecraft.world.entity.Entity> moonrise$getHardCollidingEntities(final net.minecraft.world.entity.Entity entity, final net.minecraft.world.phys.AABB box, final java.util.function.Predicate<? super net.minecraft.world.entity.Entity> predicate) {
-        return this.handle.moonrise$getHardCollidingEntities(entity, box, predicate);
-    }
-    // Paper end - rewrite chunk system
     // Paper end
 }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
index 11bc399aad01171264f7c85eb69367da2ae61f27..774556a62eb240da42e84db4502e2ed43495be17 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
@@ -11,7 +11,7 @@ public final class Versioning {
     public static String getBukkitVersion() {
         String result = "Unknown-Version";
 
-        InputStream stream = Bukkit.class.getClassLoader().getResourceAsStream("META-INF/maven/kr.ms.nogyang/NogyangSpigot-API/pom.properties");
+        InputStream stream = Bukkit.class.getClassLoader().getResourceAsStream("META-INF/maven/io.papermc.paper/paper-api/pom.properties");
         Properties properties = new Properties();
 
         if (stream != null) {
diff --git a/src/main/java/org/spigotmc/AsyncCatcher.java b/src/main/java/org/spigotmc/AsyncCatcher.java
index 1f23e775eba1c34e01145bd91b0ce26fed6ca9de..50f01faa88c8c658252fade3748f20e48e9c8432 100644
--- a/src/main/java/org/spigotmc/AsyncCatcher.java
+++ b/src/main/java/org/spigotmc/AsyncCatcher.java
@@ -2,17 +2,14 @@ package org.spigotmc;
 
 import net.minecraft.server.MinecraftServer;
 
-public class AsyncCatcher
-{
+public class AsyncCatcher {
 
     public static boolean enabled = true;
 
-    public static void catchOp(String reason)
-    {
-        if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThread()) // Paper // Paper - rewrite chunk system
-        {
-            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable()); // Paper
-            throw new IllegalStateException( "Asynchronous " + reason + "!" );
+    public static void catchOp(String reason) {
+        if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThread()) { // Paper - chunk system
+            MinecraftServer.LOGGER.error("Thread {} failed main thread check: {}", Thread.currentThread().getName(), reason, new Throwable()); // Paper
+            throw new IllegalStateException("Asynchronous " + reason + "!");
         }
     }
 }
diff --git a/src/main/java/org/spigotmc/LimitStream.java b/src/main/java/org/spigotmc/LimitStream.java
index 8de241a921daaf4bab565a72f51cd08561c99da9..60e9ec374ebfedf38ae9dc24766d9127090b4a3c 100644
--- a/src/main/java/org/spigotmc/LimitStream.java
+++ b/src/main/java/org/spigotmc/LimitStream.java
@@ -5,35 +5,30 @@ import java.io.IOException;
 import java.io.InputStream;
 import net.minecraft.nbt.NbtAccounter;
 
-public class LimitStream extends FilterInputStream
-{
+public class LimitStream extends FilterInputStream {
 
     private final NbtAccounter limit;
 
-    public LimitStream(InputStream is, NbtAccounter limit)
-    {
-        super( is );
+    public LimitStream(InputStream is, NbtAccounter limit) {
+        super(is);
         this.limit = limit;
     }
 
     @Override
-    public int read() throws IOException
-    {
-        this.limit.accountBytes( 1 );
+    public int read() throws IOException {
+        this.limit.accountBytes(1);
         return super.read();
     }
 
     @Override
-    public int read(byte[] b) throws IOException
-    {
-        this.limit.accountBytes( b.length );
-        return super.read( b );
+    public int read(byte[] b) throws IOException {
+        this.limit.accountBytes(b.length);
+        return super.read(b);
     }
 
     @Override
-    public int read(byte[] b, int off, int len) throws IOException
-    {
-        this.limit.accountBytes( len );
-        return super.read( b, off, len );
+    public int read(byte[] b, int off, int len) throws IOException {
+        this.limit.accountBytes(len);
+        return super.read(b, off, len);
     }
 }
diff --git a/src/main/java/org/spigotmc/RestartCommand.java b/src/main/java/org/spigotmc/RestartCommand.java
index 3ba27955548a26367a87d6b87c3c61beb299dfb9..3287d399511446178dfb0a34f9b1a3a2510d877d 100644
--- a/src/main/java/org/spigotmc/RestartCommand.java
+++ b/src/main/java/org/spigotmc/RestartCommand.java
@@ -1,115 +1,85 @@
 package org.spigotmc;
 
 import java.io.File;
-import java.util.List;
+import java.util.Locale;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerPlayer;
 import org.bukkit.command.Command;
 import org.bukkit.command.CommandSender;
 import org.bukkit.craftbukkit.util.CraftChatMessage;
 
-public class RestartCommand extends Command
-{
+public class RestartCommand extends Command {
 
-    public RestartCommand(String name)
-    {
-        super( name );
+    public RestartCommand(String name) {
+        super(name);
         this.description = "Restarts the server";
         this.usageMessage = "/restart";
-        this.setPermission( "bukkit.command.restart" );
+        this.setPermission("bukkit.command.restart");
     }
 
     @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args)
-    {
-        if ( this.testPermission( sender ) )
-        {
-            MinecraftServer.getServer().processQueue.add( new Runnable()
-            {
-                @Override
-                public void run()
-                {
-                    RestartCommand.restart();
-                }
-            } );
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (this.testPermission(sender)) {
+            MinecraftServer.getServer().processQueue.add(RestartCommand::restart);
         }
         return true;
     }
 
-    public static void restart()
-    {
-        RestartCommand.restart( SpigotConfig.restartScript );
+    public static void restart() {
+        RestartCommand.restart(SpigotConfig.restartScript);
     }
 
-    private static void restart(final String restartScript)
-    {
-        AsyncCatcher.enabled = false; // Disable async catcher incase it interferes with us
-        try
-        {
+    private static void restart(final String restartScript) {
+        AsyncCatcher.enabled = false; // Disable async catcher in case it interferes with us
+        try {
             // Paper - extract method and cleanup
-            boolean isRestarting = addShutdownHook( restartScript );
-            if ( isRestarting )
-            {
-                System.out.println( "Attempting to restart with " + SpigotConfig.restartScript );
-            } else
-            {
-                System.out.println( "Startup script '" + SpigotConfig.restartScript + "' does not exist! Stopping server." );
+            boolean isRestarting = addShutdownHook(restartScript);
+            if (isRestarting) {
+                System.out.println("Attempting to restart with " + SpigotConfig.restartScript);
+            } else {
+                System.out.println("Startup script '" + SpigotConfig.restartScript + "' does not exist! Stopping server.");
             }
             // Stop the watchdog
             WatchdogThread.doStop();
 
-            shutdownServer( isRestarting );
+            shutdownServer(isRestarting);
             // Paper end
-        } catch ( Exception ex )
-        {
+        } catch (Exception ex) {
             ex.printStackTrace();
         }
     }
 
     // Paper start - sync copied from above with minor changes, async added
-    private static void shutdownServer(boolean isRestarting)
-    {
-        if ( MinecraftServer.getServer().isSameThread() )
-        {
+    private static void shutdownServer(boolean isRestarting) {
+        if (MinecraftServer.getServer().isSameThread()) {
             // Kick all players
-            for ( ServerPlayer p : com.google.common.collect.ImmutableList.copyOf( MinecraftServer.getServer().getPlayerList().players ) )
-            {
-                p.connection.disconnect( CraftChatMessage.fromStringOrEmpty( SpigotConfig.restartMessage, true ), org.bukkit.event.player.PlayerKickEvent.Cause.RESTART_COMMAND); // Paper - kick event reason (cause is never used))
+            for (ServerPlayer p : com.google.common.collect.ImmutableList.copyOf(MinecraftServer.getServer().getPlayerList().players)) {
+                p.connection.disconnect(CraftChatMessage.fromStringOrEmpty(SpigotConfig.restartMessage, true), org.bukkit.event.player.PlayerKickEvent.Cause.RESTART_COMMAND); // Paper - kick event reason (cause is never used)
             }
             // Give the socket a chance to send the packets
-            try
-            {
-                Thread.sleep( 100 );
-            } catch ( InterruptedException ex )
-            {
+            try {
+                Thread.sleep(100);
+            } catch (InterruptedException ex) {
             }
 
             closeSocket();
 
             // Actually shutdown
-            try
-            {
+            try {
                 MinecraftServer.getServer().close(); // calls stop()
-            } catch ( Throwable t )
-            {
+            } catch (Throwable t) {
             }
 
             // Actually stop the JVM
-            System.exit( 0 );
-
-        } else
-        {
+            System.exit(0);
+        } else {
             // Mark the server to shutdown at the end of the tick
-            MinecraftServer.getServer().safeShutdown( false, isRestarting );
+            MinecraftServer.getServer().safeShutdown(false, isRestarting);
 
             // wait 10 seconds to see if we're actually going to try shutdown
-            try
-            {
-                Thread.sleep( 10000 );
-            }
-            catch (InterruptedException ignored)
-            {
-            }
+            try {
+                Thread.sleep(10000);
+            } catch (InterruptedException ignored) {}
 
             // Check if we've actually hit a state where the server is going to safely shutdown
             // if we have, let the server stop as usual
@@ -117,63 +87,46 @@ public class RestartCommand extends Command
 
             // If the server hasn't stopped by now, assume worse case and kill
             closeSocket();
-            System.exit( 0 );
+            System.exit(0);
         }
     }
     // Paper end
 
     // Paper - Split from moved code
-    private static void closeSocket()
-    {
+    private static void closeSocket() {
         // Close the socket so we can rebind with the new process
         MinecraftServer.getServer().getConnection().stop();
 
         // Give time for it to kick in
-        try
-        {
-            Thread.sleep( 100 );
-        } catch ( InterruptedException ex )
-        {
-        }
+        try {
+            Thread.sleep(100);
+        } catch (InterruptedException ignored) {}
     }
     // Paper end
 
     // Paper start - copied from above and modified to return if the hook registered
-    public static boolean addShutdownHook(String restartScript) // Paper
-    {
-        String[] split = restartScript.split( " " );
-        if ( split.length > 0 && new File( split[0] ).isFile() )
-        {
-            Thread shutdownHook = new Thread()
-            {
-                @Override
-                public void run()
-                {
-                    try
-                    {
-                        String os = System.getProperty( "os.name" ).toLowerCase(java.util.Locale.ENGLISH);
-                        if ( os.contains( "win" ) )
-                        {
-                            Runtime.getRuntime().exec( "cmd /c start " + restartScript );
-                        } else
-                        {
-                            Runtime.getRuntime().exec( "sh " + restartScript );
-                        }
-                    } catch ( Exception e )
-                    {
-                        e.printStackTrace();
+    public static boolean addShutdownHook(String restartScript) {
+        String[] split = restartScript.split(" ");
+        if (split.length > 0 && new File(split[0]).isFile()) {
+            Thread shutdownHook = new Thread(() -> {
+                try {
+                    String os = System.getProperty("os.name").toLowerCase(Locale.ENGLISH);
+                    if (os.contains("win")) {
+                        Runtime.getRuntime().exec("cmd /c start " + restartScript);
+                    } else {
+                        Runtime.getRuntime().exec("sh " + restartScript);
                     }
+                } catch (Exception e) {
+                    e.printStackTrace();
                 }
-            };
+            });
 
-            shutdownHook.setDaemon( true );
-            Runtime.getRuntime().addShutdownHook( shutdownHook );
+            shutdownHook.setDaemon(true);
+            Runtime.getRuntime().addShutdownHook(shutdownHook);
             return true;
-        } else
-        {
+        } else {
             return false;
         }
     }
     // Paper end
-
 }
diff --git a/src/main/java/org/spigotmc/SpigotCommand.java b/src/main/java/org/spigotmc/SpigotCommand.java
index ac0fd418fcb437896dfdff53ab3eff19833d25fb..1b60abf5f5951288f6d54f522621472673eada6e 100644
--- a/src/main/java/org/spigotmc/SpigotCommand.java
+++ b/src/main/java/org/spigotmc/SpigotCommand.java
@@ -1,12 +1,14 @@
 package org.spigotmc;
 
 import java.io.File;
+import net.kyori.adventure.text.format.NamedTextColor;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
-import org.bukkit.ChatColor;
 import org.bukkit.command.Command;
 import org.bukkit.command.CommandSender;
 
+import static net.kyori.adventure.text.Component.text;
+
 public class SpigotCommand extends Command {
 
     public SpigotCommand(String name) {
@@ -21,13 +23,17 @@ public class SpigotCommand extends Command {
         if (!this.testPermission(sender)) return true;
 
         if (args.length != 1) {
-            sender.sendMessage(ChatColor.RED + "Usage: " + this.usageMessage);
+            sender.sendMessage(text("Usage: " + this.usageMessage, NamedTextColor.RED));
             return false;
         }
 
         if (args[0].equals("reload")) {
-            Command.broadcastCommandMessage(sender, ChatColor.RED + "Please note that this command is not supported and may cause issues.");
-            Command.broadcastCommandMessage(sender, ChatColor.RED + "If you encounter any issues please use the /stop command to restart your server.");
+            Command.broadcastCommandMessage(sender, text().color(NamedTextColor.RED)
+                .append(text("Please note that this command is not supported and may cause issues."))
+                .appendNewline()
+                .append(text("If you encounter any issues please use the /stop command to restart your server."))
+                .build()
+            );
 
             MinecraftServer console = MinecraftServer.getServer();
             org.spigotmc.SpigotConfig.init((File) console.options.valueOf("spigot-settings"));
@@ -36,7 +42,7 @@ public class SpigotCommand extends Command {
             }
             console.server.reloadCount++;
 
-            Command.broadcastCommandMessage(sender, ChatColor.GREEN + "Reload complete.");
+            Command.broadcastCommandMessage(sender, text("Reload complete.", NamedTextColor.GREEN));
         }
 
         return true;
diff --git a/src/main/java/org/spigotmc/SpigotConfig.java b/src/main/java/org/spigotmc/SpigotConfig.java
index 4dbb109d0526afee99b9190fc256585121aac9b5..e0d4222a99f22d7130d95cf29b034a98f2f3b76e 100644
--- a/src/main/java/org/spigotmc/SpigotConfig.java
+++ b/src/main/java/org/spigotmc/SpigotConfig.java
@@ -28,360 +28,289 @@ import org.bukkit.configuration.ConfigurationSection;
 import org.bukkit.configuration.InvalidConfigurationException;
 import org.bukkit.configuration.file.YamlConfiguration;
 
-public class SpigotConfig
-{
+public class SpigotConfig {
 
     private static File CONFIG_FILE;
-    private static final String HEADER = "This is the main configuration file for Spigot.\n"
-            + "As you can see, there's tons to configure. Some options may impact gameplay, so use\n"
-            + "with caution, and make sure you know what each option does before configuring.\n"
-            + "For a reference for any variable inside this file, check out the Spigot wiki at\n"
-            + "http://www.spigotmc.org/wiki/spigot-configuration/\n"
-            + "\n"
-            + "If you need help with the configuration or have any questions related to Spigot,\n"
-            + "join us at the Discord or drop by our forums and leave a post.\n"
-            + "\n"
-            + "Discord: https://www.spigotmc.org/go/discord\n"
-            + "Forums: http://www.spigotmc.org/\n";
+    private static final String HEADER = """
+        This is the main configuration file for Spigot.
+        As you can see, there's tons to configure. Some options may impact gameplay, so use
+        with caution, and make sure you know what each option does before configuring.
+        For a reference for any variable inside this file, check out the Spigot wiki at
+        http://www.spigotmc.org/wiki/spigot-configuration/
+        
+        If you need help with the configuration or have any questions related to Spigot,
+        join us at the Discord or drop by our forums and leave a post.
+        
+        Discord: https://www.spigotmc.org/go/discord
+        Forums: http://www.spigotmc.org/
+        """;
     /*========================================================================*/
     public static YamlConfiguration config;
     static int version;
     static Map<String, Command> commands;
     /*========================================================================*/
-    private static Metrics metrics;
 
-    public static void init(File configFile)
-    {
+    public static void init(File configFile) {
         SpigotConfig.CONFIG_FILE = configFile;
         SpigotConfig.config = new YamlConfiguration();
-        try
-        {
-            SpigotConfig.config.load( SpigotConfig.CONFIG_FILE );
-        } catch ( IOException ex )
-        {
-        } catch ( InvalidConfigurationException ex )
-        {
-            Bukkit.getLogger().log( Level.SEVERE, "Could not load spigot.yml, please correct your syntax errors", ex );
-            throw Throwables.propagate( ex );
+        try {
+            SpigotConfig.config.load(SpigotConfig.CONFIG_FILE);
+        } catch (IOException ignored) {
+        } catch (InvalidConfigurationException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Could not load spigot.yml, please correct your syntax errors", ex);
+            throw Throwables.propagate(ex);
         }
 
-        SpigotConfig.config.options().header( SpigotConfig.HEADER );
-        SpigotConfig.config.options().copyDefaults( true );
+        SpigotConfig.config.options().header(SpigotConfig.HEADER);
+        SpigotConfig.config.options().copyDefaults(true);
 
-        SpigotConfig.commands = new HashMap<String, Command>();
-        SpigotConfig.commands.put( "spigot", new SpigotCommand( "spigot" ) );
+        SpigotConfig.commands = new HashMap<>();
+        SpigotConfig.commands.put("spigot", new SpigotCommand("spigot"));
 
-        SpigotConfig.version = SpigotConfig.getInt( "config-version", 12 );
-        SpigotConfig.set( "config-version", 12 );
-        SpigotConfig.readConfig( SpigotConfig.class, null );
+        SpigotConfig.version = SpigotConfig.getInt("config-version", 12);
+        SpigotConfig.set("config-version", 12);
+        SpigotConfig.readConfig(SpigotConfig.class, null);
     }
 
-    public static void registerCommands()
-    {
-        for ( Map.Entry<String, Command> entry : SpigotConfig.commands.entrySet() )
-        {
-            MinecraftServer.getServer().server.getCommandMap().register( entry.getKey(), "Spigot", entry.getValue() );
+    public static void registerCommands() {
+        for (Map.Entry<String, Command> entry : SpigotConfig.commands.entrySet()) {
+            MinecraftServer.getServer().server.getCommandMap().register(entry.getKey(), "Spigot", entry.getValue());
         }
+    }
 
-        /* // Paper - Replace with our own
-        if ( SpigotConfig.metrics == null )
-        {
-            try
-            {
-                SpigotConfig.metrics = new Metrics();
-                SpigotConfig.metrics.start();
-            } catch ( IOException ex )
-            {
-                Bukkit.getServer().getLogger().log( Level.SEVERE, "Could not start metrics service", ex );
-            }
-        }
-        */ // Paper end
-    }
-
-    public static void readConfig(Class<?> clazz, Object instance) // Paper - package-private -> public
-    {
-        for ( Method method : clazz.getDeclaredMethods() )
-        {
-            if ( Modifier.isPrivate( method.getModifiers() ) )
-            {
-                if ( method.getParameterTypes().length == 0 && method.getReturnType() == Void.TYPE )
-                {
-                    try
-                    {
-                        method.setAccessible( true );
-                        method.invoke( instance );
-                    } catch ( InvocationTargetException ex )
-                    {
-                        throw Throwables.propagate( ex.getCause() );
-                    } catch ( Exception ex )
-                    {
-                        Bukkit.getLogger().log( Level.SEVERE, "Error invoking " + method, ex );
+    public static void readConfig(Class<?> clazz, Object instance) { // Paper - package-private -> public
+        for (Method method : clazz.getDeclaredMethods()) {
+            if (Modifier.isPrivate(method.getModifiers())) {
+                if (method.getParameterTypes().length == 0 && method.getReturnType() == Void.TYPE) {
+                    try {
+                        method.setAccessible(true);
+                        method.invoke(instance);
+                    } catch (InvocationTargetException ex) {
+                        throw Throwables.propagate(ex.getCause());
+                    } catch (Exception ex) {
+                        Bukkit.getLogger().log(Level.SEVERE, "Error invoking " + method, ex);
                     }
                 }
             }
         }
 
-        try
-        {
-            SpigotConfig.config.save( SpigotConfig.CONFIG_FILE );
-        } catch ( IOException ex )
-        {
-            Bukkit.getLogger().log( Level.SEVERE, "Could not save " + SpigotConfig.CONFIG_FILE, ex );
+        try {
+            SpigotConfig.config.save(SpigotConfig.CONFIG_FILE);
+        } catch (IOException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Could not save " + SpigotConfig.CONFIG_FILE, ex);
         }
     }
 
-    private static void set(String path, Object val)
-    {
-        SpigotConfig.config.set( path, val );
+    private static void set(String path, Object val) {
+        SpigotConfig.config.set(path, val);
     }
 
-    private static boolean getBoolean(String path, boolean def)
-    {
-        SpigotConfig.config.addDefault( path, def );
-        return SpigotConfig.config.getBoolean( path, SpigotConfig.config.getBoolean( path ) );
+    private static boolean getBoolean(String path, boolean def) {
+        SpigotConfig.config.addDefault(path, def);
+        return SpigotConfig.config.getBoolean(path, SpigotConfig.config.getBoolean(path));
     }
 
-    private static int getInt(String path, int def)
-    {
-        SpigotConfig.config.addDefault( path, def );
-        return SpigotConfig.config.getInt( path, SpigotConfig.config.getInt( path ) );
+    private static int getInt(String path, int def) {
+        SpigotConfig.config.addDefault(path, def);
+        return SpigotConfig.config.getInt(path, SpigotConfig.config.getInt(path));
     }
 
-    private static <T> List getList(String path, T def)
-    {
-        SpigotConfig.config.addDefault( path, def );
-        return (List<T>) SpigotConfig.config.getList( path, SpigotConfig.config.getList( path ) );
+    private static <T> List getList(String path, T def) {
+        SpigotConfig.config.addDefault(path, def);
+        return (List<T>) SpigotConfig.config.getList(path, SpigotConfig.config.getList(path));
     }
 
-    private static String getString(String path, String def)
-    {
-        SpigotConfig.config.addDefault( path, def );
-        return SpigotConfig.config.getString( path, SpigotConfig.config.getString( path ) );
+    private static String getString(String path, String def) {
+        SpigotConfig.config.addDefault(path, def);
+        return SpigotConfig.config.getString(path, SpigotConfig.config.getString(path));
     }
 
-    private static double getDouble(String path, double def)
-    {
-        SpigotConfig.config.addDefault( path, def );
-        return SpigotConfig.config.getDouble( path, SpigotConfig.config.getDouble( path ) );
+    private static double getDouble(String path, double def) {
+        SpigotConfig.config.addDefault(path, def);
+        return SpigotConfig.config.getDouble(path, SpigotConfig.config.getDouble(path));
     }
 
     public static boolean logCommands;
-    private static void logCommands()
-    {
-        SpigotConfig.logCommands = SpigotConfig.getBoolean( "commands.log", true );
+    private static void logCommands() {
+        SpigotConfig.logCommands = SpigotConfig.getBoolean("commands.log", true);
     }
 
     public static int tabComplete;
     public static boolean sendNamespaced;
-    private static void tabComplete()
-    {
-        if ( SpigotConfig.version < 6 )
-        {
-            boolean oldValue = SpigotConfig.getBoolean( "commands.tab-complete", true );
-            if ( oldValue )
-            {
-                SpigotConfig.set( "commands.tab-complete", 0 );
-            } else
-            {
-                SpigotConfig.set( "commands.tab-complete", -1 );
+    private static void tabComplete() {
+        if (SpigotConfig.version < 6) {
+            boolean oldValue = SpigotConfig.getBoolean("commands.tab-complete", true);
+            if (oldValue) {
+                SpigotConfig.set("commands.tab-complete", 0);
+            } else {
+                SpigotConfig.set("commands.tab-complete", -1);
             }
         }
-        SpigotConfig.tabComplete = SpigotConfig.getInt( "commands.tab-complete", 0 );
-        SpigotConfig.sendNamespaced = SpigotConfig.getBoolean( "commands.send-namespaced", true );
+        SpigotConfig.tabComplete = SpigotConfig.getInt("commands.tab-complete", 0);
+        SpigotConfig.sendNamespaced = SpigotConfig.getBoolean("commands.send-namespaced", true);
     }
 
     public static String whitelistMessage;
     public static String unknownCommandMessage;
     public static String serverFullMessage;
     public static String outdatedClientMessage = "Outdated client! Please use {0}";
-    public static String outdatedServerMessage = "Outdated server! I\'m still on {0}";
-    private static String transform(String s)
-    {
-        return ChatColor.translateAlternateColorCodes( '&', s ).replaceAll( "\\\\n", "\n" );
-    }
-    private static void messages()
-    {
-        if (SpigotConfig.version < 8)
-        {
-            SpigotConfig.set( "messages.outdated-client", SpigotConfig.outdatedClientMessage );
-            SpigotConfig.set( "messages.outdated-server", SpigotConfig.outdatedServerMessage );
+    public static String outdatedServerMessage = "Outdated server! I'm still on {0}";
+
+    private static String transform(String s) {
+        return ChatColor.translateAlternateColorCodes('&', s).replaceAll("\\\\n", "\n");
+    }
+
+    private static void messages() {
+        if (SpigotConfig.version < 8) {
+            SpigotConfig.set("messages.outdated-client", SpigotConfig.outdatedClientMessage);
+            SpigotConfig.set("messages.outdated-server", SpigotConfig.outdatedServerMessage);
         }
 
-        SpigotConfig.whitelistMessage = SpigotConfig.transform( SpigotConfig.getString( "messages.whitelist", "You are not whitelisted on this server!" ) );
-        SpigotConfig.unknownCommandMessage = SpigotConfig.transform( SpigotConfig.getString( "messages.unknown-command", "Unknown command. Type \"/help\" for help." ) );
-        SpigotConfig.serverFullMessage = SpigotConfig.transform( SpigotConfig.getString( "messages.server-full", "The server is full!" ) );
-        SpigotConfig.outdatedClientMessage = SpigotConfig.transform( SpigotConfig.getString( "messages.outdated-client", SpigotConfig.outdatedClientMessage ) );
-        SpigotConfig.outdatedServerMessage = SpigotConfig.transform( SpigotConfig.getString( "messages.outdated-server", SpigotConfig.outdatedServerMessage ) );
+        SpigotConfig.whitelistMessage = SpigotConfig.transform(SpigotConfig.getString("messages.whitelist", "You are not whitelisted on this server!"));
+        SpigotConfig.unknownCommandMessage = SpigotConfig.transform(SpigotConfig.getString("messages.unknown-command", "Unknown command. Type \"/help\" for help."));
+        SpigotConfig.serverFullMessage = SpigotConfig.transform(SpigotConfig.getString("messages.server-full", "The server is full!"));
+        SpigotConfig.outdatedClientMessage = SpigotConfig.transform(SpigotConfig.getString("messages.outdated-client", SpigotConfig.outdatedClientMessage));
+        SpigotConfig.outdatedServerMessage = SpigotConfig.transform(SpigotConfig.getString("messages.outdated-server", SpigotConfig.outdatedServerMessage));
     }
 
     public static int timeoutTime = 60;
     public static boolean restartOnCrash = true;
     public static String restartScript = "./start.sh";
     public static String restartMessage;
-    private static void watchdog()
-    {
-        SpigotConfig.timeoutTime = SpigotConfig.getInt( "settings.timeout-time", SpigotConfig.timeoutTime );
-        SpigotConfig.restartOnCrash = SpigotConfig.getBoolean( "settings.restart-on-crash", SpigotConfig.restartOnCrash );
-        SpigotConfig.restartScript = SpigotConfig.getString( "settings.restart-script", SpigotConfig.restartScript );
-        SpigotConfig.restartMessage = SpigotConfig.transform( SpigotConfig.getString( "messages.restart", "Server is restarting" ) );
-        SpigotConfig.commands.put( "restart", new RestartCommand( "restart" ) );
-        // WatchdogThread.doStart( SpigotConfig.timeoutTime, SpigotConfig.restartOnCrash ); // Paper - moved to after paper config initialization
+    private static void watchdog() {
+        SpigotConfig.timeoutTime = SpigotConfig.getInt("settings.timeout-time", SpigotConfig.timeoutTime);
+        SpigotConfig.restartOnCrash = SpigotConfig.getBoolean("settings.restart-on-crash", SpigotConfig.restartOnCrash);
+        SpigotConfig.restartScript = SpigotConfig.getString("settings.restart-script", SpigotConfig.restartScript);
+        SpigotConfig.restartMessage = SpigotConfig.transform(SpigotConfig.getString("messages.restart", "Server is restarting"));
+        SpigotConfig.commands.put("restart", new RestartCommand("restart"));
     }
 
     public static boolean bungee;
     private static void bungee() {
-        if ( SpigotConfig.version < 4 )
-        {
-            SpigotConfig.set( "settings.bungeecord", false );
-            System.out.println( "Outdated config, disabling BungeeCord support!" );
+        if (SpigotConfig.version < 4) {
+            SpigotConfig.set("settings.bungeecord", false);
+            System.out.println("Outdated config, disabling BungeeCord support!");
         }
-        SpigotConfig.bungee = SpigotConfig.getBoolean( "settings.bungeecord", false );
+        SpigotConfig.bungee = SpigotConfig.getBoolean("settings.bungeecord", false);
     }
 
-    private static void nettyThreads()
-    {
-        int count = SpigotConfig.getInt( "settings.netty-threads", 4 );
-        System.setProperty( "io.netty.eventLoopThreads", Integer.toString( count ) );
-        Bukkit.getLogger().log( Level.INFO, "Using {0} threads for Netty based IO", count );
+    private static void nettyThreads() {
+        int count = SpigotConfig.getInt("settings.netty-threads", 4);
+        System.setProperty("io.netty.eventLoopThreads", Integer.toString(count));
+        Bukkit.getLogger().log(Level.INFO, "Using {0} threads for Netty based IO", count);
     }
 
     public static boolean disableStatSaving;
     public static Map<ResourceLocation, Integer> forcedStats = new HashMap<>();
-    private static void stats()
-    {
-        SpigotConfig.disableStatSaving = SpigotConfig.getBoolean( "stats.disable-saving", false );
 
-        if ( !SpigotConfig.config.contains( "stats.forced-stats" ) ) {
-            SpigotConfig.config.createSection( "stats.forced-stats" );
+    private static void stats() {
+        SpigotConfig.disableStatSaving = SpigotConfig.getBoolean("stats.disable-saving", false);
+
+        if (!SpigotConfig.config.contains("stats.forced-stats")) {
+            SpigotConfig.config.createSection("stats.forced-stats");
         }
 
-        ConfigurationSection section = SpigotConfig.config.getConfigurationSection( "stats.forced-stats" );
-        for ( String name : section.getKeys( true ) )
-        {
-            if ( section.isInt( name ) )
-            {
-                try
-                {
-                    ResourceLocation key = ResourceLocation.parse( name );
-                    if ( BuiltInRegistries.CUSTOM_STAT.get( key ) == null )
-                    {
+        ConfigurationSection section = SpigotConfig.config.getConfigurationSection("stats.forced-stats");
+        for (String name : section.getKeys(true)) {
+            if (section.isInt(name)) {
+                try {
+                    ResourceLocation key = ResourceLocation.parse(name);
+                    if (BuiltInRegistries.CUSTOM_STAT.get(key) == null) {
                         Bukkit.getLogger().log(Level.WARNING, "Ignoring non existent stats.forced-stats " + name);
                         continue;
                     }
-                    SpigotConfig.forcedStats.put( key, section.getInt( name ) );
-                } catch (Exception ex)
-                {
+                    SpigotConfig.forcedStats.put(key, section.getInt(name));
+                } catch (Exception ex) {
                     Bukkit.getLogger().log(Level.WARNING, "Ignoring invalid stats.forced-stats " + name);
                 }
             }
         }
     }
 
-    private static void tpsCommand()
-    {
-        SpigotConfig.commands.put( "tps", new TicksPerSecondCommand( "tps" ) );
+    private static void tpsCommand() {
+        SpigotConfig.commands.put("tps", new TicksPerSecondCommand("tps"));
     }
 
     public static int playerSample;
-    private static void playerSample()
-    {
-        SpigotConfig.playerSample = Math.max( SpigotConfig.getInt( "settings.sample-count", 12 ), 0 ); // Paper - Avoid negative counts
-        Bukkit.getLogger().log( Level.INFO, "Server Ping Player Sample Count: {0}", playerSample ); // Paper - Use logger
+    private static void playerSample() {
+        SpigotConfig.playerSample = Math.max(SpigotConfig.getInt("settings.sample-count", 12), 0); // Paper - Avoid negative counts
+        Bukkit.getLogger().log(Level.INFO, "Server Ping Player Sample Count: {0}", playerSample); // Paper - Use logger
     }
 
     public static int playerShuffle;
-    private static void playerShuffle()
-    {
-        SpigotConfig.playerShuffle = SpigotConfig.getInt( "settings.player-shuffle", 0 );
+    private static void playerShuffle() {
+        SpigotConfig.playerShuffle = SpigotConfig.getInt("settings.player-shuffle", 0);
     }
 
     public static List<String> spamExclusions;
-    private static void spamExclusions()
-    {
-        SpigotConfig.spamExclusions = SpigotConfig.getList( "commands.spam-exclusions", Arrays.asList( new String[]
-        {
-                "/skill"
-        } ) );
+    private static void spamExclusions() {
+        SpigotConfig.spamExclusions = SpigotConfig.getList("commands.spam-exclusions", List.of("/skill"));
     }
 
     public static boolean silentCommandBlocks;
-    private static void silentCommandBlocks()
-    {
-        SpigotConfig.silentCommandBlocks = SpigotConfig.getBoolean( "commands.silent-commandblock-console", false );
+    private static void silentCommandBlocks() {
+        SpigotConfig.silentCommandBlocks = SpigotConfig.getBoolean("commands.silent-commandblock-console", false);
     }
 
     public static Set<String> replaceCommands;
-    private static void replaceCommands()
-    {
-        if ( SpigotConfig.config.contains( "replace-commands" ) )
-        {
-            SpigotConfig.set( "commands.replace-commands", SpigotConfig.config.getStringList( "replace-commands" ) );
-            SpigotConfig.config.set( "replace-commands", null );
+    private static void replaceCommands() {
+        if (SpigotConfig.config.contains("replace-commands")) {
+            SpigotConfig.set("commands.replace-commands", SpigotConfig.config.getStringList("replace-commands"));
+            SpigotConfig.config.set("replace-commands", null);
         }
-        SpigotConfig.replaceCommands = new HashSet<String>( (List<String>) SpigotConfig.getList( "commands.replace-commands",
-                Arrays.asList( "setblock", "summon", "testforblock", "tellraw" ) ) );
+        SpigotConfig.replaceCommands = new HashSet<>(SpigotConfig.getList("commands.replace-commands",
+            Arrays.asList("setblock", "summon", "testforblock", "tellraw")));
     }
 
     public static int userCacheCap;
-    private static void userCacheCap()
-    {
-        SpigotConfig.userCacheCap = SpigotConfig.getInt( "settings.user-cache-size", 1000 );
+    private static void userCacheCap() {
+        SpigotConfig.userCacheCap = SpigotConfig.getInt("settings.user-cache-size", 1000);
     }
 
     public static boolean saveUserCacheOnStopOnly;
-    private static void saveUserCacheOnStopOnly()
-    {
-        SpigotConfig.saveUserCacheOnStopOnly = SpigotConfig.getBoolean( "settings.save-user-cache-on-stop-only", false );
+    private static void saveUserCacheOnStopOnly() {
+        SpigotConfig.saveUserCacheOnStopOnly = SpigotConfig.getBoolean("settings.save-user-cache-on-stop-only", false);
     }
 
     public static double movedWronglyThreshold;
-    private static void movedWronglyThreshold()
-    {
-        SpigotConfig.movedWronglyThreshold = SpigotConfig.getDouble( "settings.moved-wrongly-threshold", 0.0625D );
+    private static void movedWronglyThreshold() {
+        SpigotConfig.movedWronglyThreshold = SpigotConfig.getDouble("settings.moved-wrongly-threshold", 0.0625D);
     }
 
     public static double movedTooQuicklyMultiplier;
-    private static void movedTooQuicklyMultiplier()
-    {
-        SpigotConfig.movedTooQuicklyMultiplier = SpigotConfig.getDouble( "settings.moved-too-quickly-multiplier", 10.0D );
+    private static void movedTooQuicklyMultiplier() {
+        SpigotConfig.movedTooQuicklyMultiplier = SpigotConfig.getDouble("settings.moved-too-quickly-multiplier", 10.0D);
     }
 
     public static double maxAbsorption = 2048;
-    public static double maxHealth = 2048;
-    public static double movementSpeed = 2048;
+    public static double maxHealth = 1024;
+    public static double movementSpeed = 1024;
     public static double attackDamage = 2048;
-    private static void attributeMaxes()
-    {
-        SpigotConfig.maxAbsorption = SpigotConfig.getDouble( "settings.attribute.maxAbsorption.max", SpigotConfig.maxAbsorption );
-        ( (RangedAttribute) Attributes.MAX_ABSORPTION.value() ).maxValue = SpigotConfig.maxAbsorption;
-        SpigotConfig.maxHealth = SpigotConfig.getDouble( "settings.attribute.maxHealth.max", SpigotConfig.maxHealth );
-        ( (RangedAttribute) Attributes.MAX_HEALTH.value() ).maxValue = SpigotConfig.maxHealth;
-        SpigotConfig.movementSpeed = SpigotConfig.getDouble( "settings.attribute.movementSpeed.max", SpigotConfig.movementSpeed );
-        ( (RangedAttribute) Attributes.MOVEMENT_SPEED.value() ).maxValue = SpigotConfig.movementSpeed;
-        SpigotConfig.attackDamage = SpigotConfig.getDouble( "settings.attribute.attackDamage.max", SpigotConfig.attackDamage );
-        ( (RangedAttribute) Attributes.ATTACK_DAMAGE.value() ).maxValue = SpigotConfig.attackDamage;
+    private static void attributeMaxes() {
+        SpigotConfig.maxAbsorption = SpigotConfig.getDouble("settings.attribute.maxAbsorption.max", SpigotConfig.maxAbsorption);
+        ((RangedAttribute) Attributes.MAX_ABSORPTION.value()).maxValue = SpigotConfig.maxAbsorption;
+        SpigotConfig.maxHealth = SpigotConfig.getDouble("settings.attribute.maxHealth.max", SpigotConfig.maxHealth);
+        ((RangedAttribute) Attributes.MAX_HEALTH.value()).maxValue = SpigotConfig.maxHealth;
+        SpigotConfig.movementSpeed = SpigotConfig.getDouble("settings.attribute.movementSpeed.max", SpigotConfig.movementSpeed);
+        ((RangedAttribute) Attributes.MOVEMENT_SPEED.value()).maxValue = SpigotConfig.movementSpeed;
+        SpigotConfig.attackDamage = SpigotConfig.getDouble("settings.attribute.attackDamage.max", SpigotConfig.attackDamage);
+        ((RangedAttribute) Attributes.ATTACK_DAMAGE.value()).maxValue = SpigotConfig.attackDamage;
     }
 
     public static boolean debug;
-    private static void debug()
-    {
-        SpigotConfig.debug = SpigotConfig.getBoolean( "settings.debug", false );
+    private static void debug() {
+        SpigotConfig.debug = SpigotConfig.getBoolean("settings.debug", false);
 
-        if ( SpigotConfig.debug && !LogManager.getRootLogger().isTraceEnabled() )
-        {
+        if (SpigotConfig.debug && !LogManager.getRootLogger().isTraceEnabled()) {
             // Enable debug logging
-            LoggerContext ctx = (LoggerContext) LogManager.getContext( false );
+            LoggerContext ctx = (LoggerContext) LogManager.getContext(false);
             Configuration conf = ctx.getConfiguration();
-            conf.getLoggerConfig( LogManager.ROOT_LOGGER_NAME ).setLevel( org.apache.logging.log4j.Level.ALL );
-            ctx.updateLoggers( conf );
+            conf.getLoggerConfig(LogManager.ROOT_LOGGER_NAME).setLevel(org.apache.logging.log4j.Level.ALL);
+            ctx.updateLoggers(conf);
         }
 
-        if ( LogManager.getRootLogger().isTraceEnabled() )
-        {
-            Bukkit.getLogger().info( "Debug logging is enabled" );
-        } else
-        {
-            // Bukkit.getLogger().info( "Debug logging is disabled" ); // Paper - Don't log if debug logging isn't enabled.
+        if (LogManager.getRootLogger().isTraceEnabled()) {
+            Bukkit.getLogger().info("Debug logging is enabled");
         }
     }
 
@@ -389,7 +318,7 @@ public class SpigotConfig
     public static List<String> disabledAdvancements;
     private static void disabledAdvancements() {
         SpigotConfig.disableAdvancementSaving = SpigotConfig.getBoolean("advancements.disable-saving", false);
-        SpigotConfig.disabledAdvancements = SpigotConfig.getList("advancements.disabled", Arrays.asList(new String[]{"minecraft:story/disabled"}));
+        SpigotConfig.disabledAdvancements = SpigotConfig.getList("advancements.disabled", List.of("minecraft:story/disabled"));
     }
 
     public static boolean logVillagerDeaths;
diff --git a/src/main/java/org/spigotmc/SpigotWorldConfig.java b/src/main/java/org/spigotmc/SpigotWorldConfig.java
index 2c408fa4abcbe1171c58aee8799c8cf7867d0f0a..89e2adbc1e1a0709d03e151e3ffcdbff10a44098 100644
--- a/src/main/java/org/spigotmc/SpigotWorldConfig.java
+++ b/src/main/java/org/spigotmc/SpigotWorldConfig.java
@@ -4,86 +4,73 @@ import java.util.List;
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
 
-public class SpigotWorldConfig
-{
+public class SpigotWorldConfig {
 
     private final String worldName;
     private final YamlConfiguration config;
     private boolean verbose;
 
-    public SpigotWorldConfig(String worldName)
-    {
+    public SpigotWorldConfig(String worldName) {
         this.worldName = worldName;
         this.config = SpigotConfig.config;
         this.init();
     }
 
-    public void init()
-    {
-        this.verbose = this.getBoolean( "verbose", false ); // Paper
+    public void init() {
+        this.verbose = this.getBoolean("verbose", false); // Paper
 
-        this.log( "-------- World Settings For [" + this.worldName + "] --------" );
-        SpigotConfig.readConfig( SpigotWorldConfig.class, this );
+        this.log("-------- World Settings For [" + this.worldName + "] --------");
+        SpigotConfig.readConfig(SpigotWorldConfig.class, this);
     }
 
-    private void log(String s)
-    {
-        if ( this.verbose )
-        {
-            Bukkit.getLogger().info( s );
+    private void log(String s) {
+        if (this.verbose) {
+            Bukkit.getLogger().info(s);
         }
     }
 
-    private void set(String path, Object val)
-    {
-        this.config.set( "world-settings.default." + path, val );
+    private void set(String path, Object val) {
+        this.config.set("world-settings.default." + path, val);
     }
 
-    public boolean getBoolean(String path, boolean def)
-    {
-        this.config.addDefault( "world-settings.default." + path, def );
-        return this.config.getBoolean( "world-settings." + this.worldName + "." + path, this.config.getBoolean( "world-settings.default." + path ) );
+    public boolean getBoolean(String path, boolean def) {
+        this.config.addDefault("world-settings.default." + path, def);
+        return this.config.getBoolean("world-settings." + this.worldName + "." + path, this.config.getBoolean("world-settings.default." + path));
     }
 
-    public double getDouble(String path, double def)
-    {
-        this.config.addDefault( "world-settings.default." + path, def );
-        return this.config.getDouble( "world-settings." + this.worldName + "." + path, this.config.getDouble( "world-settings.default." + path ) );
+    public double getDouble(String path, double def) {
+        this.config.addDefault("world-settings.default." + path, def);
+        return this.config.getDouble("world-settings." + this.worldName + "." + path, this.config.getDouble("world-settings.default." + path));
     }
 
-    public int getInt(String path)
-    {
-        return this.config.getInt( "world-settings." + this.worldName + "." + path );
+    public int getInt(String path) {
+        return this.config.getInt("world-settings." + this.worldName + "." + path);
     }
 
-    public int getInt(String path, int def)
-    {
+    public int getInt(String path, int def) {
         // Paper start - get int without setting default
         return this.getInt(path, def, true);
     }
-    public int getInt(String path, int def, boolean setDef)
-    {
-        if (setDef) this.config.addDefault( "world-settings.default." + path, def );
-        return this.config.getInt( "world-settings." + this.worldName + "." + path, this.config.getInt( "world-settings.default." + path, def ) );
+
+    public int getInt(String path, int def, boolean setDef) {
+        if (setDef) this.config.addDefault("world-settings.default." + path, def);
+        return this.config.getInt("world-settings." + this.worldName + "." + path, this.config.getInt("world-settings.default." + path, def));
         // Paper end
     }
 
-    public <T> List getList(String path, T def)
-    {
-        this.config.addDefault( "world-settings.default." + path, def );
-        return (List<T>) this.config.getList( "world-settings." + this.worldName + "." + path, this.config.getList( "world-settings.default." + path ) );
+    public <T> List getList(String path, T def) {
+        this.config.addDefault("world-settings.default." + path, def);
+        return (List<T>) this.config.getList("world-settings." + this.worldName + "." + path, this.config.getList("world-settings.default." + path));
     }
 
-    public String getString(String path, String def)
-    {
-        this.config.addDefault( "world-settings.default." + path, def );
-        return this.config.getString( "world-settings." + this.worldName + "." + path, this.config.getString( "world-settings.default." + path ) );
+    public String getString(String path, String def) {
+        this.config.addDefault("world-settings.default." + path, def);
+        return this.config.getString("world-settings." + this.worldName + "." + path, this.config.getString("world-settings.default." + path));
     }
 
-    private Object get(String path, Object def)
-    {
-        this.config.addDefault( "world-settings.default." + path, def );
-        return this.config.get( "world-settings." + this.worldName + "." + path, this.config.get( "world-settings.default." + path ) );
+    private Object get(String path, Object def) {
+        this.config.addDefault("world-settings.default." + path, def);
+        return this.config.get("world-settings." + this.worldName + "." + path, this.config.get("world-settings.default." + path));
     }
 
     // Crop growth rates
@@ -109,102 +96,92 @@ public class SpigotWorldConfig
     public int caveVinesModifier;
     public int glowBerryModifier; // Paper
     public int pitcherPlantModifier; // Paper
-    private int getAndValidateGrowth(String crop)
-    {
-        int modifier = this.getInt( "growth." + crop.toLowerCase(java.util.Locale.ENGLISH) + "-modifier", 100 );
-        if ( modifier == 0 )
-        {
-            this.log( "Cannot set " + crop + " growth to zero, defaulting to 100" );
+
+    private int getAndValidateGrowth(String crop) {
+        int modifier = this.getInt("growth." + crop.toLowerCase(java.util.Locale.ENGLISH) + "-modifier", 100);
+        if (modifier == 0) {
+            this.log("Cannot set " + crop + " growth to zero, defaulting to 100");
             modifier = 100;
         }
-        this.log( crop + " Growth Modifier: " + modifier + "%" );
+        this.log(crop + " Growth Modifier: " + modifier + "%");
 
         return modifier;
     }
-    private void growthModifiers()
-    {
-        this.cactusModifier = this.getAndValidateGrowth( "Cactus" );
-        this.caneModifier = this.getAndValidateGrowth( "Cane" );
-        this.melonModifier = this.getAndValidateGrowth( "Melon" );
-        this.mushroomModifier = this.getAndValidateGrowth( "Mushroom" );
-        this.pumpkinModifier = this.getAndValidateGrowth( "Pumpkin" );
-        this.saplingModifier = this.getAndValidateGrowth( "Sapling" );
-        this.beetrootModifier = this.getAndValidateGrowth( "Beetroot" );
-        this.carrotModifier = this.getAndValidateGrowth( "Carrot" );
-        this.potatoModifier = this.getAndValidateGrowth( "Potato" );
+
+    private void growthModifiers() {
+        this.cactusModifier = this.getAndValidateGrowth("Cactus");
+        this.caneModifier = this.getAndValidateGrowth("Cane");
+        this.melonModifier = this.getAndValidateGrowth("Melon");
+        this.mushroomModifier = this.getAndValidateGrowth("Mushroom");
+        this.pumpkinModifier = this.getAndValidateGrowth("Pumpkin");
+        this.saplingModifier = this.getAndValidateGrowth("Sapling");
+        this.beetrootModifier = this.getAndValidateGrowth("Beetroot");
+        this.carrotModifier = this.getAndValidateGrowth("Carrot");
+        this.potatoModifier = this.getAndValidateGrowth("Potato");
         this.torchFlowerModifier = this.getAndValidateGrowth("TorchFlower"); // Paper
-        this.wheatModifier = this.getAndValidateGrowth( "Wheat" );
-        this.wartModifier = this.getAndValidateGrowth( "NetherWart" );
-        this.vineModifier = this.getAndValidateGrowth( "Vine" );
-        this.cocoaModifier = this.getAndValidateGrowth( "Cocoa" );
-        this.bambooModifier = this.getAndValidateGrowth( "Bamboo" );
-        this.sweetBerryModifier = this.getAndValidateGrowth( "SweetBerry" );
-        this.kelpModifier = this.getAndValidateGrowth( "Kelp" );
-        this.twistingVinesModifier = this.getAndValidateGrowth( "TwistingVines" );
-        this.weepingVinesModifier = this.getAndValidateGrowth( "WeepingVines" );
-        this.caveVinesModifier = this.getAndValidateGrowth( "CaveVines" );
+        this.wheatModifier = this.getAndValidateGrowth("Wheat");
+        this.wartModifier = this.getAndValidateGrowth("NetherWart");
+        this.vineModifier = this.getAndValidateGrowth("Vine");
+        this.cocoaModifier = this.getAndValidateGrowth("Cocoa");
+        this.bambooModifier = this.getAndValidateGrowth("Bamboo");
+        this.sweetBerryModifier = this.getAndValidateGrowth("SweetBerry");
+        this.kelpModifier = this.getAndValidateGrowth("Kelp");
+        this.twistingVinesModifier = this.getAndValidateGrowth("TwistingVines");
+        this.weepingVinesModifier = this.getAndValidateGrowth("WeepingVines");
+        this.caveVinesModifier = this.getAndValidateGrowth("CaveVines");
         this.glowBerryModifier = this.getAndValidateGrowth("GlowBerry"); // Paper
         this.pitcherPlantModifier = this.getAndValidateGrowth("PitcherPlant"); // Paper
     }
 
     public double itemMerge;
-    private void itemMerge()
-    {
-        this.itemMerge = this.getDouble("merge-radius.item", 0.5 );
-        this.log( "Item Merge Radius: " + this.itemMerge );
+    private void itemMerge() {
+        this.itemMerge = this.getDouble("merge-radius.item", 0.5);
+        this.log("Item Merge Radius: " + this.itemMerge);
     }
 
     public double expMerge;
-    private void expMerge()
-    {
-        this.expMerge = this.getDouble("merge-radius.exp", -1 );
-        this.log( "Experience Merge Radius: " + this.expMerge );
+    private void expMerge() {
+        this.expMerge = this.getDouble("merge-radius.exp", -1);
+        this.log("Experience Merge Radius: " + this.expMerge);
     }
 
     public int viewDistance;
-    private void viewDistance()
-    {
-        if ( SpigotConfig.version < 12 )
-        {
-            this.set( "view-distance", null );
+    private void viewDistance() {
+        if (SpigotConfig.version < 12) {
+            this.set("view-distance", null);
         }
 
-        Object viewDistanceObject = this.get( "view-distance", "default" );
-        this.viewDistance = ( viewDistanceObject ) instanceof Number ? ( (Number) viewDistanceObject ).intValue() : -1;
-        if ( this.viewDistance <= 0 )
-        {
+        Object viewDistanceObject = this.get("view-distance", "default");
+        this.viewDistance = (viewDistanceObject) instanceof Number ? ((Number) viewDistanceObject).intValue() : -1;
+        if (this.viewDistance <= 0) {
             this.viewDistance = Bukkit.getViewDistance();
         }
 
-        this.viewDistance = Math.max( Math.min( this.viewDistance, 32 ), 3 );
-        this.log( "View Distance: " + this.viewDistance );
+        this.viewDistance = Math.max(Math.min(this.viewDistance, 32), 3);
+        this.log("View Distance: " + this.viewDistance);
     }
 
     public int simulationDistance;
-    private void simulationDistance()
-    {
-        Object simulationDistanceObject = this.get( "simulation-distance", "default" );
-        this.simulationDistance = ( simulationDistanceObject ) instanceof Number ? ( (Number) simulationDistanceObject ).intValue() : -1;
-        if ( this.simulationDistance <= 0 )
-        {
+    private void simulationDistance() {
+        Object simulationDistanceObject = this.get("simulation-distance", "default");
+        this.simulationDistance = (simulationDistanceObject) instanceof Number ? ((Number) simulationDistanceObject).intValue() : -1;
+        if (this.simulationDistance <= 0) {
             this.simulationDistance = Bukkit.getSimulationDistance();
         }
 
-        this.log( "Simulation Distance: " + this.simulationDistance );
+        this.log("Simulation Distance: " + this.simulationDistance);
     }
 
     public byte mobSpawnRange;
-    private void mobSpawnRange()
-    {
-        this.mobSpawnRange = (byte) getInt( "mob-spawn-range", 8 ); // Paper - Vanilla
-        this.log( "Mob Spawn Range: " + this.mobSpawnRange );
+    private void mobSpawnRange() {
+        this.mobSpawnRange = (byte) getInt("mob-spawn-range", 8); // Paper - Vanilla
+        this.log("Mob Spawn Range: " + this.mobSpawnRange);
     }
 
     public int itemDespawnRate;
-    private void itemDespawnRate()
-    {
-        this.itemDespawnRate = this.getInt( "item-despawn-rate", 6000 );
-        this.log( "Item Despawn Rate: " + this.itemDespawnRate );
+    private void itemDespawnRate() {
+        this.itemDespawnRate = this.getInt("item-despawn-rate", 6000);
+        this.log("Item Despawn Rate: " + this.itemDespawnRate);
     }
 
     public int animalActivationRange = 32;
@@ -216,34 +193,34 @@ public class SpigotWorldConfig
     public int waterActivationRange = 16;
     public int villagerActivationRange = 32;
     public int wakeUpInactiveAnimals = 4;
-    public int wakeUpInactiveAnimalsEvery = 60*20;
-    public int wakeUpInactiveAnimalsFor = 5*20;
+    public int wakeUpInactiveAnimalsEvery = 60 * 20;
+    public int wakeUpInactiveAnimalsFor = 5 * 20;
     public int wakeUpInactiveMonsters = 8;
-    public int wakeUpInactiveMonstersEvery = 20*20;
-    public int wakeUpInactiveMonstersFor = 5*20;
+    public int wakeUpInactiveMonstersEvery = 20 * 20;
+    public int wakeUpInactiveMonstersFor = 5 * 20;
     public int wakeUpInactiveVillagers = 4;
-    public int wakeUpInactiveVillagersEvery = 30*20;
-    public int wakeUpInactiveVillagersFor = 5*20;
+    public int wakeUpInactiveVillagersEvery = 30 * 20;
+    public int wakeUpInactiveVillagersFor = 5 * 20;
     public int wakeUpInactiveFlying = 8;
-    public int wakeUpInactiveFlyingEvery = 10*20;
-    public int wakeUpInactiveFlyingFor = 5*20;
-    public int villagersWorkImmunityAfter = 5*20;
+    public int wakeUpInactiveFlyingEvery = 10 * 20;
+    public int wakeUpInactiveFlyingFor = 5 * 20;
+    public int villagersWorkImmunityAfter = 5 * 20;
     public int villagersWorkImmunityFor = 20;
     public boolean villagersActiveForPanic = true;
     // Paper end
     public boolean tickInactiveVillagers = true;
     public boolean ignoreSpectatorActivation = false;
-    private void activationRange()
-    {
+
+    private void activationRange() {
         boolean hasAnimalsConfig = config.getInt("entity-activation-range.animals", this.animalActivationRange) != this.animalActivationRange; // Paper
-        this.animalActivationRange = this.getInt( "entity-activation-range.animals", this.animalActivationRange );
-        this.monsterActivationRange = this.getInt( "entity-activation-range.monsters", this.monsterActivationRange );
-        this.raiderActivationRange = this.getInt( "entity-activation-range.raiders", this.raiderActivationRange );
-        this.miscActivationRange = this.getInt( "entity-activation-range.misc", this.miscActivationRange );
+        this.animalActivationRange = this.getInt("entity-activation-range.animals", this.animalActivationRange);
+        this.monsterActivationRange = this.getInt("entity-activation-range.monsters", this.monsterActivationRange);
+        this.raiderActivationRange = this.getInt("entity-activation-range.raiders", this.raiderActivationRange);
+        this.miscActivationRange = this.getInt("entity-activation-range.misc", this.miscActivationRange);
         // Paper start
-        this.waterActivationRange = this.getInt( "entity-activation-range.water", this.waterActivationRange );
-        this.villagerActivationRange = this.getInt( "entity-activation-range.villagers", hasAnimalsConfig ? this.animalActivationRange : this.villagerActivationRange );
-        this.flyingMonsterActivationRange = this.getInt( "entity-activation-range.flying-monsters", this.flyingMonsterActivationRange );
+        this.waterActivationRange = this.getInt("entity-activation-range.water", this.waterActivationRange);
+        this.villagerActivationRange = this.getInt("entity-activation-range.villagers", hasAnimalsConfig ? this.animalActivationRange : this.villagerActivationRange);
+        this.flyingMonsterActivationRange = this.getInt("entity-activation-range.flying-monsters", this.flyingMonsterActivationRange);
 
         this.wakeUpInactiveAnimals = this.getInt("entity-activation-range.wake-up-inactive.animals-max-per-tick", this.wakeUpInactiveAnimals);
         this.wakeUpInactiveAnimalsEvery = this.getInt("entity-activation-range.wake-up-inactive.animals-every", this.wakeUpInactiveAnimalsEvery);
@@ -261,13 +238,13 @@ public class SpigotWorldConfig
         this.wakeUpInactiveFlyingEvery = this.getInt("entity-activation-range.wake-up-inactive.flying-monsters-every", this.wakeUpInactiveFlyingEvery);
         this.wakeUpInactiveFlyingFor = this.getInt("entity-activation-range.wake-up-inactive.flying-monsters-for", this.wakeUpInactiveFlyingFor);
 
-        this.villagersWorkImmunityAfter = this.getInt( "entity-activation-range.villagers-work-immunity-after", this.villagersWorkImmunityAfter );
-        this.villagersWorkImmunityFor = this.getInt( "entity-activation-range.villagers-work-immunity-for", this.villagersWorkImmunityFor );
-        this.villagersActiveForPanic = this.getBoolean( "entity-activation-range.villagers-active-for-panic", this.villagersActiveForPanic );
+        this.villagersWorkImmunityAfter = this.getInt("entity-activation-range.villagers-work-immunity-after", this.villagersWorkImmunityAfter);
+        this.villagersWorkImmunityFor = this.getInt("entity-activation-range.villagers-work-immunity-for", this.villagersWorkImmunityFor);
+        this.villagersActiveForPanic = this.getBoolean("entity-activation-range.villagers-active-for-panic", this.villagersActiveForPanic);
         // Paper end
-        this.tickInactiveVillagers = this.getBoolean( "entity-activation-range.tick-inactive-villagers", this.tickInactiveVillagers );
-        this.ignoreSpectatorActivation = this.getBoolean( "entity-activation-range.ignore-spectators", this.ignoreSpectatorActivation );
-        this.log( "Entity Activation Range: An " + this.animalActivationRange + " / Mo " + this.monsterActivationRange + " / Ra " + this.raiderActivationRange + " / Mi " + this.miscActivationRange + " / Tiv " + this.tickInactiveVillagers + " / Isa " + this.ignoreSpectatorActivation );
+        this.tickInactiveVillagers = this.getBoolean("entity-activation-range.tick-inactive-villagers", this.tickInactiveVillagers);
+        this.ignoreSpectatorActivation = this.getBoolean("entity-activation-range.ignore-spectators", this.ignoreSpectatorActivation);
+        this.log("Entity Activation Range: An " + this.animalActivationRange + " / Mo " + this.monsterActivationRange + " / Ra " + this.raiderActivationRange + " / Mi " + this.miscActivationRange + " / Tiv " + this.tickInactiveVillagers + " / Isa " + this.ignoreSpectatorActivation);
     }
 
     public int playerTrackingRange = 128;
@@ -276,81 +253,71 @@ public class SpigotWorldConfig
     public int miscTrackingRange = 96;
     public int displayTrackingRange = 128;
     public int otherTrackingRange = 64;
-    private void trackingRange()
-    {
-        this.playerTrackingRange = this.getInt( "entity-tracking-range.players", this.playerTrackingRange );
-        this.animalTrackingRange = this.getInt( "entity-tracking-range.animals", this.animalTrackingRange );
-        this.monsterTrackingRange = this.getInt( "entity-tracking-range.monsters", this.monsterTrackingRange );
-        this.miscTrackingRange = this.getInt( "entity-tracking-range.misc", this.miscTrackingRange );
-        this.displayTrackingRange = this.getInt( "entity-tracking-range.display", this.displayTrackingRange );
-        this.otherTrackingRange = this.getInt( "entity-tracking-range.other", this.otherTrackingRange );
-        this.log( "Entity Tracking Range: Pl " + this.playerTrackingRange + " / An " + this.animalTrackingRange + " / Mo " + this.monsterTrackingRange + " / Mi " + this.miscTrackingRange + " / Di " + this.displayTrackingRange + " / Other " + this.otherTrackingRange );
+    private void trackingRange() {
+        this.playerTrackingRange = this.getInt("entity-tracking-range.players", this.playerTrackingRange);
+        this.animalTrackingRange = this.getInt("entity-tracking-range.animals", this.animalTrackingRange);
+        this.monsterTrackingRange = this.getInt("entity-tracking-range.monsters", this.monsterTrackingRange);
+        this.miscTrackingRange = this.getInt("entity-tracking-range.misc", this.miscTrackingRange);
+        this.displayTrackingRange = this.getInt("entity-tracking-range.display", this.displayTrackingRange);
+        this.otherTrackingRange = this.getInt("entity-tracking-range.other", this.otherTrackingRange);
+        this.log("Entity Tracking Range: Pl " + this.playerTrackingRange + " / An " + this.animalTrackingRange + " / Mo " + this.monsterTrackingRange + " / Mi " + this.miscTrackingRange + " / Di " + this.displayTrackingRange + " / Other " + this.otherTrackingRange);
     }
 
     public int hopperTransfer;
     public int hopperCheck;
     public int hopperAmount;
     public boolean hopperCanLoadChunks;
-    private void hoppers()
-    {
+    private void hoppers() {
         // Set the tick delay between hopper item movements
-        this.hopperTransfer = this.getInt( "ticks-per.hopper-transfer", 8 );
-        if ( SpigotConfig.version < 11 )
-        {
-            this.set( "ticks-per.hopper-check", 1 );
+        this.hopperTransfer = this.getInt("ticks-per.hopper-transfer", 8);
+        if (SpigotConfig.version < 11) {
+            this.set("ticks-per.hopper-check", 1);
         }
-        this.hopperCheck = this.getInt( "ticks-per.hopper-check", 1 );
-        this.hopperAmount = this.getInt( "hopper-amount", 1 );
-        this.hopperCanLoadChunks = this.getBoolean( "hopper-can-load-chunks", false );
-        this.log( "Hopper Transfer: " + this.hopperTransfer + " Hopper Check: " + this.hopperCheck + " Hopper Amount: " + this.hopperAmount + " Hopper Can Load Chunks: " + this.hopperCanLoadChunks );
+        this.hopperCheck = this.getInt("ticks-per.hopper-check", 1);
+        this.hopperAmount = this.getInt("hopper-amount", 1);
+        this.hopperCanLoadChunks = this.getBoolean("hopper-can-load-chunks", false);
+        this.log("Hopper Transfer: " + this.hopperTransfer + " Hopper Check: " + this.hopperCheck + " Hopper Amount: " + this.hopperAmount + " Hopper Can Load Chunks: " + this.hopperCanLoadChunks);
     }
 
     public int arrowDespawnRate;
     public int tridentDespawnRate;
-    private void arrowDespawnRate()
-    {
-        this.arrowDespawnRate = this.getInt( "arrow-despawn-rate", 1200 );
-        this.tridentDespawnRate = this.getInt( "trident-despawn-rate", this.arrowDespawnRate );
-        this.log( "Arrow Despawn Rate: " + this.arrowDespawnRate + " Trident Respawn Rate:" + this.tridentDespawnRate );
+    private void arrowDespawnRate() {
+        this.arrowDespawnRate = this.getInt("arrow-despawn-rate", 1200);
+        this.tridentDespawnRate = this.getInt("trident-despawn-rate", this.arrowDespawnRate);
+        this.log("Arrow Despawn Rate: " + this.arrowDespawnRate + " Trident Respawn Rate:" + this.tridentDespawnRate);
     }
 
     public boolean zombieAggressiveTowardsVillager;
-    private void zombieAggressiveTowardsVillager()
-    {
-        this.zombieAggressiveTowardsVillager = this.getBoolean( "zombie-aggressive-towards-villager", true );
-        this.log( "Zombie Aggressive Towards Villager: " + this.zombieAggressiveTowardsVillager );
+    private void zombieAggressiveTowardsVillager() {
+        this.zombieAggressiveTowardsVillager = this.getBoolean("zombie-aggressive-towards-villager", true);
+        this.log("Zombie Aggressive Towards Villager: " + this.zombieAggressiveTowardsVillager);
     }
 
     public boolean nerfSpawnerMobs;
-    private void nerfSpawnerMobs()
-    {
-        this.nerfSpawnerMobs = this.getBoolean( "nerf-spawner-mobs", false );
-        this.log( "Nerfing mobs spawned from spawners: " + this.nerfSpawnerMobs );
+    private void nerfSpawnerMobs() {
+        this.nerfSpawnerMobs = this.getBoolean("nerf-spawner-mobs", false);
+        this.log("Nerfing mobs spawned from spawners: " + this.nerfSpawnerMobs);
     }
 
     public boolean enableZombiePigmenPortalSpawns;
-    private void enableZombiePigmenPortalSpawns()
-    {
-        this.enableZombiePigmenPortalSpawns = this.getBoolean( "enable-zombie-pigmen-portal-spawns", true );
-        this.log( "Allow Zombie Pigmen to spawn from portal blocks: " + this.enableZombiePigmenPortalSpawns );
+    private void enableZombiePigmenPortalSpawns() {
+        this.enableZombiePigmenPortalSpawns = this.getBoolean("enable-zombie-pigmen-portal-spawns", true);
+        this.log("Allow Zombie Pigmen to spawn from portal blocks: " + this.enableZombiePigmenPortalSpawns);
     }
 
     public int dragonDeathSoundRadius;
-    private void keepDragonDeathPerWorld()
-    {
-        this.dragonDeathSoundRadius = this.getInt( "dragon-death-sound-radius", 0 );
+    private void keepDragonDeathPerWorld() {
+        this.dragonDeathSoundRadius = this.getInt("dragon-death-sound-radius", 0);
     }
 
     public int witherSpawnSoundRadius;
-    private void witherSpawnSoundRadius()
-    {
-        this.witherSpawnSoundRadius = this.getInt( "wither-spawn-sound-radius", 0 );
+    private void witherSpawnSoundRadius() {
+        this.witherSpawnSoundRadius = this.getInt("wither-spawn-sound-radius", 0);
     }
 
     public int endPortalSoundRadius;
-    private void endPortalSoundRadius()
-    {
-        this.endPortalSoundRadius = this.getInt( "end-portal-sound-radius", 0 );
+    private void endPortalSoundRadius() {
+        this.endPortalSoundRadius = this.getInt("end-portal-sound-radius", 0);
     }
 
     public int villageSeed;
@@ -375,28 +342,29 @@ public class SpigotWorldConfig
     public int buriedTreasureSeed;
     public Integer mineshaftSeed;
     public Long strongholdSeed;
+
     private <N extends Number> N getSeed(String path, java.util.function.Function<String, N> toNumberFunc) {
         final String value = this.getString(path, "default");
         return org.apache.commons.lang3.math.NumberUtils.isParsable(value) ? toNumberFunc.apply(value) : null;
     }
+
     // Paper end
-    private void initWorldGenSeeds()
-    {
-        this.villageSeed = this.getInt( "seed-village", 10387312 );
-        this.desertSeed = this.getInt( "seed-desert", 14357617 );
-        this.iglooSeed = this.getInt( "seed-igloo", 14357618 );
-        this.jungleSeed = this.getInt( "seed-jungle", 14357619 );
-        this.swampSeed = this.getInt( "seed-swamp", 14357620 );
-        this.monumentSeed = this.getInt( "seed-monument", 10387313 );
-        this.shipwreckSeed = this.getInt( "seed-shipwreck", 165745295 );
-        this.oceanSeed = this.getInt( "seed-ocean", 14357621 );
-        this.outpostSeed = this.getInt( "seed-outpost", 165745296 );
-        this.endCitySeed = this.getInt( "seed-endcity", 10387313 );
-        this.slimeSeed = this.getInt( "seed-slime", 987234911 );
-        this.netherSeed = this.getInt( "seed-nether", 30084232 );
-        this.mansionSeed = this.getInt( "seed-mansion", 10387319 );
-        this.fossilSeed = this.getInt( "seed-fossil", 14357921 );
-        this.portalSeed = this.getInt( "seed-portal", 34222645 );
+    private void initWorldGenSeeds() {
+        this.villageSeed = this.getInt("seed-village", 10387312);
+        this.desertSeed = this.getInt("seed-desert", 14357617);
+        this.iglooSeed = this.getInt("seed-igloo", 14357618);
+        this.jungleSeed = this.getInt("seed-jungle", 14357619);
+        this.swampSeed = this.getInt("seed-swamp", 14357620);
+        this.monumentSeed = this.getInt("seed-monument", 10387313);
+        this.shipwreckSeed = this.getInt("seed-shipwreck", 165745295);
+        this.oceanSeed = this.getInt("seed-ocean", 14357621);
+        this.outpostSeed = this.getInt("seed-outpost", 165745296);
+        this.endCitySeed = this.getInt("seed-endcity", 10387313);
+        this.slimeSeed = this.getInt("seed-slime", 987234911);
+        this.netherSeed = this.getInt("seed-nether", 30084232);
+        this.mansionSeed = this.getInt("seed-mansion", 10387319);
+        this.fossilSeed = this.getInt("seed-fossil", 14357921);
+        this.portalSeed = this.getInt("seed-portal", 34222645);
         // Paper start - add missing structure set configs
         this.ancientCitySeed = this.getInt("seed-ancientcity", 20083232);
         this.trailRuinsSeed = this.getInt("seed-trailruins", 83469867);
@@ -405,8 +373,8 @@ public class SpigotWorldConfig
         this.mineshaftSeed = this.getSeed("seed-mineshaft", Integer::parseInt);
         this.strongholdSeed = this.getSeed("seed-stronghold", Long::parseLong);
         // Paper end
-        this.log( "Custom Map Seeds:  Village: " + this.villageSeed + " Desert: " + this.desertSeed + " Igloo: " + this.iglooSeed + " Jungle: " + this.jungleSeed + " Swamp: " + this.swampSeed + " Monument: " + this.monumentSeed
-                + " Ocean: " + this.oceanSeed + " Shipwreck: " + this.shipwreckSeed + " End City: " + this.endCitySeed + " Slime: " + this.slimeSeed + " Nether: " + this.netherSeed + " Mansion: " + this.mansionSeed + " Fossil: " + this.fossilSeed + " Portal: " + this.portalSeed );
+        this.log("Custom Map Seeds:  Village: " + this.villageSeed + " Desert: " + this.desertSeed + " Igloo: " + this.iglooSeed + " Jungle: " + this.jungleSeed + " Swamp: " + this.swampSeed + " Monument: " + this.monumentSeed
+            + " Ocean: " + this.oceanSeed + " Shipwreck: " + this.shipwreckSeed + " End City: " + this.endCitySeed + " Slime: " + this.slimeSeed + " Nether: " + this.netherSeed + " Mansion: " + this.mansionSeed + " Fossil: " + this.fossilSeed + " Portal: " + this.portalSeed);
     }
 
     public float jumpWalkExhaustion;
@@ -416,54 +384,48 @@ public class SpigotWorldConfig
     public float swimMultiplier;
     public float sprintMultiplier;
     public float otherMultiplier;
-    private void initHunger()
-    {
-        if ( SpigotConfig.version < 10 )
-        {
-            this.set( "hunger.walk-exhaustion", null );
-            this.set( "hunger.sprint-exhaustion", null );
-            this.set( "hunger.combat-exhaustion", 0.1 );
-            this.set( "hunger.regen-exhaustion", 6.0 );
+    private void initHunger() {
+        if (SpigotConfig.version < 10) {
+            this.set("hunger.walk-exhaustion", null);
+            this.set("hunger.sprint-exhaustion", null);
+            this.set("hunger.combat-exhaustion", 0.1);
+            this.set("hunger.regen-exhaustion", 6.0);
         }
 
-        this.jumpWalkExhaustion = (float) this.getDouble( "hunger.jump-walk-exhaustion", 0.05 );
-        this.jumpSprintExhaustion = (float) this.getDouble( "hunger.jump-sprint-exhaustion", 0.2 );
-        this.combatExhaustion = (float) this.getDouble( "hunger.combat-exhaustion", 0.1 );
-        this.regenExhaustion = (float) this.getDouble( "hunger.regen-exhaustion", 6.0 );
-        this.swimMultiplier = (float) this.getDouble( "hunger.swim-multiplier", 0.01 );
-        this.sprintMultiplier = (float) this.getDouble( "hunger.sprint-multiplier", 0.1 );
-        this.otherMultiplier = (float) this.getDouble( "hunger.other-multiplier", 0.0 );
+        this.jumpWalkExhaustion = (float) this.getDouble("hunger.jump-walk-exhaustion", 0.05);
+        this.jumpSprintExhaustion = (float) this.getDouble("hunger.jump-sprint-exhaustion", 0.2);
+        this.combatExhaustion = (float) this.getDouble("hunger.combat-exhaustion", 0.1);
+        this.regenExhaustion = (float) this.getDouble("hunger.regen-exhaustion", 6.0);
+        this.swimMultiplier = (float) this.getDouble("hunger.swim-multiplier", 0.01);
+        this.sprintMultiplier = (float) this.getDouble("hunger.sprint-multiplier", 0.1);
+        this.otherMultiplier = (float) this.getDouble("hunger.other-multiplier", 0.0);
     }
 
     public int currentPrimedTnt = 0;
     public int maxTntTicksPerTick;
     private void maxTntPerTick() {
-        if ( SpigotConfig.version < 7 )
-        {
-            this.set( "max-tnt-per-tick", 100 );
+        if (SpigotConfig.version < 7) {
+            this.set("max-tnt-per-tick", 100);
         }
-        this.maxTntTicksPerTick = this.getInt( "max-tnt-per-tick", 100 );
-        this.log( "Max TNT Explosions: " + this.maxTntTicksPerTick );
+        this.maxTntTicksPerTick = this.getInt("max-tnt-per-tick", 100);
+        this.log("Max TNT Explosions: " + this.maxTntTicksPerTick);
     }
 
     public int hangingTickFrequency;
-    private void hangingTickFrequency()
-    {
-        this.hangingTickFrequency = this.getInt( "hanging-tick-frequency", 100 );
+    private void hangingTickFrequency() {
+        this.hangingTickFrequency = this.getInt("hanging-tick-frequency", 100);
     }
 
     public int tileMaxTickTime;
     public int entityMaxTickTime;
-    private void maxTickTimes()
-    {
+    private void maxTickTimes() {
         this.tileMaxTickTime = this.getInt("max-tick-time.tile", 50);
         this.entityMaxTickTime = this.getInt("max-tick-time.entity", 50);
         this.log("Tile Max Tick Time: " + this.tileMaxTickTime + "ms Entity max Tick Time: " + this.entityMaxTickTime + "ms");
     }
 
     public int thunderChance;
-    private void thunderChance()
-    {
+    private void thunderChance() {
         this.thunderChance = this.getInt("thunder-chance", 100000);
     }
 
diff --git a/src/main/java/org/spigotmc/TickLimiter.java b/src/main/java/org/spigotmc/TickLimiter.java
index 4074538ea6090bf99d8ab04b1e98c2832a0e9a98..961489499e220d71339771dcabf151edeaf6d231 100644
--- a/src/main/java/org/spigotmc/TickLimiter.java
+++ b/src/main/java/org/spigotmc/TickLimiter.java
@@ -5,8 +5,8 @@ public class TickLimiter {
     private final int maxTime;
     private long startTime;
 
-    public TickLimiter(int maxtime) {
-        this.maxTime = maxtime;
+    public TickLimiter(int maxTime) {
+        this.maxTime = maxTime;
     }
 
     public void initTick() {
diff --git a/src/main/java/org/spigotmc/TicksPerSecondCommand.java b/src/main/java/org/spigotmc/TicksPerSecondCommand.java
index 9eb2823cc8f83bad2626fc77578b0162d9ed5782..6d4851aa8c53793bfaf650f399fc5e2a98dbbb24 100644
--- a/src/main/java/org/spigotmc/TicksPerSecondCommand.java
+++ b/src/main/java/org/spigotmc/TicksPerSecondCommand.java
@@ -1,51 +1,55 @@
 package org.spigotmc;
 
-import net.minecraft.server.MinecraftServer;
-import org.bukkit.ChatColor;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.JoinConfiguration;
+import net.kyori.adventure.text.TextComponent;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.format.TextColor;
 import org.bukkit.command.Command;
 import org.bukkit.command.CommandSender;
 
-public class TicksPerSecondCommand extends Command
-{
+import static net.kyori.adventure.text.Component.text;
 
-    public TicksPerSecondCommand(String name)
-    {
-        super( name );
+public class TicksPerSecondCommand extends Command {
+
+    private boolean hasShownMemoryWarning; // Paper
+
+    public TicksPerSecondCommand(String name) {
+        super(name);
         this.description = "Gets the current ticks per second for the server";
         this.usageMessage = "/tps";
-        this.setPermission( "bukkit.command.tps" );
+        this.setPermission("bukkit.command.tps");
     }
+
     // Paper start
-    private static final net.kyori.adventure.text.Component WARN_MSG = net.kyori.adventure.text.Component.text()
-        .append(net.kyori.adventure.text.Component.text("Warning: ", net.kyori.adventure.text.format.NamedTextColor.RED))
-        .append(net.kyori.adventure.text.Component.text("Memory usage on modern garbage collectors is not a stable value and it is perfectly normal to see it reach max. Please do not pay it much attention.", net.kyori.adventure.text.format.NamedTextColor.GOLD))
+    private static final Component WARN_MSG = text()
+        .append(text("Warning: ", NamedTextColor.RED))
+        .append(text("Memory usage on modern garbage collectors is not a stable value and it is perfectly normal to see it reach max. Please do not pay it much attention.", NamedTextColor.GOLD))
         .build();
     // Paper end
 
     @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args)
-    {
-        if ( !this.testPermission( sender ) )
-        {
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!this.testPermission(sender)) {
             return true;
         }
 
         // Paper start - Further improve tick handling
         double[] tps = org.bukkit.Bukkit.getTPS();
-        net.kyori.adventure.text.Component[] tpsAvg = new net.kyori.adventure.text.Component[tps.length];
+        Component[] tpsAvg = new Component[tps.length];
 
-        for ( int i = 0; i < tps.length; i++) {
-            tpsAvg[i] = TicksPerSecondCommand.format( tps[i] );
+        for (int i = 0; i < tps.length; i++) {
+            tpsAvg[i] = TicksPerSecondCommand.format(tps[i]);
         }
 
-        net.kyori.adventure.text.TextComponent.Builder builder = net.kyori.adventure.text.Component.text();
-        builder.append(net.kyori.adventure.text.Component.text("TPS from last 1m, 5m, 15m: ", net.kyori.adventure.text.format.NamedTextColor.GOLD));
-        builder.append(net.kyori.adventure.text.Component.join(net.kyori.adventure.text.JoinConfiguration.commas(true), tpsAvg));
+        TextComponent.Builder builder = text();
+        builder.append(text("TPS from last 1m, 5m, 15m: ", NamedTextColor.GOLD));
+        builder.append(Component.join(JoinConfiguration.commas(true), tpsAvg));
         sender.sendMessage(builder.asComponent());
         if (args.length > 0 && args[0].equals("mem") && sender.hasPermission("bukkit.command.tpsmemory")) {
-            sender.sendMessage(net.kyori.adventure.text.Component.text()
-                .append(net.kyori.adventure.text.Component.text("Current Memory Usage: ", net.kyori.adventure.text.format.NamedTextColor.GOLD))
-                .append(net.kyori.adventure.text.Component.text(((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / (1024 * 1024)) + "/" + (Runtime.getRuntime().totalMemory() / (1024 * 1024)) + " mb (Max: " + (Runtime.getRuntime().maxMemory() / (1024 * 1024)) + " mb)", net.kyori.adventure.text.format.NamedTextColor.GREEN))
+            sender.sendMessage(text()
+                .append(text("Current Memory Usage: ", NamedTextColor.GOLD))
+                .append(text(((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / (1024 * 1024)) + "/" + (Runtime.getRuntime().totalMemory() / (1024 * 1024)) + " mb (Max: " + (Runtime.getRuntime().maxMemory() / (1024 * 1024)) + " mb)", NamedTextColor.GREEN))
             );
             if (!this.hasShownMemoryWarning) {
                 sender.sendMessage(WARN_MSG);
@@ -57,13 +61,11 @@ public class TicksPerSecondCommand extends Command
         return true;
     }
 
-    private boolean hasShownMemoryWarning; // Paper
-    private static net.kyori.adventure.text.Component format(double tps) // Paper - Made static
-    {
-        // Paper
-        net.kyori.adventure.text.format.TextColor color = ( ( tps > 18.0 ) ? net.kyori.adventure.text.format.NamedTextColor.GREEN : ( tps > 16.0 ) ? net.kyori.adventure.text.format.NamedTextColor.YELLOW : net.kyori.adventure.text.format.NamedTextColor.RED );
-        String amount = Math.min(Math.round(tps * 100.0) / 100.0, 20.0) + (tps > 21.0  ? "*" : ""); // Paper - only print * at 21, we commonly peak to 20.02 as the tick sleep is not accurate enough, stop the noise
-        return net.kyori.adventure.text.Component.text(amount, color);
+    private static Component format(double tps) { // Paper - Made static
+        // Paper start
+        TextColor color = ((tps > 18.0) ? NamedTextColor.GREEN : (tps > 16.0) ? NamedTextColor.YELLOW : NamedTextColor.RED);
+        String amount = Math.min(Math.round(tps * 100.0) / 100.0, 20.0) + (tps > 21.0 ? "*" : ""); // Paper - only print * at 21, we commonly peak to 20.02 as the tick sleep is not accurate enough, stop the noise
+        return text(amount, color);
         // Paper end
     }
 }
diff --git a/src/main/java/org/spigotmc/TrackingRange.java b/src/main/java/org/spigotmc/TrackingRange.java
index bb06f89a29f30144e7e2113e088a503db006a83c..05db2aab74fbf34d77761184d40eb66b879f20ec 100644
--- a/src/main/java/org/spigotmc/TrackingRange.java
+++ b/src/main/java/org/spigotmc/TrackingRange.java
@@ -1,5 +1,6 @@
 package org.spigotmc;
 
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.entity.Display;
 import net.minecraft.world.entity.Entity;
@@ -8,29 +9,27 @@ import net.minecraft.world.entity.decoration.ItemFrame;
 import net.minecraft.world.entity.decoration.Painting;
 import net.minecraft.world.entity.item.ItemEntity;
 
-public class TrackingRange
-{
+public final class TrackingRange {
+
+    private TrackingRange() {
+    }
 
     /**
      * Gets the range an entity should be 'tracked' by players and visible in
      * the client.
      *
-     * @param entity
      * @param defaultRange Default range defined by Mojang
-     * @return
      */
-    public static int getEntityTrackingRange(Entity entity, int defaultRange)
-    {
-        if ( defaultRange == 0 )
-        {
+    public static int getEntityTrackingRange(final Entity entity, final int defaultRange) {
+        if (defaultRange == 0) {
             return defaultRange;
         }
-        SpigotWorldConfig config = entity.level().spigotConfig;
-        if ( entity instanceof ServerPlayer )
-        {
+
+        final SpigotWorldConfig config = entity.level().spigotConfig;
+        if (entity instanceof ServerPlayer) {
             return config.playerTrackingRange;
-        // Paper start - Simplify and set water mobs to animal tracking range
         }
+
         switch (entity.activationType) {
             case RAIDER:
             case MONSTER:
@@ -42,16 +41,16 @@ public class TrackingRange
                 return config.animalTrackingRange;
             case MISC:
         }
-        if ( entity instanceof ItemFrame || entity instanceof Painting || entity instanceof ItemEntity || entity instanceof ExperienceOrb )
-        // Paper end
-        {
+
+        if (entity instanceof ItemFrame || entity instanceof Painting || entity instanceof ItemEntity || entity instanceof ExperienceOrb) {
             return config.miscTrackingRange;
-        } else if ( entity instanceof Display )
-        {
+        } else if (entity instanceof Display) {
             return config.displayTrackingRange;
-        } else
-        {
-            if (entity instanceof net.minecraft.world.entity.boss.enderdragon.EnderDragon) return ((net.minecraft.server.level.ServerLevel)(entity.getCommandSenderWorld())).getChunkSource().chunkMap.serverViewDistance; // Paper - enderdragon is exempt
+        } else {
+            if (entity instanceof net.minecraft.world.entity.boss.enderdragon.EnderDragon) {
+                // Exempt ender dragon
+                return ((ServerLevel) entity.level()).getChunkSource().chunkMap.serverViewDistance;
+            }
             return config.otherTrackingRange;
         }
     }
diff --git a/src/main/java/org/spigotmc/WatchdogThread.java b/src/main/java/org/spigotmc/WatchdogThread.java
index f7a4fee9bb25ff256dc2e5ea26bfbceca6a49167..a9339f59f81dff307317ae4afdff0dc296febcc9 100644
--- a/src/main/java/org/spigotmc/WatchdogThread.java
+++ b/src/main/java/org/spigotmc/WatchdogThread.java
@@ -1,5 +1,7 @@
 package org.spigotmc;
 
+import io.papermc.paper.FeatureHooks;
+import io.papermc.paper.configuration.GlobalConfiguration;
 import java.lang.management.ManagementFactory;
 import java.lang.management.MonitorInfo;
 import java.lang.management.ThreadInfo;
@@ -7,9 +9,9 @@ import java.util.logging.Level;
 import java.util.logging.Logger;
 import net.minecraft.server.MinecraftServer;
 import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftServer;
 
-public class WatchdogThread extends ca.spottedleaf.moonrise.common.util.TickThread // Paper - rewrite chunk system
-{
+public class WatchdogThread extends Thread {
 
     public static final boolean DISABLE_WATCHDOG = Boolean.getBoolean("disable.watchdog"); // Paper - Improved watchdog support
     private static WatchdogThread instance;
@@ -22,251 +24,159 @@ public class WatchdogThread extends ca.spottedleaf.moonrise.common.util.TickThre
     private volatile long lastTick;
     private volatile boolean stopping;
 
-    // Paper start - log detailed tick information
-    private void dumpEntity(net.minecraft.world.entity.Entity entity) {
-        Logger log = Bukkit.getServer().getLogger();
-        double posX, posY, posZ;
-        net.minecraft.world.phys.Vec3 mot;
-        double moveStartX, moveStartY, moveStartZ;
-        net.minecraft.world.phys.Vec3 moveVec;
-        synchronized (entity.posLock) {
-            posX = entity.getX();
-            posY = entity.getY();
-            posZ = entity.getZ();
-            mot = entity.getDeltaMovement();
-            moveStartX = entity.getMoveStartX();
-            moveStartY = entity.getMoveStartY();
-            moveStartZ = entity.getMoveStartZ();
-            moveVec = entity.getMoveVector();
-        }
-
-        String entityType = net.minecraft.world.entity.EntityType.getKey(entity.getType()).toString();
-        java.util.UUID entityUUID = entity.getUUID();
-        net.minecraft.world.level.Level world = entity.level();
-
-        log.log(Level.SEVERE, "Ticking entity: " + entityType + ", entity class: " + entity.getClass().getName());
-        log.log(Level.SEVERE, "Entity status: removed: " + entity.isRemoved() + ", valid: " + entity.valid + ", alive: " + entity.isAlive() + ", is passenger: " + entity.isPassenger());
-        log.log(Level.SEVERE, "Entity UUID: " + entityUUID);
-        log.log(Level.SEVERE, "Position: world: '" + (world == null ? "unknown world?" : world.getWorld().getName()) + "' at location (" + posX + ", " + posY + ", " + posZ + ")");
-        log.log(Level.SEVERE, "Velocity: " + (mot == null ? "unknown velocity" : mot.toString()) + " (in blocks per tick)");
-        log.log(Level.SEVERE, "Entity AABB: " + entity.getBoundingBox());
-        if (moveVec != null) {
-            log.log(Level.SEVERE, "Move call information: ");
-            log.log(Level.SEVERE, "Start position: (" + moveStartX + ", " + moveStartY + ", " + moveStartZ + ")");
-            log.log(Level.SEVERE, "Move vector: " + moveVec.toString());
-        }
-    }
-
-    private void dumpTickingInfo() {
-        Logger log = Bukkit.getServer().getLogger();
-
-        // ticking entities
-        for (net.minecraft.world.entity.Entity entity : net.minecraft.server.level.ServerLevel.getCurrentlyTickingEntities()) {
-            this.dumpEntity(entity);
-            net.minecraft.world.entity.Entity vehicle = entity.getVehicle();
-            if (vehicle != null) {
-                log.log(Level.SEVERE, "Detailing vehicle for above entity:");
-                this.dumpEntity(vehicle);
-            }
-        }
-
-        // packet processors
-        for (net.minecraft.network.PacketListener packetListener : net.minecraft.network.protocol.PacketUtils.getCurrentPacketProcessors()) {
-            if (packetListener instanceof net.minecraft.server.network.ServerGamePacketListenerImpl) {
-                net.minecraft.server.level.ServerPlayer player = ((net.minecraft.server.network.ServerGamePacketListenerImpl)packetListener).player;
-                long totalPackets = net.minecraft.network.protocol.PacketUtils.getTotalProcessedPackets();
-                if (player == null) {
-                    log.log(Level.SEVERE, "Handling packet for player connection or ticking player connection (null player): " + packetListener);
-                    log.log(Level.SEVERE, "Total packets processed on the main thread for all players: " + totalPackets);
-                } else {
-                    this.dumpEntity(player);
-                    net.minecraft.world.entity.Entity vehicle = player.getVehicle();
-                    if (vehicle != null) {
-                        log.log(Level.SEVERE, "Detailing vehicle for above entity:");
-                        this.dumpEntity(vehicle);
-                    }
-                    log.log(Level.SEVERE, "Total packets processed on the main thread for all players: " + totalPackets);
-                }
-            } else {
-                log.log(Level.SEVERE, "Handling packet for connection: " + packetListener);
-            }
-        }
-    }
-    // Paper end - log detailed tick information
-
-    private WatchdogThread(long timeoutTime, boolean restart)
-    {
-        super( "Paper Watchdog Thread" );
+    private WatchdogThread(long timeoutTime, boolean restart) {
+        super("Paper Watchdog Thread");
         this.timeoutTime = timeoutTime;
         this.restart = restart;
-        earlyWarningEvery = Math.min(io.papermc.paper.configuration.GlobalConfiguration.get().watchdog.earlyWarningEvery, timeoutTime); // Paper
-        earlyWarningDelay = Math.min(io.papermc.paper.configuration.GlobalConfiguration.get().watchdog.earlyWarningDelay, timeoutTime); // Paper
+        this.earlyWarningEvery = Math.min(GlobalConfiguration.get().watchdog.earlyWarningEvery, timeoutTime); // Paper
+        this.earlyWarningDelay = Math.min(GlobalConfiguration.get().watchdog.earlyWarningDelay, timeoutTime); // Paper
     }
 
-    private static long monotonicMillis()
-    {
+    private static long monotonicMillis() {
         return System.nanoTime() / 1000000L;
     }
 
-    public static void doStart(int timeoutTime, boolean restart)
-    {
-        if ( WatchdogThread.instance == null )
-        {
+    public static void doStart(int timeoutTime, boolean restart) {
+        if (WatchdogThread.instance == null) {
             if (timeoutTime <= 0) timeoutTime = 300; // Paper
-            WatchdogThread.instance = new WatchdogThread( timeoutTime * 1000L, restart );
+            WatchdogThread.instance = new WatchdogThread(timeoutTime * 1000L, restart);
             WatchdogThread.instance.start();
-        } else
-        {
+        } else {
             WatchdogThread.instance.timeoutTime = timeoutTime * 1000L;
             WatchdogThread.instance.restart = restart;
         }
     }
 
-    public static void tick()
-    {
+    public static void tick() {
         WatchdogThread.instance.lastTick = WatchdogThread.monotonicMillis();
     }
 
-    public static void doStop()
-    {
-        if ( WatchdogThread.instance != null )
-        {
+    public static void doStop() {
+        if (WatchdogThread.instance != null) {
             WatchdogThread.instance.stopping = true;
         }
     }
 
     @Override
-    public void run()
-    {
-        while ( !this.stopping )
-        {
-            //
+    public void run() {
+        while (!this.stopping) {
             // Paper start
-            Logger log = Bukkit.getServer().getLogger();
+            Logger logger = Bukkit.getServer().getLogger();
             long currentTime = WatchdogThread.monotonicMillis();
             MinecraftServer server = MinecraftServer.getServer();
-            if ( this.lastTick != 0 && this.timeoutTime > 0 && WatchdogThread.hasStarted && (!server.isRunning() || (currentTime > this.lastTick + this.earlyWarningEvery && !DISABLE_WATCHDOG) )) // Paper - add property to disable
-            {
-                boolean isLongTimeout = currentTime > lastTick + timeoutTime || (!server.isRunning() && !server.hasStopped() && currentTime > lastTick + 1000);
+            if (this.lastTick != 0 && this.timeoutTime > 0 && WatchdogThread.hasStarted && (!server.isRunning() || (currentTime > this.lastTick + this.earlyWarningEvery && !DISABLE_WATCHDOG))) { // Paper - add property to disable
+                boolean isLongTimeout = currentTime > this.lastTick + this.timeoutTime || (!server.isRunning() && !server.hasStopped() && currentTime > this.lastTick + 1000);
                 // Don't spam early warning dumps
-                if ( !isLongTimeout && (earlyWarningEvery <= 0 || !hasStarted || currentTime < lastEarlyWarning + earlyWarningEvery || currentTime < lastTick + earlyWarningDelay)) continue;
-                if ( !isLongTimeout && server.hasStopped()) continue; // Don't spam early watchdog warnings during shutdown, we'll come back to this...
-                lastEarlyWarning = currentTime;
+                if (!isLongTimeout && (this.earlyWarningEvery <= 0 ||
+                    !hasStarted || currentTime < this.lastEarlyWarning + this.earlyWarningEvery ||
+                    currentTime < this.lastTick + this.earlyWarningDelay))
+                    continue;
+                if (!isLongTimeout && server.hasStopped())
+                    continue; // Don't spam early watchdog warnings during shutdown, we'll come back to this...
+                this.lastEarlyWarning = currentTime;
                 if (isLongTimeout) {
-                // Paper end
-                log.log( Level.SEVERE, "------------------------------" );
-                log.log( Level.SEVERE, "The server has stopped responding! This is (probably) not a Paper bug." ); // Paper
-                log.log( Level.SEVERE, "If you see a plugin in the Server thread dump below, then please report it to that author" );
-                log.log( Level.SEVERE, "\t *Especially* if it looks like HTTP or MySQL operations are occurring" );
-                log.log( Level.SEVERE, "If you see a world save or edit, then it means you did far more than your server can handle at once" );
-                log.log( Level.SEVERE, "\t If this is the case, consider increasing timeout-time in spigot.yml but note that this will replace the crash with LARGE lag spikes" );
-                log.log( Level.SEVERE, "If you are unsure or still think this is a Paper bug, please report this to https://github.com/PaperMC/Paper/issues" );
-                log.log( Level.SEVERE, "Be sure to include ALL relevant console errors and Minecraft crash reports" );
-                log.log( Level.SEVERE, "Paper version: " + Bukkit.getServer().getVersion() );
-                //
-                if ( net.minecraft.world.level.Level.lastPhysicsProblem != null )
-                {
-                    log.log( Level.SEVERE, "------------------------------" );
-                    log.log( Level.SEVERE, "During the run of the server, a physics stackoverflow was supressed" );
-                    log.log( Level.SEVERE, "near " + net.minecraft.world.level.Level.lastPhysicsProblem );
-                }
-                //
-                // Paper start - Warn in watchdog if an excessive velocity was ever set
-                if (org.bukkit.craftbukkit.CraftServer.excessiveVelEx != null) {
-                    log.log(Level.SEVERE, "------------------------------");
-                    log.log(Level.SEVERE, "During the run of the server, a plugin set an excessive velocity on an entity");
-                    log.log(Level.SEVERE, "This may be the cause of the issue, or it may be entirely unrelated");
-                    log.log(Level.SEVERE, org.bukkit.craftbukkit.CraftServer.excessiveVelEx.getMessage());
-                    for (StackTraceElement stack : org.bukkit.craftbukkit.CraftServer.excessiveVelEx.getStackTrace()) {
-                        log.log( Level.SEVERE, "\t\t" + stack );
+                    // Paper end
+                    logger.log(Level.SEVERE, "------------------------------");
+                    logger.log(Level.SEVERE, "The server has stopped responding! This is (probably) not a Paper bug."); // Paper
+                    logger.log(Level.SEVERE, "If you see a plugin in the Server thread dump below, then please report it to that author");
+                    logger.log(Level.SEVERE, "\t *Especially* if it looks like HTTP or MySQL operations are occurring");
+                    logger.log(Level.SEVERE, "If you see a world save or edit, then it means you did far more than your server can handle at once");
+                    logger.log(Level.SEVERE, "\t If this is the case, consider increasing timeout-time in spigot.yml but note that this will replace the crash with LARGE lag spikes");
+                    logger.log(Level.SEVERE, "If you are unsure or still think this is a Paper bug, please report this to https://github.com/PaperMC/Paper/issues");
+                    logger.log(Level.SEVERE, "Be sure to include ALL relevant console errors and Minecraft crash reports");
+                    logger.log(Level.SEVERE, "Paper version: " + Bukkit.getServer().getVersion());
+
+                    if (net.minecraft.world.level.Level.lastPhysicsProblem != null) {
+                        logger.log(Level.SEVERE, "------------------------------");
+                        logger.log(Level.SEVERE, "During the run of the server, a physics stackoverflow was supressed");
+                        logger.log(Level.SEVERE, "near " + net.minecraft.world.level.Level.lastPhysicsProblem);
                     }
-                }
-                // Paper end
-                } else
-                {
-                    log.log(Level.SEVERE, "--- DO NOT REPORT THIS TO PAPER - THIS IS NOT A BUG OR A CRASH  - " + Bukkit.getServer().getVersion() + " ---");
-                    log.log(Level.SEVERE, "The server has not responded for " + (currentTime - lastTick) / 1000 + " seconds! Creating thread dump");
+
+                    // Paper start - Warn in watchdog if an excessive velocity was ever set
+                    if (CraftServer.excessiveVelEx != null) {
+                        logger.log(Level.SEVERE, "------------------------------");
+                        logger.log(Level.SEVERE, "During the run of the server, a plugin set an excessive velocity on an entity");
+                        logger.log(Level.SEVERE, "This may be the cause of the issue, or it may be entirely unrelated");
+                        logger.log(Level.SEVERE, CraftServer.excessiveVelEx.getMessage());
+                        for (StackTraceElement stack : CraftServer.excessiveVelEx.getStackTrace()) {
+                            logger.log(Level.SEVERE, "\t\t" + stack);
+                        }
+                    }
+                    // Paper end
+                } else {
+                    logger.log(Level.SEVERE, "--- DO NOT REPORT THIS TO PAPER - THIS IS NOT A BUG OR A CRASH  - " + Bukkit.getServer().getVersion() + " ---");
+                    logger.log(Level.SEVERE, "The server has not responded for " + (currentTime - lastTick) / 1000 + " seconds! Creating thread dump");
                 }
                 // Paper end - Different message for short timeout
-                log.log( Level.SEVERE, "------------------------------" );
-                log.log( Level.SEVERE, "Server thread dump (Look for plugins here before reporting to Paper!):" ); // Paper
-                ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler.dumpAllChunkLoadInfo(MinecraftServer.getServer(), isLongTimeout); // Paper - rewrite chunk system
-                this.dumpTickingInfo(); // Paper - log detailed tick information
-                WatchdogThread.dumpThread( ManagementFactory.getThreadMXBean().getThreadInfo( MinecraftServer.getServer().serverThread.getId(), Integer.MAX_VALUE ), log );
-                log.log( Level.SEVERE, "------------------------------" );
-                //
+                logger.log(Level.SEVERE, "------------------------------");
+                logger.log(Level.SEVERE, "Server thread dump (Look for plugins here before reporting to Paper!):"); // Paper
+                FeatureHooks.dumpAllChunkLoadInfo(MinecraftServer.getServer(), isLongTimeout); // Paper - log detailed tick information
+                WatchdogThread.dumpThread(ManagementFactory.getThreadMXBean().getThreadInfo(MinecraftServer.getServer().serverThread.getId(), Integer.MAX_VALUE), logger);
+                logger.log(Level.SEVERE, "------------------------------");
+
                 // Paper start - Only print full dump on long timeouts
-                if ( isLongTimeout )
-                {
-                log.log( Level.SEVERE, "Entire Thread Dump:" );
-                ThreadInfo[] threads = ManagementFactory.getThreadMXBean().dumpAllThreads( true, true );
-                for ( ThreadInfo thread : threads )
-                {
-                    WatchdogThread.dumpThread( thread, log );
-                }
+                if (isLongTimeout) {
+                    logger.log(Level.SEVERE, "Entire Thread Dump:");
+                    ThreadInfo[] threads = ManagementFactory.getThreadMXBean().dumpAllThreads(true, true);
+                    for (ThreadInfo thread : threads) {
+                        WatchdogThread.dumpThread(thread, logger);
+                    }
                 } else {
-                    log.log(Level.SEVERE, "--- DO NOT REPORT THIS TO PAPER - THIS IS NOT A BUG OR A CRASH ---");
+                    logger.log(Level.SEVERE, "--- DO NOT REPORT THIS TO PAPER - THIS IS NOT A BUG OR A CRASH ---");
                 }
 
-                log.log( Level.SEVERE, "------------------------------" );
+                logger.log(Level.SEVERE, "------------------------------");
 
-                if ( isLongTimeout )
-                {
-                if ( !server.hasStopped() )
-                {
-                    AsyncCatcher.enabled = false; // Disable async catcher incase it interferes with us
-                    server.forceTicks = true;
-                    if (restart) {
-                        RestartCommand.addShutdownHook( SpigotConfig.restartScript );
-                    }
-                    // try one last chance to safe shutdown on main incase it 'comes back'
-                    server.abnormalExit = true;
-                    server.safeShutdown(false, restart);
-                    try {
-                        Thread.sleep(1000);
-                    } catch (InterruptedException e) {
-                        e.printStackTrace();
-                    }
+                if (isLongTimeout) {
                     if (!server.hasStopped()) {
-                        server.close();
+                        AsyncCatcher.enabled = false; // Disable async catcher incase it interferes with us
+                        server.forceTicks = true;
+                        if (this.restart) {
+                            RestartCommand.addShutdownHook(SpigotConfig.restartScript);
+                        }
+                        // try one last chance to safe shutdown on main incase it 'comes back'
+                        server.abnormalExit = true;
+                        server.safeShutdown(false, this.restart);
+                        try {
+                            Thread.sleep(1000);
+                        } catch (InterruptedException e) {
+                            e.printStackTrace();
+                        }
+                        if (!server.hasStopped()) {
+                            server.close();
+                        }
                     }
+                    break;
                 }
-                break;
-                } // Paper end
+                // Paper end
             }
 
-            try
-            {
-                sleep( 1000 ); // Paper - Reduce check time to every second instead of every ten seconds, more consistent and allows for short timeout
-            } catch ( InterruptedException ex )
-            {
+            try {
+                sleep(1000); // Paper - Reduce check time to every second instead of every ten seconds, more consistent and allows for short timeout
+            } catch (InterruptedException ex) {
                 this.interrupt();
             }
         }
     }
 
-    private static void dumpThread(ThreadInfo thread, Logger log)
-    {
-        log.log( Level.SEVERE, "------------------------------" );
-        //
-        log.log( Level.SEVERE, "Current Thread: " + thread.getThreadName() );
-        log.log( Level.SEVERE, "\tPID: " + thread.getThreadId()
-                + " | Suspended: " + thread.isSuspended()
-                + " | Native: " + thread.isInNative()
-                + " | State: " + thread.getThreadState() );
-        if ( thread.getLockedMonitors().length != 0 )
-        {
-            log.log( Level.SEVERE, "\tThread is waiting on monitor(s):" );
-            for ( MonitorInfo monitor : thread.getLockedMonitors() )
-            {
-                log.log( Level.SEVERE, "\t\tLocked on:" + monitor.getLockedStackFrame() );
+    private static void dumpThread(ThreadInfo thread, Logger log) {
+        log.log(Level.SEVERE, "------------------------------");
+
+        log.log(Level.SEVERE, "Current Thread: " + thread.getThreadName());
+        log.log(Level.SEVERE, "\tPID: " + thread.getThreadId()
+            + " | Suspended: " + thread.isSuspended()
+            + " | Native: " + thread.isInNative()
+            + " | State: " + thread.getThreadState());
+        if (thread.getLockedMonitors().length != 0) {
+            log.log(Level.SEVERE, "\tThread is waiting on monitor(s):");
+            for (MonitorInfo monitor : thread.getLockedMonitors()) {
+                log.log(Level.SEVERE, "\t\tLocked on:" + monitor.getLockedStackFrame());
             }
         }
-        log.log( Level.SEVERE, "\tStack:" );
-        //
-        for ( StackTraceElement stack : io.papermc.paper.util.StacktraceDeobfuscator.INSTANCE.deobfuscateStacktrace(thread.getStackTrace()) ) // Paper
-        {
-            log.log( Level.SEVERE, "\t\t" + stack );
+        log.log(Level.SEVERE, "\tStack:");
+
+        for (StackTraceElement stack : io.papermc.paper.util.StacktraceDeobfuscator.INSTANCE.deobfuscateStacktrace(thread.getStackTrace())) { // Paper
+            log.log(Level.SEVERE, "\t\t" + stack);
         }
     }
 }
